<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ratatui Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="module">
            import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
            mermaid.initialize({ startOnLoad: true });
        </script>
        <script
            async
            src="https://umami.orhun.dev/script.js"
            data-website-id="3f27a7c3-d24f-4869-a371-8a6ba8ec6932"
        ></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction to Ratatui</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">2.</strong> Tutorials</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/hello-world/index.html"><strong aria-hidden="true">2.1.</strong> Hello World</a></li><li class="chapter-item "><a href="tutorial/counter-app/index.html"><strong aria-hidden="true">2.2.</strong> Counter App</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/counter-app/single-function.html"><strong aria-hidden="true">2.2.1.</strong> Single Function</a></li><li class="chapter-item "><a href="tutorial/counter-app/multiple-functions.html"><strong aria-hidden="true">2.2.2.</strong> Multiple Functions</a></li><li class="chapter-item "><a href="tutorial/counter-app/multiple-files.html"><strong aria-hidden="true">2.2.3.</strong> Multiple Files</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/counter-app/app.html"><strong aria-hidden="true">2.2.3.1.</strong> app.rs</a></li><li class="chapter-item "><a href="tutorial/counter-app/ui.html"><strong aria-hidden="true">2.2.3.2.</strong> ui.rs</a></li><li class="chapter-item "><a href="tutorial/counter-app/event.html"><strong aria-hidden="true">2.2.3.3.</strong> event.rs</a></li><li class="chapter-item "><a href="tutorial/counter-app/tui.html"><strong aria-hidden="true">2.2.3.4.</strong> tui.rs</a></li><li class="chapter-item "><a href="tutorial/counter-app/update.html"><strong aria-hidden="true">2.2.3.5.</strong> update.rs</a></li><li class="chapter-item "><a href="tutorial/counter-app/main.html"><strong aria-hidden="true">2.2.3.6.</strong> main.rs</a></li></ol></li></ol></li><li class="chapter-item "><a href="tutorial/json-editor/index.html"><strong aria-hidden="true">2.3.</strong> JSON Editor</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/json-editor/app.html"><strong aria-hidden="true">2.3.1.</strong> App.rs - Holding application state</a></li><li class="chapter-item "><a href="tutorial/json-editor/main.html"><strong aria-hidden="true">2.3.2.</strong> Main.rs - UI loop and event handling</a></li><li class="chapter-item "><a href="tutorial/json-editor/ui.html"><strong aria-hidden="true">2.3.3.</strong> Ui.rs - Layouts, widgets, frames, oh my!</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/json-editor/ui-main.html"><strong aria-hidden="true">2.3.3.1.</strong> Ui.rs - Main</a></li><li class="chapter-item "><a href="tutorial/json-editor/ui-editing.html"><strong aria-hidden="true">2.3.3.2.</strong> Ui.rs - Editing</a></li><li class="chapter-item "><a href="tutorial/json-editor/ui-exit.html"><strong aria-hidden="true">2.3.3.3.</strong> Ui.rs - Exit</a></li></ol></li><li class="chapter-item "><a href="tutorial/json-editor/closing_thoughts.html"><strong aria-hidden="true">2.3.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item "><a href="tutorial/counter-async-app/index.html"><strong aria-hidden="true">2.4.</strong> Async Counter App</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/counter-async-app/async-event-stream.html"><strong aria-hidden="true">2.4.1.</strong> Async KeyEvents</a></li><li class="chapter-item "><a href="tutorial/counter-async-app/full-async-events.html"><strong aria-hidden="true">2.4.2.</strong> Async Render</a></li><li class="chapter-item "><a href="tutorial/counter-async-app/actions.html"><strong aria-hidden="true">2.4.3.</strong> Introducing Actions</a></li><li class="chapter-item "><a href="tutorial/counter-async-app/full-async-actions.html"><strong aria-hidden="true">2.4.4.</strong> Async Actions</a></li><li class="chapter-item "><a href="tutorial/counter-async-app/conclusion.html"><strong aria-hidden="true">2.4.5.</strong> Conclusion</a></li></ol></li><li class="chapter-item "><a href="tutorial/stopwatch-app/index.html"><strong aria-hidden="true">2.5.</strong> Stopwatch App</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">3.</strong> Concepts</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/rendering.html"><strong aria-hidden="true">3.1.</strong> Rendering</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/rendering-under-the-hood.html"><strong aria-hidden="true">3.1.1.</strong> Under the hood</a></li></ol></li><li class="chapter-item "><a href="concepts/layout/index.html"><strong aria-hidden="true">3.2.</strong> Layout</a></li><li class="chapter-item "><a href="concepts/application-patterns/index.html"><strong aria-hidden="true">3.3.</strong> Application Patterns</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/application-patterns/the-elm-architecture.html"><strong aria-hidden="true">3.3.1.</strong> The Elm Architecture</a></li><li class="chapter-item "><a href="concepts/application-patterns/component-architecture.html"><strong aria-hidden="true">3.3.2.</strong> Component Architecture</a></li><li class="chapter-item "><a href="concepts/application-patterns/flux-architecture.html"><strong aria-hidden="true">3.3.3.</strong> Flux Architecture</a></li></ol></li><li class="chapter-item "><a href="concepts/backends/index.html"><strong aria-hidden="true">3.4.</strong> Backends</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/backends/comparison.html"><strong aria-hidden="true">3.4.1.</strong> Comparison</a></li><li class="chapter-item "><a href="concepts/backends/raw-mode.html"><strong aria-hidden="true">3.4.2.</strong> Raw Mode</a></li><li class="chapter-item "><a href="concepts/backends/alternate-screen.html"><strong aria-hidden="true">3.4.3.</strong> Alternate Screen</a></li><li class="chapter-item "><a href="concepts/backends/mouse-capture.html"><strong aria-hidden="true">3.4.4.</strong> Mouse Capture</a></li></ol></li><li class="chapter-item "><a href="concepts/event_handling.html"><strong aria-hidden="true">3.5.</strong> Event Handling</a></li></ol></li><li class="chapter-item expanded "><a href="how-to/index.html"><strong aria-hidden="true">4.</strong> How To</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how-to/layout/index.html"><strong aria-hidden="true">4.1.</strong> Layout UIs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how-to/layout/dynamic.html"><strong aria-hidden="true">4.1.1.</strong> Dynamic Layouts</a></li><li class="chapter-item "><a href="how-to/layout/center-a-rect.html"><strong aria-hidden="true">4.1.2.</strong> Center a Rect</a></li><li class="chapter-item "><a href="how-to/layout/collapse-borders.html"><strong aria-hidden="true">4.1.3.</strong> Collapse Borders</a></li></ol></li><li class="chapter-item "><a href="how-to/render/index.html"><strong aria-hidden="true">4.2.</strong> Render Text</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how-to/render/display-text.html"><strong aria-hidden="true">4.2.1.</strong> Display Text</a></li><li class="chapter-item "><a href="how-to/render/style-text.html"><strong aria-hidden="true">4.2.2.</strong> Style Text</a></li></ol></li><li class="chapter-item "><a href="how-to/widgets/index.html"><strong aria-hidden="true">4.3.</strong> Use Widgets</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how-to/widgets/paragraph.html"><strong aria-hidden="true">4.3.1.</strong> Paragraph</a></li><li class="chapter-item "><a href="how-to/widgets/block.html"><strong aria-hidden="true">4.3.2.</strong> Block</a></li><li class="chapter-item "><a href="how-to/widgets/custom.html"><strong aria-hidden="true">4.3.3.</strong> Custom</a></li></ol></li><li class="chapter-item "><a href="how-to/develop-apps/index.html"><strong aria-hidden="true">4.4.</strong> Develop Applications</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how-to/develop-apps/cli-arguments.html"><strong aria-hidden="true">4.4.1.</strong> CLI arguments</a></li><li class="chapter-item "><a href="how-to/develop-apps/config-directories.html"><strong aria-hidden="true">4.4.2.</strong> Configuration Directories</a></li><li class="chapter-item "><a href="how-to/develop-apps/tracing.html"><strong aria-hidden="true">4.4.3.</strong> Logging with Tracing</a></li><li class="chapter-item "><a href="how-to/develop-apps/abstract-terminal-and-event-handler.html"><strong aria-hidden="true">4.4.4.</strong> Async Terminal and Event handler</a></li><li class="chapter-item "><a href="how-to/develop-apps/setup-panic-hooks.html"><strong aria-hidden="true">4.4.5.</strong> Setup Panic Hooks</a></li><li class="chapter-item "><a href="how-to/develop-apps/better-panic-hooks.html"><strong aria-hidden="true">4.4.6.</strong> Better Panic Hooks</a></li><li class="chapter-item "><a href="how-to/develop-apps/migrate-from-tui-rs.html"><strong aria-hidden="true">4.4.7.</strong> Migrate from tui-rs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="faq/index.html"><strong aria-hidden="true">5.</strong> FAQ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="faq/duplicate-key-events-windows.html"><strong aria-hidden="true">5.1.</strong> Duplicate key events</a></li><li class="chapter-item "><a href="faq/tokio-async.html"><strong aria-hidden="true">5.2.</strong> tokio / async</a></li><li class="chapter-item "><a href="faq/tui-rs-history.html"><strong aria-hidden="true">5.3.</strong> tui.rs history</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Highlights</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="highlights/v0.24.html"><strong aria-hidden="true">6.1.</strong> v0.24</a></li><li class="chapter-item "><a href="highlights/v0.23.html"><strong aria-hidden="true">6.2.</strong> v0.23</a></li><li class="chapter-item "><a href="highlights/v0.22.html"><strong aria-hidden="true">6.3.</strong> v0.22</a></li><li class="chapter-item "><a href="highlights/v0.21.html"><strong aria-hidden="true">6.4.</strong> v0.21</a></li></ol></li><li class="chapter-item expanded "><a href="references/index.html"><strong aria-hidden="true">7.</strong> References</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="showcase/index.html"><strong aria-hidden="true">7.1.</strong> Showcase</a></li><li class="chapter-item "><a href="references/features.html"><strong aria-hidden="true">7.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Developer Guide</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="developer-guide/ratatui.html"><strong aria-hidden="true">8.1.</strong> Ratatui</a></li><li class="chapter-item "><a href="developer-guide/book.html"><strong aria-hidden="true">8.2.</strong> Ratatui Book</a></li><li class="chapter-item "><a href="LICENSE.html"><strong aria-hidden="true">8.3.</strong> License</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ratatui Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-ratatui"><a class="header" href="#introduction-to-ratatui">Introduction to Ratatui</a></h1>
<p><img src="https://raw.githubusercontent.com/ratatui-org/ratatui/images/examples/demo2.gif" alt="Demo" /></p>
<p><a href="https://crates.io/crates/ratatui">Ratatui</a> is a Rust library for cooking up delicious text user interfaces (TUIs). It is a
lightweight library that provides a set of widgets and utilities to build simple or complex rust
TUIs.</p>
<p>Ratatui is an <a href="https://en.wikipedia.org/wiki/Immediate_mode_(computer_graphics)">immediate mode</a> graphics library. Applications imperatively declare how to render
each frame in full by combining widgets and layout. Ratatui then draws the described UI widgets
efficiently to the terminal.</p>
<p>Applications built with Ratatui use the features of their chosen <a href="./concepts/backends">backend</a> (<a href="https://crates.io/crates/crossterm">Crossterm</a>, <a href="https://crates.io/crates/termion">Termion</a>,
or <a href="https://crates.io/crates/termwiz">Termwiz</a> to handle:</p>
<ul>
<li>keyboard input events</li>
<li>mouse events</li>
<li>switching to raw mode and the alternate screen</li>
</ul>
<p>Ratatui is very flexible and customizable. It does not dictate how you need to structure your
application, as it is a library not a framework.
This book covers some different options covering the range from simple single file applications
through more complex applications using approaches based on components, Flux and The Elm
Architecture.</p>
<h2 id="who-is-ratatui-for"><a class="header" href="#who-is-ratatui-for">Who is ratatui for?</a></h2>
<p>Ratatui is designed for developers and enthusiasts who:</p>
<ul>
<li>want a lightweight alternative to graphical user interfaces (GUIs),</li>
<li>need applications that are to be deployed in constrained environments, like on servers with
limited resources, and</li>
<li>prefer to have full control over input and events, allowing for a more customized and tailored
user experience.</li>
<li>appreciate the retro aesthetic of the terminal,</li>
</ul>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h2>
<p>In this book, we will cover beginner guides to advanced patterns for developing terminal user
interfaces.</p>
<p>Those new to the world of TUIs will find this book a comprehensive guide, introducing the
foundational concepts and walking through common patterns of using Ratatui. Additionally, developers
who have worked with TUIs will understand the nuances and benefits of using Ratatui.</p>
<p>We hope that this book can be a journey into creating beautiful and functional terminal-based
applications.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="index.html#admonition-note"></a></p>
</div>
<div>
<p>Help us improve!</p>
<p>We‚Äôve designed this user guide to aid you throughout your journey with our open-source project.
However, the beauty of open source is that it‚Äôs not just about receiving, but also contributing. We
highly encourage you to contribute to our project and help improve it even further. If you have
innovative ideas, helpful feedback, or useful suggestions, please don‚Äôt hesitate to share them with us.</p>
<p>If you see something that could be better written, feel free to <a href="https://github.com/ratatui-org/ratatui-book/issues">create an issue</a>, a
<a href="https://github.com/ratatui-org/ratatui-book/discussions">discussion thread</a> or even contribute a <a href="https://github.com/ratatui-org/ratatui-book/pulls">Pull Request</a>. We‚Äôre also often active in the
<code>#doc-discussion</code> channel on <a href="https://discord.gg/pMCEU9hNEj">Discord</a> and <a href="https://matrix.to/#/#ratatui:matrix.org">Matrix</a></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p><code>ratatui</code> is a standard rust crate and can be installed into your app using the following command:</p>
<pre><code class="language-shell">cargo add ratatui crossterm
</code></pre>
<p>or by adding the following to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
crossterm = &quot;0.27.0&quot;
ratatui = &quot;0.24.0&quot;
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="installation.html#admonition-tip"></a></p>
</div>
<div>
<p>Additionally, you can use the <code>all-widgets</code> feature, which enables additional widgets:</p>
<pre><code class="language-shell">cargo add ratatui --features all-widgets
cargo add crossterm
</code></pre>
<p>or by adding the following to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
crossterm = &quot;0.27.0&quot;
ratatui = { version = &quot;0.24.0&quot;, features = [&quot;all-widgets&quot;]}
</code></pre>
<p>You can learn more about available widgets from the
<a href="https://docs.rs/ratatui/latest/ratatui/widgets/index.html">docs.rs page on widgets</a>.</p>
</div>
</div>
<p>By default, <code>ratatui</code> enables the <code>crossterm</code>, but it‚Äôs possible to alternatively use <code>termion</code>, or
<code>termwiz</code> instead by enabling the appropriate feature and disabling the default features. See
<a href="./concepts/backends/">Backend</a> for more information.</p>
<p>For Termion:</p>
<pre><code class="language-shell">cargo add ratatui --no-default-features --features termion
cargo add termion
</code></pre>
<p>or in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ratatui = { version = &quot;0.23&quot;, default-features = false, features = [&quot;termion&quot;] }
termion = &quot;2.0.1&quot;
</code></pre>
<p>For Termwiz:</p>
<pre><code class="language-shell">cargo add ratatui --no-default-features --features termwiz
cargo add termwiz
</code></pre>
<p>or in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ratatui = { version = &quot;0.23&quot;, default-features = false, features = [&quot;termion&quot;] }
termwiz = &quot;0.20.0&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<ul>
<li><a href="tutorial/./hello-world/">Hello World</a>: This tutorial takes you through the basics of creating a simple
Ratatui application that displays ‚ÄúHello World‚Äù.</li>
<li><a href="tutorial/./counter-app/">Counter App</a>: This tutorial will set up the basics of a <code>ratatui</code> project by
building a app that displays a counter.</li>
<li><a href="tutorial/./json-editor/">JSON Editor</a>: This tutorial will guide you through setting up a Rust project and
organizing its structure for a <code>ratatui</code>-based application to edit json key value pairs. JSON
Editor TUI will provide an interface for users to input key-value pairs, which are then converted
into correct JSON format and printed to stdout.</li>
<li><a href="tutorial/./counter-async-app/">Async Counter App</a>: This tutorial, expands on the Counter app to build a an
async TUI using <a href="https://tokio.rs/">tokio</a>.</li>
<li><a href="tutorial/./stopwatch-app/">Stopwatch App</a>: This tutorial will build a working stopwatch application that
uses an external big-text widget library, runs asynchronously using tokio.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>This tutorial will lead you through creating a simple ‚ÄúHello World‚Äù TUI app that displays some text
in the middle of the screen and waits for the user to press q to exit. It demonstrates the necessary
tasks that any application developed with Ratatui needs to undertake. We assume that you have a
basic understanding of the terminal a text editor or Rust IDE (if you don‚Äôt have a preference,
<a href="https://code.visualstudio.com/">VSCode</a> makes a good default choice).</p>
<p>We‚Äôre going to build the following:</p>
<p><img src="https://github.com/ratatui-org/ratatui-book/assets/381361/b324807e-915f-45b3-a4a2-d3b419eec387" alt="hello" /></p>
<p>The full code for this tutorial is available to view at <a href="https://github.com/ratatui-org/ratatui-book/tree/main/code/hello-world-tutorial">https://github.com/ratatui-org/ratatui-book/tree/main/code/hello-world-tutorial</a></p>
<h2 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h2>
<p>The first step is to install Rust. See the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Installation</a> section of the official Rust Book for more
information. Most people tend to use <code>rustup</code>, a command line tool for managing Rust versions and
associated tools.</p>
<p>Once you‚Äôve installed Rust, verify that it‚Äôs installed by running:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>You should see output similar to the following (the exact version, date and commit hash will vary):</p>
<pre><code class="language-plain">rustc 1.72.1 (d5c2e9c34 2023-09-13)
</code></pre>
<h2 id="create-a-new-project"><a class="header" href="#create-a-new-project">Create a new project</a></h2>
<p>Let‚Äôs create a new Rust project. In the terminal, navigate to a folder where you will store your
projects and run:</p>
<pre><code class="language-shell">cargo new hello-ratatui
cd hello-ratatui
</code></pre>
<p>The <code>cargo new</code> command creates a new folder called <code>hello-ratatui</code> with a basic binary application
in it. You should see:</p>
<pre><code class="language-plain">     Created binary (application) `hello-ratatui` package
</code></pre>
<p>If you examine the folders and files created this will look like:</p>
<pre><code class="language-plain">hello-ratatui/
‚îú‚îÄ‚îÄ src/
‚îÇ  ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ Cargo.toml
</code></pre>
<p><code>cargo new</code> created a default <code>main.rs</code> with a small console program that prints ‚ÄúHello, world!‚Äù.</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre>
<p>Let‚Äôs build and execute the project. Run:</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>You should see:</p>
<pre><code class="language-plain">   Compiling hello-ratatui v0.1.0 (/Users/joshka/local/hello-ratatui)
    Finished dev [unoptimized + debuginfo] target(s) in 0.18s
     Running `target/debug/hello-ratatui`
Hello, world!
</code></pre>
<p>The default <code>main.rs</code> program is responsible for printing the last line. We‚Äôre going to replace it
with something a little bit more exciting.</p>
<h2 id="install-ratatui"><a class="header" href="#install-ratatui">Install Ratatui</a></h2>
<p>First up, we need to install the Ratatui crate into our project. We also need to install a
<a href="tutorial/hello-world/../../concepts/backends/">backend</a>. We will use <a href="https://crates.io/crates/crossterm">Crossterm</a> here as the backend as it‚Äôs compatible with most operating
systems. To install the latest version of the <code>ratatui</code> and <code>crossterm</code> crates into the project run:</p>
<pre><code class="language-shell">cargo add ratatui crossterm
</code></pre>
<p>Cargo will output the following (note that the exact versions may be later than the ones in this
tutorial).</p>
<pre><code class="language-plain">    Updating crates.io index
      Adding ratatui v0.24.0 to dependencies.
             Features:
             + crossterm
             - all-widgets
             - document-features
             - macros
             - serde
             - termion
             - termwiz
             - widget-calendar
      Adding crossterm v0.27.0 to dependencies.
             Features:
             + bracketed-paste
             + events
             + windows
             - event-stream
             - filedescriptor
             - serde
             - use-dev-tty
    Updating crates.io index
</code></pre>
<p>If you examine the <code>Cargo.toml</code> file, you should see that the new crates have been added to the
dependencies section:</p>
<pre><code class="language-toml">[dependencies]
crossterm = &quot;0.27.0&quot;
ratatui = &quot;0.24.0&quot;
</code></pre>
<h2 id="create-a-tui-application"><a class="header" href="#create-a-tui-application">Create a TUI application</a></h2>
<p>Let‚Äôs replace the default console application code that <code>cargo new</code> created with a Ratatui
application that displays a colored message the middle of the screen and waits for the user to press
a key to exit.</p>
<p>Note: a full copy of the code is available below in the <a href="tutorial/hello-world/index.html#running-the-application">Running the
application</a> section.</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>First let‚Äôs add the module imports necessary to run our application.</p>
<ul>
<li>From <code>crossterm</code> import modules, types, methods and traits to handle <a href="tutorial/hello-world/../../concepts/event_handling.html">events</a>, <a href="tutorial/hello-world/../../concepts/backends/raw-mode.html">raw mode</a>, and
the <a href="tutorial/hello-world/../../concepts/backends/alternate-screen.html">alternate screen</a>. See the <a href="https://docs.rs/crossterm/0.27.0/crossterm/">Crossterm docs</a> for more information on these types.</li>
<li>From <code>ratatui</code> import:
<ul>
<li><a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.CrosstermBackend.html"><code>CrosstermBackend</code></a>, a <a href="tutorial/hello-world/../../concepts/backends/">backend</a> implementation for Crossterm</li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/terminal/index.html"><code>Terminal</code></a> which provides the means to output to the terminal</li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/style/trait.Stylize.html"><code>Stylize</code></a>, an extension trait that adds <a href="https://docs.rs/ratatui/latest/ratatui/style/#using-style-shorthands">style shorthands</a> to other types</li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html"><code>Paragraph</code></a> widget, which is used to display text</li>
</ul>
</li>
<li>From <code>std</code> we import the <code>io::Result</code> which most of the backend methods return, and the <code>stdout()</code>
method.</li>
</ul>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-info"></a></p>
</div>
<div>
<p>Ratatui has a <a href="https://docs.rs/ratatui/latest/ratatui/prelude/index.html"><code>prelude</code></a> module that
re-exports the most used types and traits. Importing this module with a wildcard import can
simplify your application‚Äôs imports.</p>
</div>
</div>
<p>In your editor, open <code>src/main.rs</code> and add the following at the top of the file.</p>
<pre><code class="language-rust">use crossterm::{
    event::{self, KeyCode, KeyEventKind},
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    ExecutableCommand,
};
use ratatui::{
    prelude::{CrosstermBackend, Stylize, Terminal},
    widgets::Paragraph,
};
use std::io::{stdout, Result};</code></pre>
<h3 id="setting-up-and-restoring-the-terminal"><a class="header" href="#setting-up-and-restoring-the-terminal">Setting up and restoring the terminal</a></h3>
<p>Next, we need to add code to the main function to setup and restore the terminal state.</p>
<p>Our application needs to do a few things in order to setup the terminal for use:</p>
<ul>
<li>First, the application enters the <a href="tutorial/hello-world/../../concepts/backends/alternate-screen.html">alternate screen</a>, which is a secondary screen that allows your
application to render whatever it needs to, without disturbing the normal output of terminal apps
in your shell.</li>
<li>Next, the application enables <a href="tutorial/hello-world/../../concepts/backends/raw-mode.html">raw mode</a>, which turns off input and output processing by the
terminal. This allows our application control when characters are printed to the screen.</li>
<li>The app then creates a <a href="tutorial/hello-world/../../concepts/backends/">backend</a> and <a href="https://docs.rs/ratatui/latest/ratatui/terminal/index.html"><code>Terminal</code></a> and then clears the screen.</li>
</ul>
<p>When the application is finished it needs to restore the terminal state by leaving the alternate
screen and disabling raw mode.</p>
<p>Replace the existing <code>main</code> function with the following:</p>
<pre><code class="language-rust no_run">fn main() -&gt; Result&lt;()&gt; {
    stdout().execute(EnterAlternateScreen)?;
    enable_raw_mode()?;
    let mut terminal = Terminal::new(CrosstermBackend::new(stdout()))?;
    terminal.clear()?;

    // TODO main loop

    stdout().execute(LeaveAlternateScreen)?;
    disable_raw_mode()?;
    Ok(())
}</code></pre>
<div id="admonition-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-warning"></a></p>
</div>
<div>
<p>If we don‚Äôt disable raw mode before exit, terminals can act weirdly when the mouse or
navigation keys are pressed. To fix this, on a Linux / macOS terminal type <code>reset</code>.
On Windows, you‚Äôll have to close the tab and open a new terminal.</p>
</div>
</div>
<h3 id="add-a-main-loop"><a class="header" href="#add-a-main-loop">Add a main loop</a></h3>
<p>The main part of our application is the main loop. Our application repeatedly draws the ui and then
handles any events that have occurred.</p>
<p>Replace <code>// TODO main loop</code> with a loop:</p>
<pre><code class="language-rust no_run">    loop {
        // TODO draw
        // TODO handle events
    }</code></pre>
<h3 id="draw-to-the-terminal"><a class="header" href="#draw-to-the-terminal">Draw to the terminal</a></h3>
<p>The <code>draw</code> method on <a href="https://docs.rs/ratatui/latest/ratatui/terminal/index.html"><code>terminal</code></a> is the main interaction point that an app has with Ratatui. The
<code>draw</code> method accepts a closure that has a single <a href="https://docs.rs/ratatui/latest/ratatui/struct.Frame.html"><code>Frame</code></a> parameter, and renders the entire
screen. Our application creates an area that is the full size of the terminal window and renders
a new Paragraph with white foreground text and a blue background. The <code>white()</code> and <code>on_blue()</code>
methods are defined in the <a href="https://docs.rs/ratatui/latest/ratatui/style/trait.Stylize.html"><code>Stylize</code></a> extension trait as <a href="https://docs.rs/ratatui/latest/ratatui/style/#using-style-shorthands">style shorthands</a>, rather than on the
<a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html"><code>Paragraph</code></a> widget.</p>
<p>Replace <code>// TODO draw</code> with the following</p>
<pre><code class="language-rust no_run">        terminal.draw(|frame| {
            let area = frame.size();
            frame.render_widget(
                Paragraph::new(&quot;Hello Ratatui! (press 'q' to quit)&quot;)
                    .white()
                    .on_blue(),
                area,
            );
        })?;</code></pre>
<h3 id="handle-events"><a class="header" href="#handle-events">Handle events</a></h3>
<p>After Ratatui has drawn a frame, our application needs to check to see if any events have occurred.
These are things like keyboard presses, mouse events, resizes, etc. If the user has pressed the <code>q</code>
key, we break out of the loop. We add a small timeout to the event polling to ensure that our UI
remains responsive regardless of whether there are events pending (16ms is ~60fps). Note that it‚Äôs
important to check that the event kind is <code>Press</code> otherwise Windows terminals will see each key
twice.</p>
<p>Replace <code>// TODO handle events</code> with:</p>
<pre><code class="language-rust no_run">        if event::poll(std::time::Duration::from_millis(16))? {
            if let event::Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press &amp;&amp; key.code == KeyCode::Char('q') {
                    break;
                }
            }
        }</code></pre>
<h2 id="running-the-application"><a class="header" href="#running-the-application">Running the Application</a></h2>
<p>Your application should look like:</p>
<details><summary>main.rs</summary>
<pre><code class="language-rust no_run">use crossterm::{
    event::{self, KeyCode, KeyEventKind},
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    ExecutableCommand,
};
use ratatui::{
    prelude::{CrosstermBackend, Stylize, Terminal},
    widgets::Paragraph,
};
use std::io::{stdout, Result};

fn main() -&gt; Result&lt;()&gt; {
    stdout().execute(EnterAlternateScreen)?;
    enable_raw_mode()?;
    let mut terminal = Terminal::new(CrosstermBackend::new(stdout()))?;
    terminal.clear()?;

    loop {
        terminal.draw(|frame| {
            let area = frame.size();
            frame.render_widget(
                Paragraph::new(&quot;Hello Ratatui! (press 'q' to quit)&quot;)
                    .white()
                    .on_blue(),
                area,
            );
        })?;

        if event::poll(std::time::Duration::from_millis(16))? {
            if let event::Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press &amp;&amp; key.code == KeyCode::Char('q') {
                    break;
                }
            }
        }
    }

    stdout().execute(LeaveAlternateScreen)?;
    disable_raw_mode()?;
    Ok(())
}</code></pre>
</details>
<p>Make sure you save the file! Let‚Äôs run the app:</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>You should see a TUI app with <code>Hello Ratatui! (press 'q' to quit)</code> show up in your terminal as a TUI
app.</p>
<p><img src="https://github.com/ratatui-org/ratatui-book/assets/381361/98eee556-6283-4aa5-a068-99392e1a5dda" alt="hello" /></p>
<p>You can press <code>q</code> to exit and go back to your terminal as it was before.</p>
<p>Congratulations! üéâ</p>
<p>You have written a ‚Äúhello world‚Äù terminal user interface with <code>ratatui</code>. We will learn more about
how <code>ratatui</code> works in the next sections.</p>
<div id="admonition-question" class="admonition admonish-question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-question"></a></p>
</div>
<div>
<p>Can you modify the example above to exit when pressing <code>q</code> <em>or</em> when pressing <code>Q</code>?</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter-app"><a class="header" href="#counter-app">Counter App</a></h1>
<p>In the previous section, we built a ‚Äúhello world‚Äù TUI. In this tutorial, we‚Äôll develop a simple
counter application.</p>
<p>For the app, we‚Äôll need a <code>Paragraph</code> to display the counter. We‚Äôll also want to increment or
decrement the counter when a key is pressed. Let‚Äôs increment and decrement the counter with <code>j</code> and
<code>k</code>.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>Go ahead and set up a new rust project with</p>
<pre><code class="language-shell">cargo new ratatui-counter-app
cd ratatui-counter-app
</code></pre>
<p>We are only going to use 3 dependencies in this tutorial:</p>
<pre><code class="language-shell">cargo add ratatui crossterm anyhow
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/index.html#admonition-tip"></a></p>
</div>
<div>
<p>We opt to use the <code>anyhow</code> crate for easier error handling; it is not necessary to build apps with <code>ratatui</code>.</p>
</div>
</div>
<h2 id="filestructure"><a class="header" href="#filestructure">Filestructure</a></h2>
<p>We are going to start off like in the previous ‚Äúhello world‚Äù tutorial with one file like so:</p>
<pre><code class="language-plain">tree .
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ LICENSE
‚îî‚îÄ‚îÄ src
   ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<p>but this time for the counter example, we will expand it out to multiple files like so:</p>
<pre><code class="language-plain">tree .
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ LICENSE
‚îî‚îÄ‚îÄ src
   ‚îú‚îÄ‚îÄ app.rs
   ‚îú‚îÄ‚îÄ event.rs
   ‚îú‚îÄ‚îÄ lib.rs
   ‚îú‚îÄ‚îÄ main.rs
   ‚îú‚îÄ‚îÄ tui.rs
   ‚îú‚îÄ‚îÄ ui.rs
   ‚îî‚îÄ‚îÄ update.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-function"><a class="header" href="#single-function">Single Function</a></h1>
<p>In this section, we‚Äôll walk through building a simple counter application, allowing users to
increase or decrease a displayed number using keyboard input.</p>
<p>Here‚Äôs a first pass at a counter application in Rust using <code>ratatui</code> where all the code is in one
<code>main</code> function:</p>
<pre><code class="language-rust">use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  // startup: Enable raw mode for the terminal, giving us fine control over user input
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  // Initialize the terminal backend using crossterm
  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // Define our counter variable
  // This is the state of our application
  let mut counter = 0;

  // Main application loop
  loop {
    // Render the UI
    terminal.draw(|f| {
      f.render_widget(Paragraph::new(format!(&quot;Counter: {counter}&quot;)), f.size());
    })?;

    // Check for user input every 250 milliseconds
    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      // If a key event occurs, handle it
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        if key.kind == crossterm::event::KeyEventKind::Press {
          match key.code {
            crossterm::event::KeyCode::Char('j') =&gt; counter += 1,
            crossterm::event::KeyCode::Char('k') =&gt; counter -= 1,
            crossterm::event::KeyCode::Char('q') =&gt; break,
            _ =&gt; {},
          }
        }
      }
    }
  }

  // shutdown down: reset terminal back to original state
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;

  Ok(())
}</code></pre>
<p>In the code above, it is useful to think about various parts of the code as separate pieces of the
puzzle. This is useful to help refactor and reorganize your code for larger applications.</p>
<h2 id="imports-1"><a class="header" href="#imports-1">Imports</a></h2>
<p>We start by importing necessary components from the <code>ratatui</code> library, which provides a number of
different widgets and utilities.</p>
<pre><code class="language-rust">use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};</code></pre>
<h2 id="start-up"><a class="header" href="#start-up">Start up</a></h2>
<p>Using <code>crossterm</code>, we can set the terminal to raw mode and enter an alternate screen.</p>
<pre><code class="language-rust">crossterm::terminal::enable_raw_mode()?;
crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;</code></pre>
<h2 id="initialize"><a class="header" href="#initialize">Initialize</a></h2>
<p>Again using <code>crossterm</code>, we can create an instance of terminal backend</p>
<pre><code class="language-rust">let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;</code></pre>
<h2 id="shut-down"><a class="header" href="#shut-down">Shut down</a></h2>
<p>Terminal disables raw mode and exits the alternate screen for a clean exit, ensuring the terminal
returns to its original state</p>
<pre><code class="language-rust">crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
crossterm::terminal::disable_raw_mode()?;</code></pre>
<h2 id="app-state"><a class="header" href="#app-state">App state</a></h2>
<p>Our application has just one variable that tracks the ‚Äústate‚Äù, i.e. the counter value.</p>
<pre><code class="language-rust">let mut counter = 0;</code></pre>
<h2 id="run-loop"><a class="header" href="#run-loop">Run loop</a></h2>
<p>Our application runs in a continuous loop, constantly checking for user input and updating the
state, which in turn updates the display on the next loop.</p>
<pre><code class="language-rust">  // Main application loop
  loop {
    // draw UI based on state
    // ...
    // Update state based on user input
    // ...
    // Break from loop based on user input and/or state
  }</code></pre>
<p>Every TUI with <code>ratatui</code> is bound to have (at least) one main application run loop like this.</p>
<h2 id="user-interface"><a class="header" href="#user-interface">User interface</a></h2>
<p>The UI part of our code takes the state of the application, i.e. the value of <code>counter</code> and uses it
to render a widget, i.e. a <code>Paragraph</code> widget.</p>
<pre><code class="language-rust">    terminal.draw(|f| {
      f.render_widget(Paragraph::new(format!(&quot;Counter: {counter}&quot;)), f.size());
    })?;</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/single-function.html#admonition-note"></a></p>
</div>
<div>
<p>The closure passed to the <code>Terminal::draw()</code> method must render the entire UI. Call the
draw method at most once for each pass through your application‚Äôs main loop.
<a href="tutorial/counter-app/./../../faq/">See the FAQ for more information.</a></p>
</div>
</div>
<h2 id="user-input"><a class="header" href="#user-input">User input</a></h2>
<p>Every 250 milliseconds, the application checks if the user has pressed a key:</p>
<ul>
<li><code>j</code> increases the counter</li>
<li><code>k</code> decreases the counter</li>
<li><code>q</code> exits the application</li>
</ul>
<p>For Linux and MacOS, you‚Äôll be able to write code like the following:</p>
<pre><code class="language-rust">    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        match key.code {
          crossterm::event::KeyCode::Char('j') =&gt; counter += 1,
          crossterm::event::KeyCode::Char('k') =&gt; counter -= 1,
          crossterm::event::KeyCode::Char('q') =&gt; break,
          _ =&gt; {},
        }
      }
    }</code></pre>
<p>On <code>MacOS</code> and <code>Linux</code> only <code>KeyEventKind::Press</code> kinds of <code>key</code> event is generated. However, on
Windows when using <code>Crossterm</code>, the above code will send the same <code>Event::Key(e)</code> twice; one for
when you press the key, i.e. <code>KeyEventKind::Press</code> and one for when you release the key, i.e.
<code>KeyEventKind::Release</code>.</p>
<p>To make the code work in a cross platform manner, you‚Äôll want to check that <code>key.kind</code> is
<code>KeyEventKind::Press</code>, like so:</p>
<pre><code class="language-rust">    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        // check if key.kind is a `KeyEventKind::Press`
        if key.kind == crossterm::event::KeyEventKind::Press {
          match key.code {
            crossterm::event::KeyCode::Char('j') =&gt; counter += 1,
            crossterm::event::KeyCode::Char('k') =&gt; counter -= 1,
            crossterm::event::KeyCode::Char('q') =&gt; break,
            _ =&gt; {},
          }
        }
      }
    }</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>By understanding the structure and components used in this simple counter application, you are set
up to explore crafting more intricate terminal-based interfaces using <code>ratatui</code>.</p>
<p>In the next section, we will explore a refactor of the above code to separate the various parts into
individual functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-functions"><a class="header" href="#multiple-functions">Multiple Functions</a></h1>
<p>In this section, we will walk through the process of refactoring the application to set ourselves up
better for bigger projects. Not all of these changes are <code>ratatui</code> specific, and are generally good
coding practices to follow.</p>
<p>We are still going to keep everything in one file for this section, but we are going to split the
previous functionality into separate functions.</p>
<h2 id="organizing-imports"><a class="header" href="#organizing-imports">Organizing imports</a></h2>
<p>The first thing you might consider doing is reorganizing imports with qualified names.</p>
<pre><code class="language-rust">use crossterm::{
  event::{self, Event::Key, KeyCode::Char},
  execute,
  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};</code></pre>
<h2 id="typedefs-and-type-aliases"><a class="header" href="#typedefs-and-type-aliases">Typedefs and Type Aliases</a></h2>
<p>By defining custom types and aliases, we can simplify our code and make it more expressive.</p>
<pre><code class="language-rust">type Err = Box&lt;dyn std::error::Error&gt;;
type Result&lt;T&gt; = std::result::Result&lt;T, Err&gt;;
pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/multiple-functions.html#admonition-tip"></a></p>
</div>
<div>
<p>If you use the popular <a href="https://docs.rs/anyhow/latest/anyhow/"><code>anyhow</code></a>
then instead of these two lines:</p>
<pre><code class="language-rust">type Err = Box&lt;dyn std::error::Error&gt;;
type Result&lt;T&gt; = std::result::Result&lt;T, Err&gt;;</code></pre>
<p>you can simply import <code>Result</code> from <code>anyhow</code>:</p>
<pre><code class="language-rust">use anyhow::Result;</code></pre>
<p>You will need to run <code>cargo add anyhow</code> for this to work.</p>
</div>
</div>
<p><code>Frame</code> is a shorthand type to represent the frame we draw to when we render our application.</p>
<h2 id="app-struct"><a class="header" href="#app-struct"><code>App</code> struct</a></h2>
<p>By defining an <code>App</code> struct, we can encapsulate our application state and make it more structured.</p>
<pre><code class="language-rust">struct App {
  counter: i64,
  should_quit: bool,
}</code></pre>
<ul>
<li><code>counter</code> holds the current value of our counter.</li>
<li><code>should_quit</code> is a flag that indicates whether the application should exit its main loop.</li>
</ul>
<h2 id="breaking-up-main"><a class="header" href="#breaking-up-main">Breaking up <code>main()</code></a></h2>
<p>We can extract significant parts of the <code>main()</code> function into separate smaller functions, e.g.
<code>startup()</code>, <code>shutdown()</code>, <code>ui()</code>, <code>update()</code>, <code>run()</code>.</p>
<p><code>startup()</code> is responsible for initializing the terminal.</p>
<pre><code class="language-rust">fn startup() -&gt; Result&lt;()&gt; {
  enable_raw_mode()?;
  execute!(std::io::stderr(), EnterAlternateScreen)?;
  Ok(())
}</code></pre>
<p><code>shutdown()</code> cleans up the terminal.</p>
<pre><code class="language-rust">fn shutdown() -&gt; Result&lt;()&gt; {
  execute!(std::io::stderr(), LeaveAlternateScreen)?;
  disable_raw_mode()?;
  Ok(())
}</code></pre>
<p><code>ui()</code> handles rendering of our application state.</p>
<pre><code class="language-rust">fn ui(app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}</code></pre>
<p><code>update()</code> processes user input and updates our application state.</p>
<pre><code class="language-rust">fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
  if event::poll(std::time::Duration::from_millis(250))? {
    if let Key(key) = event::read()? {
      if key.kind == event::KeyEventKind::Press {
        match key.code {
          Char('j') =&gt; app.counter += 1,
          Char('k') =&gt; app.counter -= 1,
          Char('q') =&gt; app.should_quit = true,
          _ =&gt; {},
        }
      }
    }
  }
  Ok(())
}</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/multiple-functions.html#admonition-tip-1"></a></p>
</div>
<div>
<p>You‚Äôll notice that in the <code>update()</code> function we make use of pattern matching for handling user
input. This is a powerful feature in rust; and enhances readability and provides a clear pattern for
how each input is processed.</p>
<p>You can learn more about <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">pattern matching in the official rust
book</a>.</p>
</div>
</div>
<p><code>run()</code> contains our main application loop.</p>
<pre><code class="language-rust">fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    // application render
    t.draw(|f| {
      ui(&amp;app, f);
    })?;

    // application update
    update(&amp;mut app)?;

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}</code></pre>
<p>Each function now has a specific task, making our main application logic more organized and easier
to follow.</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  let status = run();
  shutdown()?;
  status?;
  Ok(())
}</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/multiple-functions.html#admonition-note"></a></p>
</div>
<div>
<p>You may be wondering if we could have written the <code>main</code> function like so:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  run()?;
  shutdown()?;
  Ok(())
}</code></pre>
<p>This works fine during the happy path of a program.</p>
<p>However, if your <code>run()</code> function returns an error, the program will not call <code>shutdown()</code>.
And this can leave your terminal in a messed up
state for your users.</p>
<p>Instead, we should ensure that <code>shutdown()</code> is <em>always</em> called before the program exits.</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  let result = run();
  shutdown()?;
  result?;
  Ok(())
}</code></pre>
<p>Here, we can get the result of <code>run()</code>, and call <code>shutdown()</code> first and then <code>unwrap()</code> on the result.
This will be a much better experience for users.</p>
<p>We will discuss in future sections how to handle the situation when your code unexpectedly panics.</p>
</div>
</div>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>By making our code more organized, modular, and readable, we not only make it easier for others to
understand and work with but also set the stage for future enhancements and extensions.</p>
<p>Here‚Äôs the full code for reference:</p>
<pre><code class="language-rust">use anyhow::Result;
use crossterm::{
  event::{self, Event::Key, KeyCode::Char},
  execute,
  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

fn startup() -&gt; Result&lt;()&gt; {
  enable_raw_mode()?;
  execute!(std::io::stderr(), EnterAlternateScreen)?;
  Ok(())
}

fn shutdown() -&gt; Result&lt;()&gt; {
  execute!(std::io::stderr(), LeaveAlternateScreen)?;
  disable_raw_mode()?;
  Ok(())
}

// App state
struct App {
  counter: i64,
  should_quit: bool,
}

// App ui render function
fn ui(app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}

// App update function
fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
  if event::poll(std::time::Duration::from_millis(250))? {
    if let Key(key) = event::read()? {
      if key.kind == event::KeyEventKind::Press {
        match key.code {
          Char('j') =&gt; app.counter += 1,
          Char('k') =&gt; app.counter -= 1,
          Char('q') =&gt; app.should_quit = true,
          _ =&gt; {},
        }
      }
    }
  }
  Ok(())
}

fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    // application update
    update(&amp;mut app)?;

    // application render
    t.draw(|f| {
      ui(&amp;app, f);
    })?;

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
  // setup terminal
  startup()?;

  let result = run();

  // teardown terminal before unwrapping Result of app run
  shutdown()?;

  result?;

  Ok(())
}</code></pre>
<p>Here‚Äôs a flow chart representation of the various steps in the program:</p>
<pre class="mermaid">graph TD
    MainRun[Main: Run];
    CheckEvent[Main: Poll KeyPress];
    UpdateApp[Main: Update App];
    ShouldQuit[Main: Check should_quit?];
    BreakLoop[Main: Break Loop];
    MainStart[Main: Start];
    MainEnd[Main: End];
    MainStart --&gt; MainRun;
    MainRun --&gt; CheckEvent;
    CheckEvent --&gt;|No KeyPress| Draw;
    CheckEvent --&gt; |KeyPress Received| UpdateApp;
    Draw --&gt; ShouldQuit;
    UpdateApp --&gt; Draw;
    ShouldQuit --&gt;|Yes| BreakLoop;
    BreakLoop --&gt; MainEnd;
    ShouldQuit --&gt;|No| CheckEvent;
</pre>
<div id="admonition-question" class="admonition admonish-question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/multiple-functions.html#admonition-question"></a></p>
</div>
<div>
<p>What do you think happens if you modify the example above to change the polling to <code>0</code> milliseconds?</p>
<p>What would happen if you change the example to poll every 10 seconds?</p>
<p>Experiment with different ‚Äútick rates‚Äù and see how that affects the user experience.
Monitor your CPU usage when you do this experiment.
What happens to your CPU usage as you change the poll frequency?</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-files"><a class="header" href="#multiple-files">Multiple Files</a></h1>
<p>At the moment, we have everything in just one file. However, this can be impractical if we want to
expand our app further.</p>
<p>Let‚Äôs start by creating a number of different files to represent the various concepts we covered in
the previous section:</p>
<pre><code class="language-bash">$ tree .
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ LICENSE
‚îî‚îÄ‚îÄ src
   ‚îú‚îÄ‚îÄ app.rs
   ‚îú‚îÄ‚îÄ event.rs
   ‚îú‚îÄ‚îÄ main.rs
   ‚îú‚îÄ‚îÄ tui.rs
   ‚îú‚îÄ‚îÄ ui.rs
   ‚îî‚îÄ‚îÄ update.rs
</code></pre>
<p>If you want to explore the code on your own, you can check out the completed source code here:
<a href="https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/counter-app/ratatui-counter-app">https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/counter-app/ratatui-counter-app</a></p>
<p>Let‚Äôs go ahead and declare these files as modules in <code>src/main.rs</code></p>
<pre><code class="language-rust">/// Application.
pub mod app;

/// Terminal events handler.
pub mod event;

/// Widget renderer.
pub mod ui;

/// Terminal user interface.
pub mod tui;

/// Application updater.
pub mod update;</code></pre>
<p>We are going to use <code>anyhow</code> in this section of the tutorial.</p>
<pre><code class="language-bash">cargo add anyhow
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/multiple-files.html#admonition-tip"></a></p>
</div>
<div>
<p>Instead of <code>anyhow</code> you can also use <a href="https://github.com/eyre-rs/eyre"><code>eyre</code></a> or <a href="https://github.com/eyre-rs/color-eyre"><code>color-eyre</code></a>.</p>
<pre><code class="language-diff">- use anyhow::Result;
+ use color_eyre::eyre::Result;
</code></pre>
<p>You‚Äôll need to add <code>color-eyre</code> and remove <code>anyhow</code>:</p>
<pre><code class="language-shell">cargo remove anyhow
cargo add color-eyre
</code></pre>
<p>If you are using <code>color_eyre</code>, you‚Äôll also want to add <code>color_eyre::install()?</code> to the beginning of
your <code>main()</code> function:</p>
<pre><code class="language-rust">use color_eyre::eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    color_eyre::install()?;
    // ...
    Ok(())
}</code></pre>
<p><code>color_eyre</code> is an error report handler for colorful, consistent, and well formatted error
reports for all kinds of errors.
Check out the <a href="tutorial/counter-app/../../how-to/develop-apps/setup-panic-hooks-color-eyre.html">section</a> for
setting up panic hooks with color-eyre.</p>
</div>
</div>
<p>Now we are ready to start refactoring our app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprs"><a class="header" href="#apprs">app.rs</a></h1>
<p>Let‚Äôs start with the same <code>struct</code> as we had before:</p>
<pre><code class="language-rust">/// Application.
#[derive(Debug, Default)]
pub struct App {
  /// should the application exit?
  pub should_quit: bool,
  /// counter
  pub counter: u8,
}</code></pre>
<p>We can add additional methods to this <code>Application</code> struct:</p>
<pre><code class="language-rust">impl App {
  /// Constructs a new instance of [`App`].
  pub fn new() -&gt; Self {
    Self::default()
  }

  /// Handles the tick event of the terminal.
  pub fn tick(&amp;self) {}

  /// Set running to false to quit the application.
  pub fn quit(&amp;mut self) {
    self.should_quit = true;
  }

  pub fn increment_counter(&amp;mut self) {
    if let Some(res) = self.counter.checked_add(1) {
      self.counter = res;
    }
  }

  pub fn decrement_counter(&amp;mut self) {
    if let Some(res) = self.counter.checked_sub(1) {
      self.counter = res;
    }
  }
}</code></pre>
<p>We use the principle of encapsulation to expose an interface to modify the state. In this particular
instance, it may seem like overkill but it is good practice nonetheless.</p>
<p>The practical advantage of this is that it makes the state changes easy to test.</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
  use super::*;
  #[test]
  fn test_app_increment_counter() {
    let mut app = App::default();
    app.increment_counter();
    assert_eq!(app.counter, 1);
  }

  #[test]
  fn test_app_decrement_counter() {
    let mut app = App::default();
    app.decrement_counter();
    assert_eq!(app.counter, 0);
  }
}</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/app.html#admonition-tip"></a></p>
</div>
<div>
<p>You can test a single function by writing out fully qualified module path
to the test function, like so:</p>
<pre><code class="language-bash">cargo test -- app::tests::test_app_increment_counter --nocapture
</code></pre>
<p>Or even test all functions that start with <code>test_app_</code> by doing this:</p>
<pre><code class="language-bash">cargo test -- app::tests::test_app_ --nocapture
</code></pre>
<p>The <code>--nocapture</code> flag prints stdout and stderr to the console, which can help debugging tests.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uirs"><a class="header" href="#uirs">ui.rs</a></h1>
<p>Previously we were rendering a <code>Paragraph</code> with no styling.</p>
<p>Let‚Äôs make some improvements:</p>
<ol>
<li>Add a <code>Block</code> with a rounded border and the title <code>&quot;Counter App&quot;</code>.</li>
<li>Make everything in the Paragraph have a foreground color of <code>Color::Yellow</code></li>
</ol>
<p>This is what our code will now look like:</p>
<pre><code class="language-rust">use ratatui::{
  prelude::{Alignment, Frame},
  style::{Color, Style},
  widgets::{Block, BorderType, Borders, Paragraph},
};

use crate::app::App;

pub fn render(app: &amp;mut App, f: &amp;mut Frame) {
  f.render_widget(
    Paragraph::new(format!(
      &quot;
        Press `Esc`, `Ctrl-C` or `q` to stop running.\n\
        Press `j` and `k` to increment and decrement the counter respectively.\n\
        Counter: {}
      &quot;,
      app.counter
    ))
    .block(
      Block::default()
        .title(&quot;Counter App&quot;)
        .title_alignment(Alignment::Center)
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded),
    )
    .style(Style::default().fg(Color::Yellow))
    .alignment(Alignment::Center),
    f.size(),
  )
}</code></pre>
<p>Keep in mind it won‚Äôt render until we have written the code for <code>tui::Frame</code></p>
<p>When rendered, this is what the UI will look like:</p>
<p><img src="https://user-images.githubusercontent.com/1813121/263155937-d8a8b6f6-97f4-4839-b855-ffd0249c2ae0.png" alt="Counter app demo" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventrs"><a class="header" href="#eventrs">event.rs</a></h1>
<p>Most applications will have a main run loop like this:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  crossterm::terminal::enable_raw_mode()?; // enter raw mode
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;
<span class="boring">  let mut app = App::new();
</span><span class="boring">  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
</span>  // --snip--
  loop {
    // --snip--
<span class="boring">    terminal.draw(|f| { // &lt;- `terminal.draw` is the only ratatui function here
</span><span class="boring">      ui(app, f) // render state to terminal
</span><span class="boring">    })?;
</span>  }
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?; // exit raw mode
  Ok(())
}</code></pre>
<p>While the application is in the ‚Äúraw mode‚Äù, any key presses in that terminal window are sent to
<code>stdin</code>. We have to make sure that the application reads these key presses from <code>stdin</code> if we want
to act on them.</p>
<p>In the tutorials up until now, we have been using <code>crossterm::event::poll()</code> and
<code>crossterm::event::read()</code>, like so:</p>
<pre><code class="language-rust"><span class="boring">fn main() -&gt; Result {
</span><span class="boring">  let mut app = App::new();
</span><span class="boring">
</span><span class="boring">  let mut t = Tui::new()?;
</span><span class="boring">
</span><span class="boring">  t.enter()?;
</span><span class="boring">
</span>  loop {
    // crossterm::event::poll() here will block for a maximum 250ms
    // will return true as soon as key is available to read
    if crossterm::event::poll(Duration::from_millis(250))? {

      // crossterm::event::read() blocks till it can read single key
      // when used with poll, key is always available
      if let Event::Key(key) = crossterm::event::read()? {

        if key.kind == event::KeyEventKind::Press {
          match key.code {
            KeyCode::Char('j') =&gt; app.increment(),
            KeyCode::Char('k') =&gt; app.decrement(),
            KeyCode::Char('q') =&gt; break,
            _ =&gt; {},
          }
        }

      }

    };
    t.terminal.draw(|f| {
      ui(app, f)
    })?;
  }
<span class="boring">
</span><span class="boring">  t.exit()?;
</span><span class="boring">
</span><span class="boring">  Ok(())
</span><span class="boring">}</span></code></pre>
<p><code>crossterm::event::poll()</code> blocks till a key is received on <code>stdin</code>, at which point it returns
<code>true</code> and <code>crossterm::event::read()</code> reads the single key event.</p>
<p>This works perfectly fine, and a lot of small to medium size programs can get away with doing just
that.</p>
<p>However, this approach conflates the key input handling with app state updates, and does so in the
‚Äúdraw‚Äù loop. The practical issue with this approach is we block the draw loop for 250 ms waiting for
a key press. This can have odd side effects, for example pressing and holding a key will result in
faster draws to the terminal. You can try this out by pressing and holding any key and watching your
CPU usage using <code>top</code> or <code>htop</code>.</p>
<p>In terms of architecture, the code could get complicated to reason about. For example, we may even
want key presses to mean <em>different</em> things depending on the state of the app (when you are focused
on an input field, you may want to enter the letter <code>&quot;j&quot;</code> into the text input field, but when
focused on a list of items, you may want to scroll down the list.)</p>
<p><img src="https://user-images.githubusercontent.com/1813121/254444604-de8cfcfa-eeec-417a-a8b0-92a7ccb5fcb5.gif" alt="Pressing j 3 times to increment counter and 3 times in the text field" /></p>
<!--
```
Set Shell zsh
Sleep 1s
Hide
Type "cargo run"
Enter
Sleep 1s
Show
Type "jjj"
Sleep 5s
Sleep 5s
Type "/jjj"
Sleep 5s
Escape
Type "q"
```
-->
<p>We have to do a few different things set ourselves up, so let‚Äôs take things one step at a time.</p>
<p>First, instead of polling, we are going to introduce channels to get the key presses ‚Äúin the
background‚Äù and send them over a channel. We will then receive these events on the channel in the
<code>main</code> loop.</p>
<p>Let‚Äôs create an <code>Event</code> enum to handle the different kinds of events that can occur:</p>
<pre><code class="language-rust">use crossterm::event::{KeyEvent, MouseEvent};

/// Terminal events.
#[derive(Clone, Copy, Debug)]
pub enum Event {
  /// Terminal tick.
  Tick,
  /// Key press.
  Key(KeyEvent),
  /// Mouse click/scroll.
  Mouse(MouseEvent),
  /// Terminal resize.
  Resize(u16, u16),
}</code></pre>
<p>Next, let‚Äôs create an <code>EventHandler</code> struct:</p>
<pre><code class="language-rust">use std::{sync::mpsc, thread};

/// Terminal event handler.
#[derive(Debug)]
pub struct EventHandler {
  /// Event sender channel.
  #[allow(dead_code)]
  sender: mpsc::Sender&lt;Event&gt;,
  /// Event receiver channel.
  receiver: mpsc::Receiver&lt;Event&gt;,
  /// Event handler thread.
  #[allow(dead_code)]
  handler: thread::JoinHandle&lt;()&gt;,
}</code></pre>
<p>We are using <a href="https://doc.rust-lang.org/std/sync/mpsc/"><code>std::sync::mpsc</code></a> which is a ‚ÄúMultiple
Producer Single Consumer‚Äù channel.</p>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/event.html#admonition-tip"></a></p>
</div>
<div>
<p>A channel is a thread-safe communication mechanism that allows data to be transmitted between
threads. Essentially, it‚Äôs a conduit where one or more threads (the producers) can send data, and
another thread (the consumer) can receive this data.</p>
</div>
</div>
<p>In Rust, channels are particularly useful for sending data between threads without the need for
locks or other synchronization mechanisms. The ‚ÄúMultiple Producer, Single Consumer‚Äù aspect of
<code>std::sync::mpsc</code> means that while multiple threads can send data into the channel, only a single
thread can retrieve and process this data, ensuring a clear and orderly flow of information.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/event.html#admonition-note"></a></p>
</div>
<div>
<p>In the code in this section, we only need a ‚ÄúSingle Producer, Single Consumer‚Äù but we are going to
use <code>mpsc</code> to set us up for the future.</p>
</div>
</div>
<p>Finally, here‚Äôs the code that starts a thread that polls for events from <code>crossterm</code> and maps it to
our <code>Event</code> enum.</p>
<pre><code class="language-rust">use std::{
  sync::mpsc,
  thread,
  time::{Duration, Instant},
};

use anyhow::Result;
use crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};

// -- snip --

impl EventHandler {
  /// Constructs a new instance of [`EventHandler`].
  pub fn new(tick_rate: u64) -&gt; Self {
    let tick_rate = Duration::from_millis(tick_rate);
    let (sender, receiver) = mpsc::channel();
    let handler = {
      let sender = sender.clone();
      thread::spawn(move || {
        let mut last_tick = Instant::now();
        loop {
          let timeout = tick_rate.checked_sub(last_tick.elapsed()).unwrap_or(tick_rate);

          if event::poll(timeout).expect(&quot;no events available&quot;) {
            match event::read().expect(&quot;unable to read event&quot;) {
              CrosstermEvent::Key(e) =&gt; {
                if e.kind == event::KeyEventKind::Press {
                  sender.send(Event::Key(e))
                } else {
                  Ok(()) // ignore KeyEventKind::Release on windows
                }
              },
              CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e)),
              CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h)),
              _ =&gt; unimplemented!(),
            }
            .expect(&quot;failed to send terminal event&quot;)
          }

          if last_tick.elapsed() &gt;= tick_rate {
            sender.send(Event::Tick).expect(&quot;failed to send tick event&quot;);
            last_tick = Instant::now();
          }
        }
      })
    };
    Self { sender, receiver, handler }
  }

  /// Receive the next event from the handler thread.
  ///
  /// This function will always block the current thread if
  /// there is no data available and it's possible for more data to be sent.
  pub fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.receiver.recv()?)
  }
}</code></pre>
<p>At the beginning of our <code>EventHandler::new</code> method, we create a channel using <code>mpsc::channel()</code>.</p>
<pre><code class="language-rust">let (sender, receiver) = mpsc::channel();</code></pre>
<p>This gives us a <code>sender</code> and <code>receiver</code> pair. The <code>sender</code> can be used to send events, while the
<code>receiver</code> can be used to receive them.</p>
<p>Notice that we are using <code>std::thread::spawn</code> in this <code>EventHandler</code>. This thread is spawned to
handle events and runs in the background and is responsible for polling and sending events to our
main application through the channel. In the
<a href="tutorial/counter-app/./../counter-async-app/async-event-stream.html">async counter tutorial</a> we will use
<code>tokio::task::spawn</code> instead.</p>
<p>In this background thread, we continuously poll for events with <code>event::poll(timeout)</code>. If an event
is available, it‚Äôs read and sent through the sender channel. The types of events we handle include
keypresses, mouse movements, screen resizing, and regular time ticks.</p>
<pre><code class="language-rust">if event::poll(timeout)? {
  match event::read()? {
    CrosstermEvent::Key(e) =&gt; {
        if e.kind == event::KeyEventKind::Press {
            sender.send(Event::Key(e))
        } else {
            Ok(()) // ignore KeyEventKind::Release on windows
        }
    },
    CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e))?,
    CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h))?,
    _ =&gt; unimplemented!(),
  }
}</code></pre>
<p>We expose the <code>receiver</code> channel as part of a <code>next()</code> method.</p>
<pre><code class="language-rust">  pub fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.receiver.recv()?)
  }</code></pre>
<p>Calling <code>event_handler.next()</code> method will call <code>receiver.recv()</code> which will cause the thread to
block until the <code>receiver</code> gets a new event.</p>
<p>Finally, we update the <code>last_tick</code> value based on the time elapsed since the previous <code>Tick</code>. We
also send a <code>Event::Tick</code> on the channel during this.</p>
<pre><code class="language-rust">if last_tick.elapsed() &gt;= tick_rate {
    sender.send(Event::Tick).expect(&quot;failed to send tick event&quot;);
    last_tick = Instant::now();
}</code></pre>
<p>In summary, our <code>EventHandler</code> abstracts away the complexity of event polling and handling into a
dedicated background thread.</p>
<p>Here‚Äôs the full code for your reference:</p>
<pre><code class="language-rust">use std::{
  sync::mpsc,
  thread,
  time::{Duration, Instant},
};

use anyhow::Result;
use crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};


/// Terminal events.
#[derive(Clone, Copy, Debug)]
pub enum Event {
  /// Terminal tick.
  Tick,
  /// Key press.
  Key(KeyEvent),
  /// Mouse click/scroll.
  Mouse(MouseEvent),
  /// Terminal resize.
  Resize(u16, u16),
}

/// Terminal event handler.
#[derive(Debug)]
pub struct EventHandler {
  /// Event sender channel.
  #[allow(dead_code)]
  sender: mpsc::Sender&lt;Event&gt;,
  /// Event receiver channel.
  receiver: mpsc::Receiver&lt;Event&gt;,
  /// Event handler thread.
  #[allow(dead_code)]
  handler: thread::JoinHandle&lt;()&gt;,
}

impl EventHandler {
  /// Constructs a new instance of [`EventHandler`].
  pub fn new(tick_rate: u64) -&gt; Self {
    let tick_rate = Duration::from_millis(tick_rate);
    let (sender, receiver) = mpsc::channel();
    let handler = {
      let sender = sender.clone();
      thread::spawn(move || {
        let mut last_tick = Instant::now();
        loop {
          let timeout = tick_rate.checked_sub(last_tick.elapsed()).unwrap_or(tick_rate);

          if event::poll(timeout).expect(&quot;no events available&quot;) {
            match event::read().expect(&quot;unable to read event&quot;) {
              CrosstermEvent::Key(e) =&gt; {
                if e.kind == event::KeyEventKind::Press {
                  sender.send(Event::Key(e))
                } else {
                  Ok(()) // ignore KeyEventKind::Release on windows
                }
              },
              CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e)),
              CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h)),
              _ =&gt; unimplemented!(),
            }
            .expect(&quot;failed to send terminal event&quot;)
          }

          if last_tick.elapsed() &gt;= tick_rate {
            sender.send(Event::Tick).expect(&quot;failed to send tick event&quot;);
            last_tick = Instant::now();
          }
        }
      })
    };
    Self { sender, receiver, handler }
  }

  /// Receive the next event from the handler thread.
  ///
  /// This function will always block the current thread if
  /// there is no data available and it's possible for more data to be sent.
  pub fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.receiver.recv()?)
  }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuirs"><a class="header" href="#tuirs">tui.rs</a></h1>
<p>Next, we can further abstract the terminal functionality from earlier into a <code>Tui</code> struct.</p>
<p>It provides a concise and efficient way to manage the terminal, handle events, and render content.
Let‚Äôs dive into its composition and functionality.</p>
<p>This introductory section includes the same imports and type definitions as before. We add an
additional type alias for <code>CrosstermTerminal</code>.</p>
<pre><code class="language-rust">use std::{io, panic};

use anyhow::Result;
use crossterm::{
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
};

pub type CrosstermTerminal = ratatui::Terminal&lt;ratatui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

use crate::{app::App, event::EventHandler, ui};</code></pre>
<p>The <code>Tui</code> struct can be defined with two primary fields:</p>
<ul>
<li><code>terminal</code>: This provides a direct interface to the terminal, allowing operations like drawing,
clearing the screen, and more.</li>
<li><code>events</code>: An event handler that we defined in the previous section, which would help in managing
terminal events like keystrokes, mouse movements, and other input events.</li>
</ul>
<pre><code class="language-rust">/// Representation of a terminal user interface.
///
/// It is responsible for setting up the terminal,
/// initializing the interface and handling the draw events.
pub struct Tui {
  /// Interface to the Terminal.
  terminal: CrosstermTerminal,
  /// Terminal event handler.
  pub events: EventHandler,
}</code></pre>
<p>With this <code>Tui</code> struct, we can add helper methods to handle modifying the terminal state. For
example, here‚Äôs the <code>init</code> method:</p>
<pre><code class="language-rust">impl Tui {
  /// Constructs a new instance of [`Tui`].
  pub fn new(terminal: CrosstermTerminal, events: EventHandler) -&gt; Self {
    Self { terminal, events }
  }

  /// Initializes the terminal interface.
  ///
  /// It enables the raw mode and sets terminal properties.
  pub fn enter(&amp;mut self) -&gt; Result&lt;()&gt; {
    terminal::enable_raw_mode()?;
    crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;

    // Define a custom panic hook to reset the terminal properties.
    // This way, you won't have your terminal messed up if an unexpected error happens.
    let panic_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic| {
      Self::reset().expect(&quot;failed to reset the terminal&quot;);
      panic_hook(panic);
    }));

    self.terminal.hide_cursor()?;
    self.terminal.clear()?;
    Ok(())
  }

}</code></pre>
<p>This is essentially the same as the <code>startup</code> function from before. One important thing to note that
this function can be used to set a panic hook that calls the <code>reset()</code> method.</p>
<pre><code class="language-rust">impl Tui {
  // --snip--

  /// Resets the terminal interface.
  ///
  /// This function is also used for the panic hook to revert
  /// the terminal properties if unexpected errors occur.
  fn reset() -&gt; Result&lt;()&gt; {
    terminal::disable_raw_mode()?;
    crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
  }

  /// Exits the terminal interface.
  ///
  /// It disables the raw mode and reverts back the terminal properties.
  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    Self::reset()?;
    self.terminal.show_cursor()?;
    Ok(())
  }

  // --snip--
}</code></pre>
<p>With this panic hook, in the event of an unexpected error or panic, the terminal properties will be
reset, ensuring that the terminal doesn‚Äôt remain in a disrupted state.</p>
<p>Finally, we can set up the draw method:</p>
<pre><code class="language-rust">impl Tui {
    // --snip--

  /// [`Draw`] the terminal interface by [`rendering`] the widgets.
  ///
  /// [`Draw`]: tui::Terminal::draw
  /// [`rendering`]: crate::ui:render
  pub fn draw(&amp;mut self, app: &amp;mut App) -&gt; Result&lt;()&gt; {
    self.terminal.draw(|frame| ui::render(app, frame))?;
    Ok(())
  }

}</code></pre>
<p>This draw method leverages the <code>ui::render</code> function from earlier in this section to transform the
state of our application into widgets that are then displayed on the terminal.</p>
<p>Here‚Äôs the full <code>tui.rs</code> file for your reference:</p>
<pre><code class="language-rust">
use std::{io, panic};

use anyhow::Result;
use crossterm::{
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
};

pub type CrosstermTerminal = ratatui::Terminal&lt;ratatui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

use crate::{app::App, event::EventHandler, ui};

/// Representation of a terminal user interface.
///
/// It is responsible for setting up the terminal,
/// initializing the interface and handling the draw events.
pub struct Tui {
  /// Interface to the Terminal.
  terminal: CrosstermTerminal,
  /// Terminal event handler.
  pub events: EventHandler,
}

impl Tui {
  /// Constructs a new instance of [`Tui`].
  pub fn new(terminal: CrosstermTerminal, events: EventHandler) -&gt; Self {
    Self { terminal, events }
  }

  /// Initializes the terminal interface.
  ///
  /// It enables the raw mode and sets terminal properties.
  pub fn enter(&amp;mut self) -&gt; Result&lt;()&gt; {
    terminal::enable_raw_mode()?;
    crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;

    // Define a custom panic hook to reset the terminal properties.
    // This way, you won't have your terminal messed up if an unexpected error happens.
    let panic_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic| {
      Self::reset().expect(&quot;failed to reset the terminal&quot;);
      panic_hook(panic);
    }));

    self.terminal.hide_cursor()?;
    self.terminal.clear()?;
    Ok(())
  }


  /// [`Draw`] the terminal interface by [`rendering`] the widgets.
  ///
  /// [`Draw`]: tui::Terminal::draw
  /// [`rendering`]: crate::ui:render
  pub fn draw(&amp;mut self, app: &amp;mut App) -&gt; Result&lt;()&gt; {
    self.terminal.draw(|frame| ui::render(app, frame))?;
    Ok(())
  }


  /// Resets the terminal interface.
  ///
  /// This function is also used for the panic hook to revert
  /// the terminal properties if unexpected errors occur.
  fn reset() -&gt; Result&lt;()&gt; {
    terminal::disable_raw_mode()?;
    crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
  }

  /// Exits the terminal interface.
  ///
  /// It disables the raw mode and reverts back the terminal properties.
  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    Self::reset()?;
    self.terminal.show_cursor()?;
    Ok(())
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updaters"><a class="header" href="#updaters">update.rs</a></h1>
<p>Finally we have the <code>update.rs</code> file. Here, the <code>update()</code> function takes in two arguments:</p>
<ul>
<li><code>key_event</code>: This is an event provided by the <code>crossterm</code> crate, representing a key press from the
user.</li>
<li><code>app</code>: A mutable reference to our application‚Äôs state, represented by the <code>App</code> struct.</li>
</ul>
<pre><code class="language-rust">use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

use crate::app::App;

pub fn update(app: &amp;mut App, key_event: KeyEvent) {
  match key_event.code {
    KeyCode::Esc | KeyCode::Char('q') =&gt; app.quit(),
    KeyCode::Char('c') | KeyCode::Char('C') =&gt; {
      if key_event.modifiers == KeyModifiers::CONTROL {
        app.quit()
      }
    },
    KeyCode::Right | KeyCode::Char('j') =&gt; app.increment_counter(),
    KeyCode::Left | KeyCode::Char('k') =&gt; app.decrement_counter(),
    _ =&gt; {},
  };
}</code></pre>
<p>Note that here we don‚Äôt have to check that <code>key_event.kind</code> is <code>KeyEventKind::Press</code> because we
already do that check in <a href="tutorial/counter-app/./event.html">event.rs</a> and only send <code>KeyEventKind::Press</code> events on the
channel.</p>
<div id="admonition-question" class="admonition admonish-question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/update.html#admonition-question"></a></p>
</div>
<div>
<p>As an exercise, can you refactor this app to use ‚ÄúThe Elm Architecture‚Äù principles?</p>
<p>Check out <a href="tutorial/counter-app/./../../concepts/the-elm-architecture.html">the concepts page on The Elm Architecture</a> for reference.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h1>
<p>Putting it all together, we have the <code>main.rs</code> function:</p>
<pre><code class="language-rust">/// Application.
pub mod app;

/// Terminal events handler.
pub mod event;

/// Widget renderer.
pub mod ui;

/// Terminal user interface.
pub mod tui;

/// Application updater.
pub mod update;

use anyhow::Result;
use app::App;
use event::{Event, EventHandler};
use ratatui::{backend::CrosstermBackend, Terminal};
use tui::Tui;
use update::update;

fn main() -&gt; Result&lt;()&gt; {
  // Create an application.
  let mut app = App::new();

  // Initialize the terminal user interface.
  let backend = CrosstermBackend::new(std::io::stderr());
  let terminal = Terminal::new(backend)?;
  let events = EventHandler::new(250);
  let mut tui = Tui::new(terminal, events);
  tui.enter()?;

  // Start the main loop.
  while !app.should_quit {
    // Render the user interface.
    tui.draw(&amp;mut app)?;
    // Handle events.
    match tui.events.next()? {
      Event::Tick =&gt; {},
      Event::Key(key_event) =&gt; update(&amp;mut app, key_event),
      Event::Mouse(_) =&gt; {},
      Event::Resize(_, _) =&gt; {},
    };
  }

  // Exit the user interface.
  tui.exit()?;
  Ok(())
}</code></pre>
<p>Because we call <code>tui.events.next()</code> in a loop, it blocks until there‚Äôs an event generated. If
there‚Äôs a key press, the state updates and the UI is refreshed. If there‚Äôs no key press, a <code>Tick</code>
event is generated every 250 milliseconds, which causes the UI to be refreshed.</p>
<p>This is what it looks like in practice to:</p>
<ul>
<li>Run the TUI</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>j</code> 5 times</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>k</code> 5 times</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>q</code></li>
</ul>
<!--

```
Set Shell zsh
Sleep 2.5s
Type "cargo run"
Enter
Sleep 5s
Type "jjjjj"
Sleep 500ms
Type "kkkkk"
Sleep 5s
Type "q"
Sleep 2.5s
```

-->
<p><img src="https://user-images.githubusercontent.com/1813121/263404720-41bd81a0-4eec-479c-9333-44363a183613.gif" alt="Counter app demo" /></p>
<p>You can find the full source code for this multiple files tutorial here:
<a href="https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/counter-app/ratatui-counter-app">https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/counter-app/ratatui-counter-app</a>.</p>
<div id="admonition-question" class="admonition admonish-question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/main.html#admonition-question"></a></p>
</div>
<div>
<p>Right now, this TUI application will render every time a key is pressed.
As an exercise, can you make this app render only an a predefined tick rate?</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-editor"><a class="header" href="#json-editor">JSON Editor</a></h1>
<p>Now that we have covered some of the basics of a ‚Äúhello world‚Äù and ‚Äúcounter‚Äù app, we are ready to
build and manage something more involved.</p>
<p>In this tutorial, we will be creating an application that gives the user a simple interface to enter
key-value pairs, which will be converted and printed to <code>stdout</code> in json. The purpose of this
application will be to give the user an interface to create correct json, instead of having to worry
about commas and brackets themselves.</p>
<p>Here‚Äôs a gif of what it will look like if you run this:</p>
<p><img src="https://vhs.charm.sh/vhs-5VaEPLZP2OlOxPPAIiLqbF.gif" alt="Demo" /></p>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>Go ahead and set up a new rust project with</p>
<pre><code class="language-shell">cargo new ratatui-json-editor
</code></pre>
<p>and put the following in the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
crossterm = &quot;0.26.1&quot;
ratatui = &quot;0.22.0&quot;
serde = { version = &quot;1.0.181&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.104&quot;
</code></pre>
<p>or the latest version of these libraries.</p>
<h2 id="filestructure-1"><a class="header" href="#filestructure-1">Filestructure</a></h2>
<p>Now create two files inside of <code>src/</code> so it looks like this:</p>
<pre><code class="language-plain">src
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ ui.rs
‚îî‚îÄ‚îÄ app.rs
</code></pre>
<p>This follows a common approach to small applications in <code>ratatui</code>, where we have a state file, a UI
file, and the main file to tie it all together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprs-1"><a class="header" href="#apprs-1">App.rs</a></h1>
<p>As we saw in the previous section, a common model for smaller <code>ratatui</code> applications is to have one
application state struct called <code>App</code> or some variant of that name. We will be using this paradigm
in this application as well.</p>
<p>This struct will contain all of our ‚Äúpersistent‚Äù data and will be passed to any function that needs
to know the current state of the application.</p>
<!--
    (Read [Application Pattern Concepts](../concepts/storing_state.md) to explore some other models)
-->
<h2 id="application-modes"><a class="header" href="#application-modes">Application modes</a></h2>
<p>It is useful to think about the several ‚Äúmodes‚Äù that your application can be in. Thinking in ‚Äúmodes‚Äù
will make it easier to segregate everything from what window is getting drawn, to what keybinds to
listen for.</p>
<p>We will be using the application‚Äôs state to track two things:</p>
<ol>
<li>what screen the user is seeing,</li>
<li>which box should be highlighted, the ‚Äúkey‚Äù or ‚Äúvalue‚Äù (this only applies when the user is editing
a key-value pair).</li>
</ol>
<h3 id="current-screen-enum"><a class="header" href="#current-screen-enum">Current Screen Enum</a></h3>
<p>In this tutorial application, we will have three ‚Äúscreens‚Äù:</p>
<ul>
<li><code>Main</code>: the main summary screen showing all past key-value pairs entered</li>
<li><code>Editing</code>: the screen shown when the user wishes to create a new key-value pair</li>
<li><code>Exiting</code>: displays a prompt asking if the user wants to output the key-value pairs they have
entered.</li>
</ul>
<p>We represent these possible modes with a simple enum:</p>
<pre><code class="language-rust no_run noplayground">pub enum CurrentScreen {
    Main,
    Editing,
    Exiting,
}</code></pre>
<h3 id="currently-editing-enum"><a class="header" href="#currently-editing-enum">Currently Editing Enum</a></h3>
<p>As you may already know, <code>ratatui</code> does not automatically redraw the screen<sup class="footnote-reference"><a href="#note">1</a></sup>. <code>ratatui</code> also
does not remember anything about what it drew last frame.</p>
<p>This means that the programmer is responsible for handling all state and updating widgets to reflect
changes. In this case, we will allow the user to input two strings in the <code>Editing</code> mode - a key and
a value. The programmer is responsible for knowing which the user is trying to edit.</p>
<p>For this purpose, we will create another enum for our application state called <code>CurrentlyEditing</code> to
keep track of which field the user is currently entering:</p>
<pre><code class="language-rust no_run noplayground">pub enum CurrentlyEditing {
    Key,
    Value,
}</code></pre>
<h2 id="the-full-application-state"><a class="header" href="#the-full-application-state">The full application state</a></h2>
<p>Now that we have enums to help us track where the user is, we will create the struct that actually
stores this data which can be passed around where it is needed.</p>
<pre><code class="language-rust no_run noplayground">pub struct App {
    pub key_input: String,              // the currently being edited json key.
    pub value_input: String,            // the currently being edited json value.
    pub pairs: HashMap&lt;String, String&gt;, // The representation of our key and value pairs with serde Serialize support
    pub current_screen: CurrentScreen, // the current screen the user is looking at, and will later determine what is rendered.
    pub currently_editing: Option&lt;CurrentlyEditing&gt;, // the optional state containing which of the key or value pair the user is editing. It is an option, because when the user is not directly editing a key-value pair, this will be set to `None`.
}</code></pre>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper functions</a></h2>
<p>While we could simply keep our application state as simply a holder of values, we can also create a
few helper functions which will make our life easier elsewhere. Of course, these functions should
only affect the application state itself, and nothing outside of it.</p>
<h3 id="new"><a class="header" href="#new"><code>new()</code></a></h3>
<p>We will be adding this function simply to make creating the state easier. While this could be
avoided by specifying it all in the instantiation of the variable, doing it here allows for easy to
change universal defaults for the state.</p>
<pre><code class="language-rust no_run noplayground">impl App {
    pub fn new() -&gt; App {
        App {
            key_input: String::new(),
            value_input: String::new(),
            pairs: HashMap::new(),
            current_screen: CurrentScreen::Main,
            currently_editing: None,
        }
    }
    // --snip--</code></pre>
<h3 id="save_key_value"><a class="header" href="#save_key_value"><code>save_key_value()</code></a></h3>
<p>This function will be called when the user saves a key-value pair in the editor. It adds the two
stored variables to the key-value pairs <code>HashMap</code>, and resets the status of all of the editing
variables.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    pub fn save_key_value(&amp;mut self) {
        self.pairs
            .insert(self.key_input.clone(), self.value_input.clone());

        self.key_input = String::new();
        self.value_input = String::new();
        self.currently_editing = None;
    }
    // --snip--</code></pre>
<h3 id="toggle_editing"><a class="header" href="#toggle_editing"><code>toggle_editing()</code></a></h3>
<p>Sometimes it is easier to put simple logic into a convenience function so we don‚Äôt have to worry
about it in the main code block. <code>toggle_editing</code> is one of those cases. All we are doing, is
checking if something is currently being edited, and if it is, swapping between editing the Key and
Value fields.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    pub fn toggle_editing(&amp;mut self) {
        if let Some(edit_mode) = &amp;self.currently_editing {
            match edit_mode {
                CurrentlyEditing::Key =&gt; self.currently_editing = Some(CurrentlyEditing::Value),
                CurrentlyEditing::Value =&gt; self.currently_editing = Some(CurrentlyEditing::Key),
            };
        } else {
            self.currently_editing = Some(CurrentlyEditing::Key);
        }
    }
    // --snip--</code></pre>
<h3 id="print_json"><a class="header" href="#print_json"><code>print_json()</code></a></h3>
<p>Finally, is another convenience function to print out the serialized json from all of our key-value
pairs.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    pub fn print_json(&amp;self) -&gt; Result&lt;()&gt; {
        let output = serde_json::to_string(&amp;self.pairs)?;
        println!(&quot;{}&quot;, output);
        Ok(())
    }
    // --snip--</code></pre>
<!-- prettier-ignore -->
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>In ratatui, every frame draws the UI anew. See the <a href="tutorial/json-editor/./../../concepts/rendering.html">Rendering section</a> for more information.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mainrs-1"><a class="header" href="#mainrs-1">Main.rs</a></h1>
<p>The <code>main</code> file in many ratatui applications is simply a place to store the startup loop, and
occasionally event handling. (See more ways to handle events in
<a href="tutorial/json-editor/../../concepts/event_handling.html">Event Handling</a>))</p>
<p>In this application, we will be using our <code>main</code> function to run the startup steps, and start the
main loop. We will also put our main loop logic and event handling in this file.</p>
<h2 id="main"><a class="header" href="#main">Main</a></h2>
<p>In our main function, we will set up the terminal, create an application state and run our
application, and finally reset the terminal to the state we found it in.</p>
<h3 id="application-pre-run-steps"><a class="header" href="#application-pre-run-steps">Application pre-run steps</a></h3>
<p>Because a <code>ratatui</code> application takes the whole screen, and captures all of the keyboard input, we
need some boilerplate at the beginning of our <code>main</code> function.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::EnableMouseCapture;
use crossterm::execute;
use crossterm::terminal::{enable_raw_mode, EnterAlternateScreen};
use std::io;</code></pre>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    // --snip--</code></pre>
<p>You might notice that we are using <code>stderr</code> for our output. This is because we want to allow the
user to pipe their completed json to other programs like <code>ratatui-tutorial &gt; output.json</code>. To do
this, we are utilizing the fact that <code>stderr</code> is piped differently than <code>stdout</code>, and rendering out
project in <code>stderr</code>, and printout our completed json in <code>stdout</code>.</p>
<p>For more information, please read the
<a href="https://docs.rs/crossterm/latest/crossterm/">crossterm documentation</a></p>
<h3 id="state-creation-and-loop-starting"><a class="header" href="#state-creation-and-loop-starting">State creation, and loop starting</a></h3>
<p>Now that we have prepared the terminal for our application to run, it is time to actually run it.</p>
<p>First, we need to create an instance of our <code>ApplicationState</code> or <code>app</code>, to hold all of the
program‚Äôs state, and then we will call our function which handles the event and draw loop.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);

    // --snip--</code></pre>
<h3 id="application-post-run-steps"><a class="header" href="#application-post-run-steps">Application post-run steps</a></h3>
<p>Since our <code>ratatui</code> application has changed the state of the user‚Äôs terminal with our
<a href="tutorial/json-editor/main.html#application-pre-run-steps">pre-run boilerplate</a>, we need to undo what we have done, and put the
terminal back to the way we found it.</p>
<p>Most of these functions will simply be the inverse of what we have done above.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::DisableMouseCapture;
use crossterm::terminal::{disable_raw_mode, LeaveAlternateScreen};</code></pre>
<pre><code class="language-rust no_run noplayground">    // --snip--
    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;
    // --snip--</code></pre>
<p>When an application exits without running this closing boilerplate, the terminal will act very
strange, and the user will usually have to end the terminal session and start a new one. Thus it is
important that we handle our error in such a way that we can call this last piece.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<p>The if statement at the end of boilerplate checks if the <code>run_app</code> function errored, or if it
returned an <code>Ok</code> state. If it returned an <code>Ok</code> state, we need to check if we should print the json.</p>
<p>If we don‚Äôt call our print function before we call <code>execute!(LeaveAlternateScreen)</code>, our prints will
be rendered on an old screen and lost when we leave the alternate screen. (For more information on
how this works, read the
<a href="https://docs.rs/crossterm/latest/crossterm/terminal/struct.LeaveAlternateScreen.html">Crossterm documentation</a>)</p>
<p>So, altogether, our finished function should looks like this:</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);


    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<h2 id="run_app"><a class="header" href="#run_app"><code>run_app</code></a></h2>
<p>In this function, we will start to do the actual logic.</p>
<h3 id="method-signature"><a class="header" href="#method-signature">Method signature</a></h3>
<p>Let‚Äôs start with the method signature:</p>
<pre><code class="language-rust no_run noplayground">fn run_app&lt;B: Backend&gt;(terminal: &amp;mut Terminal&lt;B&gt;, app: &amp;mut App) -&gt; io::Result&lt;bool&gt; {
    // --snip--</code></pre>
<p>You‚Äôll notice that we make this function generic across the <code>ratatui::backend::Backend</code>. In previous
sections we hardcoded the <code>CrosstermBackend</code>. This trait approach allows us to make our code backend
agnostic.</p>
<p>This method accepts an object of type <code>Terminal</code> which implements the <code>ratatui::backend::Backend</code>
trait. This trait includes the three (four counting the <code>TestBackend</code>) officially supported backends
included in <code>ratatui</code>. It allows for 3rd party backends to be implemented.</p>
<p><code>run_app</code> also requires a mutable borrow to an application state object, as defined in this project.</p>
<p>Finally, the <code>run_app</code> returns an <code>io::Result&lt;bool&gt;</code> that indicates if there was an io error with
the <code>Err</code> state, and an <code>Ok(true)</code> or <code>Ok(false)</code> that indicates if the program should print out the
finished json.</p>
<h3 id="ui-loop"><a class="header" href="#ui-loop">UI Loop</a></h3>
<p>Because <code>ratatui</code> requires us to implement our own event/ui loop, we will simply use the following
code to update our main loop.</p>
<pre><code class="language-rust no_run noplayground">    // --snip--
    loop {
        terminal.draw(|f| ui(f, app))?;
        // --snip--</code></pre>
<p>Let‚Äôs unpack that <code>draw</code> call really quick.</p>
<ul>
<li><code>terminal</code> is the <code>Terminal&lt;Backend&gt;</code> that we take as an argument,</li>
<li><code>draw</code> is the <code>ratatui</code> command to draw a <code>Frame</code> to the terminal<sup class="footnote-reference"><a href="#note">1</a></sup>.</li>
<li><code>|f| ui(f, &amp;app)</code> tells <code>draw</code> that we want to take <code>f: &lt;Frame&gt;</code> and pass it to our function <code>ui</code>,
and <code>ui</code> will draw to that <code>Frame</code>.</li>
</ul>
<!-- prettier-ignore -->
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>Technically this is the command to the <code>Terminal&lt;Backend&gt;</code>, but that only matters on the <code>TestBackend</code>.</p>
</div>
<p>Notice that we also pass an immutable borrow of our application state to the <code>ui</code> function. This
will be important later.</p>
<h3 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h3>
<p>Now that we have started our app , and have set up the UI rendering, we will implement the event
handling.</p>
<h4 id="polling"><a class="header" href="#polling">Polling</a></h4>
<p>Because we are using <code>crossterm</code>, we can simply poll for keyboard events with</p>
<pre><code class="language-rust">if let Event::Key(key) = event::read()? {
    dbg!(key.code)
}</code></pre>
<p>and then match the results.</p>
<p>Alternatively, we can set up a thread to run in the background to poll and send <code>Event</code>s (as we did
in the ‚Äúcounter‚Äù tutorial). Let‚Äôs keep things simple here for the sake of illustration.</p>
<p>Note that the process for polling events will vary on the backend you are utilizing, and you will
need to refer to the documentation of that backend for more information.</p>
<h4 id="main-screen"><a class="header" href="#main-screen">Main Screen</a></h4>
<p>We will start with the keybinds and event handling for the <code>CurrentScreen::Main</code>.</p>
<pre><code class="language-rust no_run noplayground">        // --snip--
        if let Event::Key(key) = event::read()? {
            if key.kind == event::KeyEventKind::Release {
                // Skip events that are not KeyEventKind::Press
                continue;
            }
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                // --snip--</code></pre>
<p>After matching to the <code>Main</code> enum variant, we match the event. When the user is in the main screen,
there are only two keybinds, and the rest are ignored.</p>
<p>In this case, <code>KeyCode::Char('e')</code> changes the current screen to <code>CurrentScreen::Editing</code> and sets
the <code>CurrentlyEditing</code> to a <code>Some</code> and notes that the user should be editing the <code>Key</code> value field,
as opposed to the <code>Value</code> field.</p>
<p><code>KeyCode::Char('q')</code> is straightforward, as it simply switches the application to the <code>Exiting</code>
screen, and allows the ui and future event handling runs to do the rest.</p>
<h4 id="exiting"><a class="header" href="#exiting">Exiting</a></h4>
<p>The next handler we will prepare, will handle events while the application is on the
<code>CurrentScreen::Exiting</code>. The job of this screen is to ask if the user wants to exit without
outputting the json. It is simply a <code>y/n</code> question, so that is all we listen for. We also add an
alternate exit key with <code>q</code>. If the user chooses to output the json, we return an <code>Ok(true)</code> that
indicates that our <code>main</code> function should call <code>app.print_json()</code> to perform the serialization and
printing for us after resetting the terminal to normal</p>
<pre><code class="language-rust no_run noplayground">                // --snip--
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                // --snip--</code></pre>
<h4 id="editing"><a class="header" href="#editing">Editing</a></h4>
<p>Our final handler will be a bit more involved, as we will be changing the state of internal
variables.</p>
<p>We would like the <code>Enter</code> key to serve two purposes. When the user is editing the <code>Key</code>, we want the
enter key to switch the focus to editing the <code>Value</code>. However, if the <code>Value</code> is what is being
currently edited, <code>Enter</code> will save the key-value pair, and return to the <code>Main</code> screen.</p>
<pre><code class="language-rust no_run noplayground">                // --snip--
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        // --snip--</code></pre>
<p>When <code>Backspace</code> is pressed, we need to first determine if the user is editing a <code>Key</code> or a <code>Value</code>,
then <code>pop()</code> the endings of those strings accordingly.</p>
<pre><code class="language-rust no_run noplayground">                        // --snip--
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        // --snip--</code></pre>
<p>When <code>Escape</code> is pressed, we want to quit editing.</p>
<pre><code class="language-rust no_run noplayground">                        // --snip--
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        // --snip--</code></pre>
<p>When <code>Tab</code> is pressed, we want the currently editing selection to switch.</p>
<pre><code class="language-rust no_run noplayground">                        // --snip--
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        // --snip--</code></pre>
<p>And finally, if the user types a valid character, we want to capture that, and add it to the string
that is the final key or value.</p>
<pre><code class="language-rust no_run noplayground">                        // --snip--
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        // --snip--</code></pre>
<p>Altogether, the event loop should look like this:</p>
<pre><code class="language-rust no_run noplayground">        // --snip--
        if let Event::Key(key) = event::read()? {
            if key.kind == event::KeyEventKind::Release {
                // Skip events that are not KeyEventKind::Press
                continue;
            }
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        _ =&gt; {}
                    }
                }
                _ =&gt; {}
            }
        }
        // --snip--</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uirs-1"><a class="header" href="#uirs-1">UI.rs</a></h1>
<p>Finally we come to the last piece of the puzzle, and also the hardest part when you are just
starting out creating <code>ratatui</code> TUIs ‚Äî the UI. We created a very simple UI with just one widget in
the previous tutorial, but here we‚Äôll explore some more sophisticated layouts.</p>
<div id="admonition-attention" class="admonition admonish-warning">
<div class="admonition-title">
<p>Attention</p>
<p><a class="admonition-anchor-link" href="tutorial/json-editor/ui.html#admonition-attention"></a></p>
</div>
<div>
<p>If you have created a UI before, you should know that the UI code can take up much more space than
you think it should, and this is not exception. We will only briefly cover all the functionality
available in <code>ratatui</code> and how the core of <code>ratatui</code> design works.</p>
<p>There will be links to more resources where they are covered in depth in the following sections.</p>
</div>
</div>
<h2 id="layout-basics"><a class="header" href="#layout-basics">Layout basics</a></h2>
<p>Our first step is to grasp how we render widgets onto the terminal.</p>
<p>In essence: Widgets are constructed and then drawn onto the screen using a <code>Frame</code>, which is placed
within a specified <code>Rect</code>.</p>
<p>Now, envision a scenario where we wish to divide our renderable <code>Rect</code> area into three distinct
areas. For this, we can use the <code>Layout</code> functionality in <code>ratatui</code>.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(1),
            Constraint::Length(3),
        ])
        .split(f.size());</code></pre>
<p>This can be likened to partitioning a large rectangle into smaller sections.</p>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/json-editor/ui.html#admonition-tip"></a></p>
</div>
<div>
<p>For a comprehensive understanding of layout and constraints, refer to
<a href="tutorial/json-editor/./../how-to/layout-constraints-basics.html">Layout Constraints Basics</a>
and <a href="tutorial/json-editor/./../how-to/layout-constraints-intermediate.html">Layout Constraints Intermediate</a> sections.</p>
</div>
</div>
<p>In the example above, you can read the instructions aloud like this:</p>
<ol>
<li>Take the area <code>f.size()</code> (which is a rectangle), and cut it into three vertical pieces (making
horizontal cuts).</li>
<li>The first section will be 3 lines tall</li>
<li>The second section should never be smaller than one line tall, but can expand if needed.</li>
<li>The final section should also be 3 lines tall</li>
</ol>
<p>For those visual learners, I have the following graphic:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="584" height="256">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="584" height="256"></rect>
  <text x="90" y="28" >Top</text>
  <text x="122" y="28" >segment</text>
  <text x="186" y="28" >always</text>
  <text x="90" y="44" >remains</text>
  <text x="154" y="44" >3</text>
  <text x="170" y="44" >lines</text>
  <text x="90" y="204" >Bottom</text>
  <text x="146" y="204" >segment</text>
  <text x="210" y="204" >is</text>
  <text x="90" y="220" >consistently</text>
  <text x="194" y="220" >3</text>
  <text x="210" y="220" >lines</text>
  <text x="378" y="28" >Constraint::Length</text>
  <line x1="536" y1="22" x2="552" y2="22" class="solid"></line>
  <line x1="536" y1="26" x2="552" y2="26" class="solid"></line>
  <text x="562" y="28" >3</text>
  <text x="58" y="108" >Middle</text>
  <text x="114" y="108" >segment</text>
  <text x="178" y="108" >maintains</text>
  <text x="258" y="108" >a</text>
  <text x="274" y="108" >minimum</text>
  <text x="58" y="124" >height</text>
  <text x="114" y="124" >of</text>
  <text x="138" y="124" >1</text>
  <text x="154" y="124" >line,</text>
  <text x="202" y="124" >but</text>
  <text x="234" y="124" >can</text>
  <text x="266" y="124" >expand</text>
  <text x="322" y="124" >if</text>
  <text x="58" y="140" >additional</text>
  <text x="146" y="140" >space</text>
  <text x="194" y="140" >is</text>
  <text x="218" y="140" >present.</text>
  <text x="378" y="140" >Constraint::Length</text>
  <text x="538" y="140" >&gt;</text>
  <line x1="552" y1="134" x2="560" y2="134" class="solid"></line>
  <line x1="552" y1="138" x2="560" y2="138" class="solid"></line>
  <text x="570" y="140" >1</text>
  <text x="378" y="204" >Constraint::Length</text>
  <line x1="536" y1="198" x2="552" y2="198" class="solid"></line>
  <line x1="536" y1="202" x2="552" y2="202" class="solid"></line>
  <text x="562" y="204" >3</text>
  <g>
    <line x1="4" y1="8" x2="364" y2="8" class="solid"></line>
    <line x1="4" y1="8" x2="4" y2="232" class="solid"></line>
    <line x1="364" y1="8" x2="364" y2="232" class="solid"></line>
    <line x1="4" y1="56" x2="364" y2="56" class="solid"></line>
    <line x1="4" y1="184" x2="364" y2="184" class="solid"></line>
    <line x1="4" y1="232" x2="364" y2="232" class="solid"></line>
  </g>
</svg></pre>
<p>Now that we have that out of the way, let us create the TUI for our application.</p>
<h2 id="the-function-signature"><a class="header" href="#the-function-signature">The function signature</a></h2>
<p>Our UI function needs two things to successfully create our UI elements. The <code>Frame</code> which contains
the size of the terminal at render time (this is important, because it allows us to take resizable
terminals into account), and the application state.</p>
<pre><code class="language-rust no_run noplayground">pub fn ui&lt;B: Backend&gt;(f: &amp;mut Frame&lt;B&gt;, app: &amp;App) {</code></pre>
<p>Before we proceed, let‚Äôs implement a <code>centered_rect</code> helper function. This code is adapted from the
<a href="https://github.com/ratatui-org/ratatui/blob/main/examples/popup.rs">popup example</a> found in the
official repo.</p>
<pre><code class="language-rust no_run noplayground">/// helper function to create a centered rect using up certain percentage of the available rect `r`
fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -&gt; Rect {
    // Cut the given rectangle into three vertical pieces
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage((100 - percent_y) / 2),
            Constraint::Percentage(percent_y),
            Constraint::Percentage((100 - percent_y) / 2),
        ])
        .split(r);

    // Then cut the middle vertical piece into three width-wise pieces
    Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage((100 - percent_x) / 2),
            Constraint::Percentage(percent_x),
            Constraint::Percentage((100 - percent_x) / 2),
        ])
        .split(popup_layout[1])[1] // Return the middle chunk
}</code></pre>
<p>This will be useful for the later subsections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-main-screen"><a class="header" href="#the-main-screen">The Main screen</a></h1>
<p>Because we want the <code>Main</code> screen to be rendered behind the editing popup, we will draw it first,
and then have additional logic about our popups</p>
<h2 id="our-layout"><a class="header" href="#our-layout">Our layout</a></h2>
<p>Now that we have our <code>Frame</code>, we can actually begin drawing widgets onto it. We will begin by
creating out layout.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(1),
            Constraint::Length(3),
        ])
        .split(f.size());</code></pre>
<p>The variable <code>chunks</code> now contains a length 3 array of <code>Rect</code> objects that contain the top left
corner of their space, and their size. We will use these later, after we prepare our widgets.</p>
<h2 id="the-title"><a class="header" href="#the-title">The title</a></h2>
<p>The title is an important piece for any application. It helps the user understand what they can do
and where they are. To create our title, we are going to use a <code>Paragraph</code> widget (which is used to
display only text), and we are going to tell that <code>Paragraph</code> we want a border all around it by
giving it a <code>Block</code> with borders enabled. (See <a href="tutorial/json-editor/../../how-to/widgets/block.html">How-To: Block</a> and
<a href="tutorial/json-editor/../../how-to/widgets/paragraph.html">How-To: Paragraph</a> for more information about <code>Block</code> and
<code>Paragraph</code>).</p>
<pre><code class="language-rust no_run noplayground">    let title_block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default());

    let title = Paragraph::new(Text::styled(
        &quot;Create New Json&quot;,
        Style::default().fg(Color::Green),
    ))
    .block(title_block);

    f.render_widget(title, chunks[0]);</code></pre>
<p>In this code, the first thing we do, is create a <code>Block</code> with all borders enabled, and the default
style. Next, we created a paragraph widget with the text ‚ÄúCreate New Json‚Äù styled green. (See
<a href="tutorial/json-editor/../../how-to/widgets/paragraph.html">How-To: Paragraphs</a> for more information about creating
paragraphs and <a href="tutorial/json-editor/../../how-to/render/style-text.html">How-To: Styling-Text</a> for styling text) Finally,
we call <code>render_widget</code> on our <code>Frame</code>, and give it the widget we want to render it, and the <code>Rect</code>
representing where it needs to go and what size it should be. (this is the way all widgets are
drawn)</p>
<h2 id="the-list-of-existing-pairs"><a class="header" href="#the-list-of-existing-pairs">The list of existing pairs</a></h2>
<p>We would also like the user to be able to see any key-value pairs that they have already entered.
For this, we will be using another widget, the <code>List</code>. The list is what it sounds like - it creates
a new line of text for each <code>ListItem</code>, and it supports passing in a state so you can implement
selecting items on the list with little extra work. We will not be implementing selection, as we
simply want the user to be able to see what they have already entered.</p>
<pre><code class="language-rust no_run noplayground">    let mut list_items = Vec::&lt;ListItem&gt;::new();

    for key in app.pairs.keys() {
        list_items.push(ListItem::new(Line::from(Span::styled(
            format!(&quot;{: &lt;25} : {}&quot;, key, app.pairs.get(key).unwrap()),
            Style::default().fg(Color::Yellow),
        ))));
    }

    let list = List::new(list_items);

    f.render_widget(list, chunks[1]);</code></pre>
<p>For more information on Line, Span, and Style see
<a href="tutorial/json-editor/../../how-to/render/display-text.html">How-To: Displaying Text</a></p>
<p>In this piece of the function, we create a vector of <code>ListItem</code>s, and populate it with styled and
formatted key-value pairs. Finally, we create the <code>List</code> widget, and render it.</p>
<h2 id="the-bottom-navigational-bar"><a class="header" href="#the-bottom-navigational-bar">The bottom navigational bar</a></h2>
<p>It can help new users of your application, to see hints about what keys they can press. For this, we
are going to implement two bars, and another layout. These two bars will contain information on 1)
The current screen (<code>Main</code>, <code>Editing</code>, and <code>Exiting</code>), and 2) what keybinds are available.</p>
<p>Here, we will create a <code>Vec</code> of <code>Span</code> which will be converted later into a single line by the
<code>Paragraph</code>. (A <code>Span</code> is different from a <code>Line</code>, because a <code>Span</code> indicates a section of <code>Text</code>
with a style applied, and doesn‚Äôt end with a newline)</p>
<pre><code class="language-rust no_run noplayground">    let current_navigation_text = vec![
        // The first half of the text
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(&quot;Normal Mode&quot;, Style::default().fg(Color::Green)),
            CurrentScreen::Editing =&gt; {
                Span::styled(&quot;Editing Mode&quot;, Style::default().fg(Color::Yellow))
            }
            CurrentScreen::Exiting =&gt; Span::styled(&quot;Exiting&quot;, Style::default().fg(Color::LightRed)),
        }
        .to_owned(),
        // A white divider bar to separate the two sections
        Span::styled(&quot; | &quot;, Style::default().fg(Color::White)),
        // The final section of the text, with hints on what the user is editing
        {
            if let Some(editing) = &amp;app.currently_editing {
                match editing {
                    CurrentlyEditing::Key =&gt; {
                        Span::styled(&quot;Editing Json Key&quot;, Style::default().fg(Color::Green))
                    }
                    CurrentlyEditing::Value =&gt; {
                        Span::styled(&quot;Editing Json Value&quot;, Style::default().fg(Color::LightGreen))
                    }
                }
            } else {
                Span::styled(&quot;Not Editing Anything&quot;, Style::default().fg(Color::DarkGray))
            }
        },
    ];

    let mode_footer = Paragraph::new(Line::from(current_navigation_text))
        .block(Block::default().borders(Borders::ALL));</code></pre>
<p>Next, we are also going to make a hint in the navigation bar with available keys. This one does not
have several sections of text with different styles, and is thus less code.</p>
<pre><code class="language-rust no_run noplayground">    let current_keys_hint = {
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Editing =&gt; Span::styled(
                &quot;(ESC) to cancel/(Tab) to switch boxes/enter to complete&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Exiting =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
        }
    };

    let key_notes_footer =
        Paragraph::new(Line::from(current_keys_hint)).block(Block::default().borders(Borders::ALL));</code></pre>
<p>Finally, we are going to create our first nested layout. Because the <code>Layout.split</code> function
requires a <code>Rect</code>, and not a <code>Frame</code>, we can pass one of our chunks from the previous layout as the
space for the new layout. If you remember the bottom most section from the above graphic:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="496" height="96">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="496" height="96"></rect>
  <rect x="4" y="8" width="280" height="64" class="solid nofill" rx="0"></rect>
  <text x="66" y="28" >This</text>
  <text x="106" y="28" >section</text>
  <text x="170" y="28" >should</text>
  <text x="50" y="44" >always</text>
  <text x="106" y="44" >be</text>
  <text x="130" y="44" >3</text>
  <text x="146" y="44" >lines</text>
  <text x="194" y="44" >tall</text>
  <text x="298" y="12" >Constraint::Length</text>
  <line x1="456" y1="6" x2="472" y2="6" class="solid"></line>
  <line x1="456" y1="10" x2="472" y2="10" class="solid"></line>
  <text x="482" y="12" >3</text>
</svg></pre>
<p>We will create a new layout in this space by passing it (<code>chunks[2]</code>) as the parameter for <code>split</code>.</p>
<pre><code class="language-rust no_run noplayground">    let footer_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
        .split(chunks[2]);</code></pre>
<p>This code is the visual equivalent of this:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="488" height="96">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="488" height="96"></rect>
  <rect x="4" y="8" width="272" height="64" class="solid nofill" rx="0"></rect>
  <line x1="140" y1="16" x2="140" y2="64" class="solid"></line>
  <text x="18" y="44" >Length</text>
  <line x1="72" y1="38" x2="88" y2="38" class="solid"></line>
  <line x1="72" y1="42" x2="88" y2="42" class="solid"></line>
  <text x="98" y="44" >50%</text>
  <text x="154" y="44" >Length</text>
  <line x1="208" y1="38" x2="224" y2="38" class="solid"></line>
  <line x1="208" y1="42" x2="224" y2="42" class="solid"></line>
  <text x="234" y="44" >50%</text>
  <text x="290" y="12" >Constraint::Length</text>
  <line x1="448" y1="6" x2="464" y2="6" class="solid"></line>
  <line x1="448" y1="10" x2="464" y2="10" class="solid"></line>
  <text x="474" y="12" >3</text>
</svg></pre>
<p>And now we can render our footer paragraphs in the appropriate spaces.</p>
<pre><code class="language-rust no_run noplayground">    f.render_widget(mode_footer, footer_chunks[0]);
    f.render_widget(key_notes_footer, footer_chunks[1]);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-editing-popup"><a class="header" href="#the-editing-popup">The Editing Popup</a></h1>
<p>Now that the <code>Main</code> screen is rendered, we now need to check if the <code>Editing</code> popup needs to be
rendered. Since the <code>ratatui</code> renderer simply writes over the cells within a <code>Rect</code> on a
<code>render_widget</code>, we simply need to give <code>render_widget</code> an area on top of our <code>Main</code> screen to
create the appearance of a popup.</p>
<h2 id="popup-area-and-title"><a class="header" href="#popup-area-and-title">Popup area and title</a></h2>
<p>The first thing we will do, is draw the <code>Block</code> that will contain the popup. We will give this
<code>Block</code> a title to display as well to explain to the user what it is. (We will cover <code>centered_rect</code>
below)</p>
<pre><code class="language-rust no_run noplayground">    if let Some(editing) = &amp;app.currently_editing {
        let popup_block = Block::default()
            .title(&quot;Enter a new key-value pair&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let area = centered_rect(60, 25, f.size());
        f.render_widget(popup_block, area);</code></pre>
<h2 id="popup-contents"><a class="header" href="#popup-contents">Popup contents</a></h2>
<p>Now that we have where our popup is going to go, we can create the layout for the popup, and create
and draw the widgets inside of it.</p>
<p>First, we will create split the <code>Rect</code> given to us by <code>centered_rect</code>, and create a layout from it.
Note the use of <code>margin(1)</code>, which gives a 1 space margin around any layout block, meaning our new
blocks and widgets don‚Äôt overwrite anything from the first popup block.</p>
<pre><code class="language-rust no_run noplayground">        let popup_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .margin(1)
            .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
            .split(area);</code></pre>
<p>Now that we have the layout for where we want to display the keys and values, we will actually
create the blocks and paragraphs to show what the user has already entered.</p>
<pre><code class="language-rust no_run noplayground">        let mut key_block = Block::default().title(&quot;Key&quot;).borders(Borders::ALL);
        let mut value_block = Block::default().title(&quot;Value&quot;).borders(Borders::ALL);

        let active_style = Style::default().bg(Color::LightYellow).fg(Color::Black);

        match editing {
            CurrentlyEditing::Key =&gt; key_block = key_block.style(active_style),
            CurrentlyEditing::Value =&gt; value_block = value_block.style(active_style),
        };

        let key_text = Paragraph::new(app.key_input.clone()).block(key_block);
        f.render_widget(key_text, popup_chunks[0]);

        let value_text = Paragraph::new(app.value_input.clone()).block(value_block);
        f.render_widget(value_text, popup_chunks[1]);
    }</code></pre>
<p>Note that we are declaring the blocks as variables, and then adding extra styling to the block the
user is currently editing. Then we create the <code>Paragraph</code> widgets, and assign the blocks with those
variables. Also note how we used the <code>popup_chunks</code> layout instead of the <code>popup_block</code> layout to
render these widgets into.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-exit-popup"><a class="header" href="#the-exit-popup">The Exit Popup</a></h1>
<p>We have a way for the user to view their already entered key-value pairs, and we have a way for the
user to enter new ones. The last screen we need to create, is the exit/confirmation screen.</p>
<p>In this screen, we are asking the user if they want to output the key-value pairs they have entered
in the <code>stdout</code> pipe, or close without outputting anything.</p>
<pre><code class="language-rust no_run noplayground">    if let CurrentScreen::Exiting = app.current_screen {
        f.render_widget(Clear, f.size()); //this clears the entire screen and anything already drawn
        let popup_block = Block::default()
            .title(&quot;Y/N&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let exit_text = Text::styled(
            &quot;Would you like to output the buffer as json? (y/n)&quot;,
            Style::default().fg(Color::Red),
        );
        // the `trim: false` will stop the text from being cut off when over the edge of the block
        let exit_paragraph = Paragraph::new(exit_text)
            .block(popup_block)
            .wrap(Wrap { trim: false });

        let area = centered_rect(60, 25, f.size());
        f.render_widget(exit_paragraph, area);
    }</code></pre>
<p>The only thing in this part that we haven‚Äôt done before, is use the 
<a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Clear.html"><code>Clear</code></a> widget. This is a
special widget that does what the name suggests ‚Äî it clears everything in the space it is
rendered.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closing-thoughts"><a class="header" href="#closing-thoughts">Closing Thoughts</a></h1>
<p>This tutorial should get you started with a basic understanding of the flow of a <code>ratatui</code> program.
However, this is only <em>one</em> way to create a <code>ratatui</code> application. Because <code>ratatui</code> is relatively
low level compared to other UI frameworks, almost any application model can be implemented. You can
explore more of these in <a href="tutorial/json-editor/../../concepts/application-patterns/">Concepts: Application Patterns</a> and
get some inspiration for what model will work best for your application.</p>
<h2 id="finished-files"><a class="header" href="#finished-files">Finished Files</a></h2>
<p>You can find the finished project used for the tutorial on
<a href="https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/json-editor">GitHub</a>. The code
is also shown at the bottom of this page.</p>
<p>You can test this application by yourself by running:</p>
<pre><code class="language-shell">cargo run &gt; test.json
</code></pre>
<p>and double checking the output.</p>
<h3 id="mainrs-2"><a class="header" href="#mainrs-2">Main.rs</a></h3>
<pre><code class="language-rust no_run noplayground">use std::{error::Error, io};

use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::{Backend, CrosstermBackend},
    Terminal,
};

mod app;
mod ui;
use crate::{
    app::{App, CurrentScreen, CurrentlyEditing},
    ui::ui,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);


    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}

fn run_app&lt;B: Backend&gt;(terminal: &amp;mut Terminal&lt;B&gt;, app: &amp;mut App) -&gt; io::Result&lt;bool&gt; {
    loop {
        terminal.draw(|f| ui(f, app))?;

        if let Event::Key(key) = event::read()? {
            if key.kind == event::KeyEventKind::Release {
                // Skip events that are not KeyEventKind::Press
                continue;
            }
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        _ =&gt; {}
                    }
                }
                _ =&gt; {}
            }
        }
    }
}
</code></pre>
<h3 id="apprs-2"><a class="header" href="#apprs-2">App.rs</a></h3>
<pre><code class="language-rust no_run noplayground">use serde_json::Result;

pub enum CurrentScreen {
    Main,
    Editing,
    Exiting,
}

pub enum CurrentlyEditing {
    Key,
    Value,
}

pub struct App {
    pub key_input: String,              // the currently being edited json key.
    pub value_input: String,            // the currently being edited json value.
    pub pairs: HashMap&lt;String, String&gt;, // The representation of our key and value pairs with serde Serialize support
    pub current_screen: CurrentScreen, // the current screen the user is looking at, and will later determine what is rendered.
    pub currently_editing: Option&lt;CurrentlyEditing&gt;, // the optional state containing which of the key or value pair the user is editing. It is an option, because when the user is not directly editing a key-value pair, this will be set to `None`.
}

impl App {
    pub fn new() -&gt; App {
        App {
            key_input: String::new(),
            value_input: String::new(),
            pairs: HashMap::new(),
            current_screen: CurrentScreen::Main,
            currently_editing: None,
        }
    }

    pub fn save_key_value(&amp;mut self) {
        self.pairs
            .insert(self.key_input.clone(), self.value_input.clone());

        self.key_input = String::new();
        self.value_input = String::new();
        self.currently_editing = None;
    }

    pub fn toggle_editing(&amp;mut self) {
        if let Some(edit_mode) = &amp;self.currently_editing {
            match edit_mode {
                CurrentlyEditing::Key =&gt; self.currently_editing = Some(CurrentlyEditing::Value),
                CurrentlyEditing::Value =&gt; self.currently_editing = Some(CurrentlyEditing::Key),
            };
        } else {
            self.currently_editing = Some(CurrentlyEditing::Key);
        }
    }

    pub fn print_json(&amp;self) -&gt; Result&lt;()&gt; {
        let output = serde_json::to_string(&amp;self.pairs)?;
        println!(&quot;{}&quot;, output);
        Ok(())
    }
}</code></pre>
<h3 id="uirs-2"><a class="header" href="#uirs-2">UI.rs</a></h3>
<pre><code class="language-rust no_run noplayground">use ratatui::{
    backend::Backend,
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Clear, List, ListItem, Paragraph, Wrap},
    Frame,
};

use crate::app::{App, CurrentScreen, CurrentlyEditing};

pub fn ui&lt;B: Backend&gt;(f: &amp;mut Frame&lt;B&gt;, app: &amp;App) {
    // Create the layout sections.
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(1),
            Constraint::Length(3),
        ])
        .split(f.size());

    let title_block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default());

    let title = Paragraph::new(Text::styled(
        &quot;Create New Json&quot;,
        Style::default().fg(Color::Green),
    ))
    .block(title_block);

    f.render_widget(title, chunks[0]);
    let mut list_items = Vec::&lt;ListItem&gt;::new();

    for key in app.pairs.keys() {
        list_items.push(ListItem::new(Line::from(Span::styled(
            format!(&quot;{: &lt;25} : {}&quot;, key, app.pairs.get(key).unwrap()),
            Style::default().fg(Color::Yellow),
        ))));
    }

    let list = List::new(list_items);

    f.render_widget(list, chunks[1]);
    let current_navigation_text = vec![
        // The first half of the text
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(&quot;Normal Mode&quot;, Style::default().fg(Color::Green)),
            CurrentScreen::Editing =&gt; {
                Span::styled(&quot;Editing Mode&quot;, Style::default().fg(Color::Yellow))
            }
            CurrentScreen::Exiting =&gt; Span::styled(&quot;Exiting&quot;, Style::default().fg(Color::LightRed)),
        }
        .to_owned(),
        // A white divider bar to separate the two sections
        Span::styled(&quot; | &quot;, Style::default().fg(Color::White)),
        // The final section of the text, with hints on what the user is editing
        {
            if let Some(editing) = &amp;app.currently_editing {
                match editing {
                    CurrentlyEditing::Key =&gt; {
                        Span::styled(&quot;Editing Json Key&quot;, Style::default().fg(Color::Green))
                    }
                    CurrentlyEditing::Value =&gt; {
                        Span::styled(&quot;Editing Json Value&quot;, Style::default().fg(Color::LightGreen))
                    }
                }
            } else {
                Span::styled(&quot;Not Editing Anything&quot;, Style::default().fg(Color::DarkGray))
            }
        },
    ];

    let mode_footer = Paragraph::new(Line::from(current_navigation_text))
        .block(Block::default().borders(Borders::ALL));

    let current_keys_hint = {
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Editing =&gt; Span::styled(
                &quot;(ESC) to cancel/(Tab) to switch boxes/enter to complete&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Exiting =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
        }
    };

    let key_notes_footer =
        Paragraph::new(Line::from(current_keys_hint)).block(Block::default().borders(Borders::ALL));

    let footer_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
        .split(chunks[2]);

    f.render_widget(mode_footer, footer_chunks[0]);
    f.render_widget(key_notes_footer, footer_chunks[1]);

    if let Some(editing) = &amp;app.currently_editing {
        let popup_block = Block::default()
            .title(&quot;Enter a new key-value pair&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let area = centered_rect(60, 25, f.size());
        f.render_widget(popup_block, area);

        let popup_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .margin(1)
            .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
            .split(area);

        let mut key_block = Block::default().title(&quot;Key&quot;).borders(Borders::ALL);
        let mut value_block = Block::default().title(&quot;Value&quot;).borders(Borders::ALL);

        let active_style = Style::default().bg(Color::LightYellow).fg(Color::Black);

        match editing {
            CurrentlyEditing::Key =&gt; key_block = key_block.style(active_style),
            CurrentlyEditing::Value =&gt; value_block = value_block.style(active_style),
        };

        let key_text = Paragraph::new(app.key_input.clone()).block(key_block);
        f.render_widget(key_text, popup_chunks[0]);

        let value_text = Paragraph::new(app.value_input.clone()).block(value_block);
        f.render_widget(value_text, popup_chunks[1]);
    }

    if let CurrentScreen::Exiting = app.current_screen {
        f.render_widget(Clear, f.size()); //this clears the entire screen and anything already drawn
        let popup_block = Block::default()
            .title(&quot;Y/N&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let exit_text = Text::styled(
            &quot;Would you like to output the buffer as json? (y/n)&quot;,
            Style::default().fg(Color::Red),
        );
        // the `trim: false` will stop the text from being cut off when over the edge of the block
        let exit_paragraph = Paragraph::new(exit_text)
            .block(popup_block)
            .wrap(Wrap { trim: false });

        let area = centered_rect(60, 25, f.size());
        f.render_widget(exit_paragraph, area);
    }
}

/// helper function to create a centered rect using up certain percentage of the available rect `r`
fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -&gt; Rect {
    // Cut the given rectangle into three vertical pieces
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage((100 - percent_y) / 2),
            Constraint::Percentage(percent_y),
            Constraint::Percentage((100 - percent_y) / 2),
        ])
        .split(r);

    // Then cut the middle vertical piece into three width-wise pieces
    Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage((100 - percent_x) / 2),
            Constraint::Percentage(percent_x),
            Constraint::Percentage((100 - percent_x) / 2),
        ])
        .split(popup_layout[1])[1] // Return the middle chunk
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-counter-app"><a class="header" href="#async-counter-app">Async Counter App</a></h1>
<p>In the previous counter app, we had a purely sequential blocking application. There are times when
you may be interested in running IO operations or compute asynchronously.</p>
<p>For this tutorial, we will build a single file version of an async TUI using
<a href="https://tokio.rs/">tokio</a>. This tutorial section is a simplified version of the
<a href="https://github.com/ratatui-org/ratatui-async-template"><code>ratatui-async-template</code></a> project.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Here‚Äôs an example of the <code>Cargo.toml</code> file required for this tutorial:</p>
<pre><code class="language-toml">[package]
name = &quot;ratatui-counter-async-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
color-eyre = &quot;0.6.2&quot;
crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }
ratatui = &quot;0.24.0&quot;
tokio = { version = &quot;1.32.0&quot;, features = [&quot;full&quot;] }
tokio-util = &quot;0.7.9&quot;
futures = &quot;0.3.28&quot;
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-async-app/index.html#admonition-note"></a></p>
</div>
<div>
<p>If you were already using <code>crossterm</code> before, note that now you‚Äôll need to add
<code>features = [&quot;event-stream&quot;]</code> to use crossterm‚Äôs async features.</p>
<p>You can use <code>cargo add</code> from the command line to add the above dependencies in one go:</p>
<pre><code class="language-bash">cargo add ratatui crossterm color-eyre tokio tokio-util futures --features tokio/full,crossterm/event-stream
</code></pre>
</div>
</div>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Let‚Äôs take the single file multiple function example from the counter app from earlier:</p>
<pre><code class="language-rust">// Hover on this codeblock and click &quot;Show hidden lines&quot; in the top right to see the full code
<span class="boring">use color_eyre::eyre::Result;
</span><span class="boring">use crossterm::{
</span><span class="boring">  event::{self, Event::Key, KeyCode::Char},
</span><span class="boring">  execute,
</span><span class="boring">  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span class="boring">};
</span><span class="boring">use ratatui::{
</span><span class="boring">  prelude::{CrosstermBackend, Terminal},
</span><span class="boring">  widgets::Paragraph,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
</span><span class="boring">
</span><span class="boring">fn startup() -&gt; Result&lt;()&gt; {
</span><span class="boring">  enable_raw_mode()?;
</span><span class="boring">  execute!(std::io::stderr(), EnterAlternateScreen)?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn shutdown() -&gt; Result&lt;()&gt; {
</span><span class="boring">  execute!(std::io::stderr(), LeaveAlternateScreen)?;
</span><span class="boring">  disable_raw_mode()?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App state
</span><span class="boring">struct App {
</span><span class="boring">  counter: i64,
</span><span class="boring">  should_quit: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App ui render function
</span><span class="boring">fn ui(app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
</span><span class="boring">  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App update function
</span><span class="boring">fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
</span><span class="boring">  if event::poll(std::time::Duration::from_millis(250))? {
</span><span class="boring">    if let Key(key) = event::read()? {
</span><span class="boring">      if key.kind == event::KeyEventKind::Press {
</span><span class="boring">        match key.code {
</span><span class="boring">          Char('j') =&gt; app.counter += 1,
</span><span class="boring">          Char('k') =&gt; app.counter -= 1,
</span><span class="boring">          Char('q') =&gt; app.should_quit = true,
</span><span class="boring">          _ =&gt; {},
</span><span class="boring">        }
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run() -&gt; Result&lt;()&gt; {
</span><span class="boring">  // ratatui terminal
</span><span class="boring">  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
</span><span class="boring">
</span><span class="boring">  // application state
</span><span class="boring">  let mut app = App { counter: 0, should_quit: false };
</span><span class="boring">
</span><span class="boring">  loop {
</span><span class="boring">    // application update
</span><span class="boring">    update(&amp;mut app)?;
</span><span class="boring">
</span><span class="boring">    // application render
</span><span class="boring">    t.draw(|f| {
</span><span class="boring">      ui(&amp;app, f);
</span><span class="boring">    })?;
</span><span class="boring">
</span><span class="boring">    // application exit
</span><span class="boring">    if app.should_quit {
</span><span class="boring">      break;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>fn main() -&gt; Result&lt;()&gt; {
  // setup terminal
  startup()?;

  let result = run();

  // teardown terminal before unwrapping Result of app run
  shutdown()?;

  result?;

  Ok(())
}</code></pre>
<p>Tokio is an asynchronous runtime for the Rust programming language. It provides the building blocks
needed for writing network applications. We recommend you read the
<a href="https://tokio.rs/tokio/tutorial">Tokio documentation</a> to learn more.</p>
<p>For the setup for this section of the tutorial, we are going to make just one change. We are going
to make our <code>main</code> function a <code>tokio</code> entry point.</p>
<pre><code class="language-rust">// Hover on this codeblock and click &quot;Show hidden lines&quot; in the top right to see the full code
<span class="boring">use color_eyre::eyre::Result;
</span><span class="boring">use crossterm::{
</span><span class="boring">  event::{self, Event::Key, KeyCode::Char},
</span><span class="boring">  execute,
</span><span class="boring">  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span class="boring">};
</span><span class="boring">use ratatui::{
</span><span class="boring">  prelude::{CrosstermBackend, Terminal},
</span><span class="boring">  widgets::Paragraph,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
</span><span class="boring">
</span><span class="boring">fn startup() -&gt; Result&lt;()&gt; {
</span><span class="boring">  enable_raw_mode()?;
</span><span class="boring">  execute!(std::io::stderr(), EnterAlternateScreen)?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn shutdown() -&gt; Result&lt;()&gt; {
</span><span class="boring">  execute!(std::io::stderr(), LeaveAlternateScreen)?;
</span><span class="boring">  disable_raw_mode()?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App state
</span><span class="boring">struct App {
</span><span class="boring">  counter: i64,
</span><span class="boring">  should_quit: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App ui render function
</span><span class="boring">fn ui(app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
</span><span class="boring">  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App update function
</span><span class="boring">fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
</span><span class="boring">  if event::poll(std::time::Duration::from_millis(250))? {
</span><span class="boring">    if let Key(key) = event::read()? {
</span><span class="boring">      if key.kind == event::KeyEventKind::Press {
</span><span class="boring">        match key.code {
</span><span class="boring">          Char('j') =&gt; app.counter += 1,
</span><span class="boring">          Char('k') =&gt; app.counter -= 1,
</span><span class="boring">          Char('q') =&gt; app.should_quit = true,
</span><span class="boring">          _ =&gt; {},
</span><span class="boring">        }
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run() -&gt; Result&lt;()&gt; {
</span><span class="boring">  // ratatui terminal
</span><span class="boring">  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
</span><span class="boring">
</span><span class="boring">  // application state
</span><span class="boring">  let mut app = App { counter: 0, should_quit: false };
</span><span class="boring">
</span><span class="boring">  loop {
</span><span class="boring">    // application update
</span><span class="boring">    update(&amp;mut app)?;
</span><span class="boring">
</span><span class="boring">    // application render
</span><span class="boring">    t.draw(|f| {
</span><span class="boring">      ui(&amp;app, f);
</span><span class="boring">    })?;
</span><span class="boring">
</span><span class="boring">    // application exit
</span><span class="boring">    if app.should_quit {
</span><span class="boring">      break;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  // setup terminal
  startup()?;

  let result = run();

  // teardown terminal before unwrapping Result of app run
  shutdown()?;

  result?;

  Ok(())
}</code></pre>
<p>Adding this <code>#[tokio::main]</code> macro allows us to spawn tokio tasks within <code>main</code>. At the moment,
there are no <code>async</code> functions other than <code>main</code> and we are not using <code>.await</code> anywhere yet. We will
change that in the following sections. But first, we let us introduce the <code>Action</code> enum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-event-stream"><a class="header" href="#async-event-stream">Async Event Stream</a></h1>
<p>Previously, in the multiple file version of the counter app, in
<a href="tutorial/counter-async-app/./../counter-app/event.html"><code>event.rs</code></a> we created an <code>EventHandler</code> using <code>std::thread::spawn</code>,
i.e. OS threads.</p>
<p>In this section, we are going to do the same thing with ‚Äúgreen‚Äù threads or tasks, i.e. rust‚Äôs
<code>async</code>-<code>await</code> features + a future executor. We will be using <code>tokio</code> for this.</p>
<p>Here‚Äôs example code of reading key presses asynchronously comparing <code>std::thread</code> and <code>tokio::task</code>.
Notably, we are using <code>tokio::sync::mpsc</code> channels instead of <code>std::sync::mpsc</code> channels. And
because of this, receiving on a channel needs to be <code>.await</code>‚Äôd and hence needs to be in a <code>async fn</code>
method.</p>
<pre><code class="language-diff">  enum Event {
    Key(crossterm::event::KeyEvent)
  }

  struct EventHandler {
-   rx: std::sync::mpsc::Receiver&lt;Event&gt;,
+   rx: tokio::sync::mpsc::UnboundedReceiver&lt;Event&gt;,
  }

  impl EventHandler {
    fn new() -&gt; Self {
      let tick_rate = std::time::Duration::from_millis(250);
-     let (tx, rx) =  std::sync::mpsc::channel();
+     let (tx, mut rx) =  tokio::sync::mpsc::unbounded_channel();
-     std::thread::spawn(move || {
+     tokio::spawn(async move {
        loop {
          if crossterm::event::poll(tick_rate).unwrap() {
            match crossterm::event::read().unwrap() {
              CrosstermEvent::Key(e) =&gt; {
                if key.kind == event::KeyEventKind::Press {
                  tx.send(Event::Key(e)).unwrap()
                }
              },
              _ =&gt; unimplemented!(),
            }
          }
        }
      })

      EventHandler { rx }
    }

-   fn next(&amp;self) -&gt; Result&lt;Event&gt; {
+   async fn next(&amp;self) -&gt; Result&lt;Event&gt; {
-     Ok(self.rx.recv()?)
+     Ok(self.rx.recv().await.ok()?)
    }
  }
</code></pre>
<p>Even with this change, our <code>EventHandler</code> behaves the same way as before. In order to take advantage
of using <code>tokio</code> we have to use <code>tokio::select!</code>.</p>
<p>We can use <a href="https://tokio.rs/tokio/tutorial/select"><code>tokio</code>‚Äôs <code>select!</code> macro</a> to wait on multiple
<code>async</code> computations and return when a any single computation completes.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-async-app/async-event-stream.html#admonition-note"></a></p>
</div>
<div>
<p>Using <code>crossterm::event::EventStream::new()</code> requires the <code>event-stream</code> feature to be enabled.
This also requires the <code>futures</code> crate. Naturally you‚Äôll also need <code>tokio</code>.</p>
<p>If you haven‚Äôt already, add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-yml">crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }
futures = &quot;0.3.28&quot;
tokio = { version = &quot;1.32.0&quot;, features = [&quot;full&quot;] }
tokio-util = &quot;0.7.9&quot; # required for `CancellationToken` introduced in the next section
</code></pre>
</div>
</div>
<p>Here‚Äôs what the <code>EventHandler</code> looks like with the <code>select!</code> macro:</p>
<pre><code class="language-rust">use color_eyre::eyre::Result;
use crossterm::event::KeyEvent;
use futures::{FutureExt, StreamExt};
use tokio::{sync::mpsc, task::JoinHandle};

#[derive(Clone, Copy, Debug)]
pub enum Event {
  Error,
  Tick,
  Key(KeyEvent),
}

#[derive(Debug)]
pub struct EventHandler {
  _tx: mpsc::UnboundedSender&lt;Event&gt;,
  rx: mpsc::UnboundedReceiver&lt;Event&gt;,
  task: Option&lt;JoinHandle&lt;()&gt;&gt;,
}

impl EventHandler {
  pub fn new() -&gt; Self {
    let tick_rate = std::time::Duration::from_millis(250);

    let (tx, rx) = mpsc::unbounded_channel();
    let _tx = tx.clone();

    let task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut interval = tokio::time::interval(tick_rate);
      loop {
        let delay = interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          maybe_event = crossterm_event =&gt; {
            match maybe_event {
              Some(Ok(evt)) =&gt; {
                match evt {
                  crossterm::event::Event::Key(key) =&gt; {
                    if key.kind == crossterm::event::KeyEventKind::Press {
                      tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  _ =&gt; {},
                }
              }
              Some(Err(_)) =&gt; {
                tx.send(Event::Error).unwrap();
              }
              None =&gt; {},
            }
          },
          _ = delay =&gt; {
              tx.send(Event::Tick).unwrap();
          },
        }
      }
    });

    Self { _tx, rx, task: Some(task) }
  }

  pub async fn next(&amp;mut self) -&gt; Result&lt;Event&gt; {
    self.rx.recv().await.ok_or(color_eyre::eyre::eyre!(&quot;Unable to get event&quot;))
  }
}</code></pre>
<p>As mentioned before, since <code>EventHandler::next()</code> is a <code>async</code> function, when we use it we have to
call <code>.await</code> on it. And the function that is the call site of <code>event_handler.next().await</code> also
needs to be an <code>async</code> function. In our tutorial, we are going to use the event handler in the
<code>run()</code> function which will now be <code>async</code>.</p>
<p>Also, now that we are getting events asynchronously, we don‚Äôt need to call
<code>crossterm::event::poll()</code> in the <code>update</code> function. Let‚Äôs make the <code>update</code> function take an
<code>Event</code> instead.</p>
<p>If you place the above <code>EventHandler</code> in a <code>src/tui.rs</code> file, then here‚Äôs what our application now
looks like:</p>
<pre><code class="language-rust">mod tui;

<span class="boring">use color_eyre::eyre::Result;
</span><span class="boring">use crossterm::{
</span><span class="boring">  event::{self, Event::Key, KeyCode::Char},
</span><span class="boring">  execute,
</span><span class="boring">  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span class="boring">};
</span><span class="boring">use ratatui::{
</span><span class="boring">  prelude::{CrosstermBackend, Terminal},
</span><span class="boring">  widgets::Paragraph,
</span><span class="boring">};
</span><span class="boring">use crossterm::{
</span><span class="boring">  cursor,
</span><span class="boring">  event::{Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
</span><span class="boring">
</span><span class="boring">fn startup() -&gt; Result&lt;()&gt; {
</span><span class="boring">  enable_raw_mode()?;
</span><span class="boring">  execute!(std::io::stderr(), EnterAlternateScreen)?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn shutdown() -&gt; Result&lt;()&gt; {
</span><span class="boring">  execute!(std::io::stderr(), LeaveAlternateScreen)?;
</span><span class="boring">  disable_raw_mode()?;
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App state
</span><span class="boring">struct App {
</span><span class="boring">  counter: i64,
</span><span class="boring">  should_quit: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App actions
</span><span class="boring">pub enum Action {
</span><span class="boring">  Tick,
</span><span class="boring">  Increment,
</span><span class="boring">  Decrement,
</span><span class="boring">  Quit,
</span><span class="boring">  None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// App ui render function
</span><span class="boring">fn ui(f: &amp;mut Frame&lt;'_&gt;, app: &amp;App) {
</span><span class="boring">  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
</span><span class="boring">}
</span><span class="boring">
</span>fn update(app: &amp;mut App, event: Event) -&gt; Result&lt;()&gt; {
  if let Event::Key(key) = event {
    match key.code {
      Char('j') =&gt; app.counter += 1,
      Char('k') =&gt; app.counter -= 1,
      Char('q') =&gt; app.should_quit = true,
      _ =&gt; {},
    }
  }
  Ok(())
}

async fn run() -&gt; Result&lt;()&gt; {

  let mut events = tui::EventHandler::new(); // new

  // ratatui terminal
  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    let event = events.next().await?; // new

    // application update
    update(&amp;mut app, event)?;

    // application render
    t.draw(|f| {
      ui(f, &amp;app);
    })?;

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  // setup terminal
  startup()?;

  let result = run().await;

  // teardown terminal before unwrapping Result of app run
  shutdown()?;

  result?;

  Ok(())
}</code></pre>
<p>Using <code>tokio</code> in this manner however only makes the key events asynchronous but doesn‚Äôt make the
rest of our application asynchronous yet. We will discuss that in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-async---events"><a class="header" href="#full-async---events">Full Async - <code>Event</code>s</a></h1>
<p>There are a number of ways to make our application work more in an <code>async</code> manner. The easiest way
to do this is to add more <code>Event</code> variants to our existing <code>EventHandler</code>. Specifically, we would
like to only render in the main run loop when we receive a <code>Event::Render</code> variant:</p>
<pre><code class="language-rust">#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Event {
  Quit,
  Error,
  Tick,
  Render, // new
  Key(KeyEvent),
}</code></pre>
<p>Another thing I personally like to do is combine the <code>EventHandler</code> struct and the <code>Terminal</code>
functionality. To do this, we are going to rename our <code>EventHandler</code> struct to a <code>Tui</code> struct. We
are also going to include a few more <code>Event</code> variants for making our application more capable.</p>
<p>Below is the relevant snippet of an updated <code>Tui</code> struct. You can click on the ‚ÄúShow hidden lines‚Äù
button at the top right of the code block or check out
<a href="tutorial/counter-async-app/../../how-to/develop-apps/abstract-terminal-and-event-handler.html">this section of the book</a> for the
full version this struct.</p>
<p>The key things to note are that we create a <code>tick_interval</code>, <code>render_interval</code> and <code>reader</code> stream
that can be polled using <code>tokio::select!</code>. This means that even while waiting for a key press, we
will still send a <code>Event::Tick</code> and <code>Event::Render</code> at regular intervals.</p>
<pre><code class="language-rust"><span class="boring">use std::{
</span><span class="boring">  ops::{Deref, DerefMut},
</span><span class="boring">  time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use color_eyre::eyre::Result;
</span><span class="boring">use crossterm::{
</span><span class="boring">  cursor,
</span><span class="boring">  event::{
</span><span class="boring">    DisableBracketedPaste, DisableMouseCapture, EnableBracketedPaste, EnableMouseCapture, Event as CrosstermEvent,
</span><span class="boring">    KeyEvent, KeyEventKind, MouseEvent,
</span><span class="boring">  },
</span><span class="boring">  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
</span><span class="boring">};
</span><span class="boring">use futures::{FutureExt, StreamExt};
</span><span class="boring">use ratatui::backend::CrosstermBackend as Backend;
</span><span class="boring">use tokio::{
</span><span class="boring">  sync::mpsc::{self, UnboundedReceiver, UnboundedSender},
</span><span class="boring">  task::JoinHandle,
</span><span class="boring">};
</span><span class="boring">use tokio_util::sync::CancellationToken;
</span><span class="boring">
</span><span class="boring">pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, Backend&lt;std::io::Stderr&gt;&gt;;
</span><span class="boring">
</span>#[derive(Clone, Debug)]
pub enum Event {
  Init,
  Quit,
  Error,
  Closed,
  Tick,
  Render,
  FocusGained,
  FocusLost,
  Paste(String),
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

pub struct Tui {
  pub terminal: ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;,
  pub task: JoinHandle&lt;()&gt;,
<span class="boring">  pub cancellation_token: CancellationToken,
</span>  pub event_rx: UnboundedReceiver&lt;Event&gt;,
  pub event_tx: UnboundedSender&lt;Event&gt;,
  pub frame_rate: f64,
  pub tick_rate: f64,
<span class="boring">  pub mouse: bool,
</span><span class="boring">  pub paste: bool,
</span>}

impl Tui {
<span class="boring">  pub fn new() -&gt; Result&lt;Self&gt; {
</span><span class="boring">    let tick_rate = 4.0;
</span><span class="boring">    let frame_rate = 60.0;
</span><span class="boring">    let terminal = ratatui::Terminal::new(Backend::new(std::io::stderr()))?;
</span><span class="boring">    let (event_tx, event_rx) = mpsc::unbounded_channel();
</span><span class="boring">    let cancellation_token = CancellationToken::new();
</span><span class="boring">    let task = tokio::spawn(async {});
</span><span class="boring">    let mouse = false;
</span><span class="boring">    let paste = false;
</span><span class="boring">    Ok(Self { terminal, task, cancellation_token, event_rx, event_tx, frame_rate, tick_rate, mouse, paste })
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn tick_rate(mut self, tick_rate: f64) -&gt; Self {
</span><span class="boring">    self.tick_rate = tick_rate;
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn frame_rate(mut self, frame_rate: f64) -&gt; Self {
</span><span class="boring">    self.frame_rate = frame_rate;
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn mouse(mut self, mouse: bool) -&gt; Self {
</span><span class="boring">    self.mouse = mouse;
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn paste(mut self, paste: bool) -&gt; Self {
</span><span class="boring">    self.paste = paste;
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span>  pub fn start(&amp;mut self) {
    let tick_delay = std::time::Duration::from_secs_f64(1.0 / self.tick_rate);
    let render_delay = std::time::Duration::from_secs_f64(1.0 / self.frame_rate);
<span class="boring">    self.cancel();
</span><span class="boring">    self.cancellation_token = CancellationToken::new();
</span><span class="boring">    let _cancellation_token = self.cancellation_token.clone();
</span>    let _event_tx = self.event_tx.clone();
    self.task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut tick_interval = tokio::time::interval(tick_delay);
      let mut render_interval = tokio::time::interval(render_delay);
<span class="boring">      _event_tx.send(Event::Init).unwrap();
</span>      loop {
        let tick_delay = tick_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
<span class="boring">          _ = _cancellation_token.cancelled() =&gt; {
</span><span class="boring">            break;
</span><span class="boring">          }
</span>          maybe_event = crossterm_event =&gt; {
            match maybe_event {
              Some(Ok(evt)) =&gt; {
                match evt {
                  CrosstermEvent::Key(key) =&gt; {
                    if key.kind == KeyEventKind::Press {
                      _event_tx.send(Event::Key(key)).unwrap();
                    }
                  },
<span class="boring">                  CrosstermEvent::Mouse(mouse) =&gt; {
</span><span class="boring">                    _event_tx.send(Event::Mouse(mouse)).unwrap();
</span><span class="boring">                  },
</span><span class="boring">                  CrosstermEvent::Resize(x, y) =&gt; {
</span><span class="boring">                    _event_tx.send(Event::Resize(x, y)).unwrap();
</span><span class="boring">                  },
</span><span class="boring">                  CrosstermEvent::FocusLost =&gt; {
</span><span class="boring">                    _event_tx.send(Event::FocusLost).unwrap();
</span><span class="boring">                  },
</span><span class="boring">                  CrosstermEvent::FocusGained =&gt; {
</span><span class="boring">                    _event_tx.send(Event::FocusGained).unwrap();
</span><span class="boring">                  },
</span><span class="boring">                  CrosstermEvent::Paste(s) =&gt; {
</span><span class="boring">                    _event_tx.send(Event::Paste(s)).unwrap();
</span><span class="boring">                  },
</span>                }
              }
              Some(Err(_)) =&gt; {
                _event_tx.send(Event::Error).unwrap();
              }
              None =&gt; {},
            }
          },
          _ = tick_delay =&gt; {
              _event_tx.send(Event::Tick).unwrap();
          },
          _ = render_delay =&gt; {
              _event_tx.send(Event::Render).unwrap();
          },
        }
      }
    });
  }
<span class="boring">
</span><span class="boring">  pub fn enter(&amp;mut self) -&gt; Result&lt;()&gt; {
</span><span class="boring">    crossterm::terminal::enable_raw_mode()?;
</span><span class="boring">    crossterm::execute!(std::io::stderr(), EnterAlternateScreen, cursor::Hide)?;
</span><span class="boring">    if self.mouse {
</span><span class="boring">      crossterm::execute!(std::io::stderr(), EnableMouseCapture)?;
</span><span class="boring">    }
</span><span class="boring">    if self.paste {
</span><span class="boring">      crossterm::execute!(std::io::stderr(), EnableBracketedPaste)?;
</span><span class="boring">    }
</span><span class="boring">    self.start();
</span><span class="boring">    Ok(())
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
</span><span class="boring">    self.stop()?;
</span><span class="boring">    if crossterm::terminal::is_raw_mode_enabled()? {
</span><span class="boring">      self.flush()?;
</span><span class="boring">      if self.paste {
</span><span class="boring">        crossterm::execute!(std::io::stderr(), DisableBracketedPaste)?;
</span><span class="boring">      }
</span><span class="boring">      if self.mouse {
</span><span class="boring">        crossterm::execute!(std::io::stderr(), DisableMouseCapture)?;
</span><span class="boring">      }
</span><span class="boring">      crossterm::execute!(std::io::stderr(), LeaveAlternateScreen, cursor::Show)?;
</span><span class="boring">      crossterm::terminal::disable_raw_mode()?;
</span><span class="boring">    }
</span><span class="boring">    Ok(())
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn cancel(&amp;self) {
</span><span class="boring">    self.cancellation_token.cancel();
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub fn resume(&amp;mut self) -&gt; Result&lt;()&gt; {
</span><span class="boring">    self.enter()?;
</span><span class="boring">    Ok(())
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  pub async fn next(&amp;mut self) -&gt; Result&lt;Event&gt; {
</span><span class="boring">    self.event_rx.recv().await.ok_or(color_eyre::eyre::eyre!(&quot;Unable to get event&quot;))
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Deref for Tui {
</span><span class="boring">  type Target = ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;;
</span><span class="boring">
</span><span class="boring">  fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">    &amp;self.terminal
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DerefMut for Tui {
</span><span class="boring">  fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">    &amp;mut self.terminal
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for Tui {
</span><span class="boring">  fn drop(&amp;mut self) {
</span><span class="boring">    self.exit().unwrap();
</span><span class="boring">  }
</span><span class="boring">}</span></code></pre>
<p>We made a number of changes to the <code>Tui</code> struct.</p>
<ol>
<li>We added a <code>Deref</code> and <code>DerefMut</code> so we can call <code>tui.draw(|f| ...)</code> to have it call
<code>tui.terminal.draw(|f| ...)</code>.</li>
<li>We moved the <code>startup()</code> and <code>shutdown()</code> functionality into the <code>Tui</code> struct.</li>
<li>We also added a <code>CancellationToken</code> so that we can start and stop the tokio task more easily.</li>
<li>We added <code>Event</code> variants for <code>Resize</code>, <code>Focus</code>, and <code>Paste</code>.</li>
<li>We added methods to set the <code>tick_rate</code>, <code>frame_rate</code>, and whether we want to enable <code>mouse</code> or
<code>paste</code> events.</li>
</ol>
<p>Here‚Äôs the code for the fully async application:</p>
<pre><code class="language-rust">mod tui;

use color_eyre::eyre::Result;
use crossterm::event::KeyCode::Char;
use ratatui::{prelude::CrosstermBackend, widgets::Paragraph};
use tui::Event;

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

// App state
struct App {
  counter: i64,
  should_quit: bool,
}

// App ui render function
fn ui(f: &amp;mut Frame&lt;'_&gt;, app: &amp;App) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}

fn update(app: &amp;mut App, event: Event) {
  match event {
    Event::Key(key) =&gt; {
      match key.code {
        Char('j') =&gt; app.counter += 1,
        Char('k') =&gt; app.counter -= 1,
        Char('q') =&gt; app.should_quit = true,
        _ =&gt; Action::None,
      }
    },
    _ =&gt; {},
  };
}

async fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut tui = tui::Tui::new()?.tick_rate(1.0).frame_rate(30.0);
  tui.enter()?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    let event = tui.next().await?; // blocks until next event

    if let Event::Render = event.clone() {
      // application render
      tui.draw(|f| {
        ui(f, &amp;app);
      })?;
    }

    // application update
    update(&amp;mut app, event);

    // application exit
    if app.should_quit {
      break;
    }
  }
  tui.exit()?;

  Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  let result = run().await;

  result?;

  Ok(())
}</code></pre>
<p>The above code ensures that we render at a consistent frame rate. As an exercise, play around with
this frame rate and tick rate to see how the CPU utilization changes as you change those numbers.</p>
<p>Even though our application renders in an ‚Äúasync‚Äù manner, we also want to perform ‚Äúactions‚Äù in an
asynchronous manner. We will improve this in the next section to make our application truly async
capable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter-app-with-actions"><a class="header" href="#counter-app-with-actions">Counter App with Actions</a></h1>
<p>One of the first steps to building truly <code>async</code> TUI applications is to use the <code>Command</code>, <code>Action</code>,
or <code>Message</code> pattern.</p>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-async-app/actions.html#admonition-tip"></a></p>
</div>
<div>
<p>The <code>Command</code> pattern is the concept of ‚Äúreified method calls‚Äù.
You can learn a lot more about this pattern from the excellent <a href="http://gameprogrammingpatterns.com/command.html">http://gameprogrammingpatterns.com</a>.</p>
</div>
</div>
<p>You can learn more about this concept in
<a href="tutorial/counter-async-app/../../concepts/application-patterns/the-elm-architecture.html">The Elm Architecture section</a> of the
documentation.</p>
<p>We have learnt about enums in JSON-editor tutorial. We are going to extend the counter application
to include <code>Action</code>s using Rust‚Äôs enum features. The key idea is that we have an <code>Action</code> enum that
tracks all the actions that can be carried out by the <code>App</code>. Here‚Äôs the variants of the <code>Action</code>
enum we will be using:</p>
<pre><code class="language-rust">pub enum Action {
  Tick,
  Increment,
  Decrement,
  Quit,
  None,
}</code></pre>
<p>Now we add a new <code>get_action</code> function to map a <code>Event</code> to an <code>Action</code>.</p>
<pre><code class="language-rust">fn get_action(_app: &amp;App, event: Event) -&gt; Action {
  if let Key(key) = event {
    return match key.code {
      Char('j') =&gt; Action::Increment,
      Char('k') =&gt; Action::Decrement,
      Char('q') =&gt; Action::Quit,
      _ =&gt; Action::None,
    };
  };
  Action::None
}</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-async-app/actions.html#admonition-tip-1"></a></p>
</div>
<div>
<p>Instead of using a <code>None</code> variant in <code>Action</code>, you can drop the <code>None</code> from <code>Action</code>
and use Rust‚Äôs built-in <code>Option</code> types instead.
This is what your code might actually look like:</p>
<pre><code class="language-rust">fn get_action(_app: &amp;App, event: Event) -&gt; Result&lt;Option&lt;Action&gt;&gt; {
  if let Key(key) = event {
    let action = match key.code {
      Char('j') =&gt; Action::Increment,
      Char('k') =&gt; Action::Decrement,
      Char('q') =&gt; Action::Quit,
      _ =&gt; return Ok(None),
    };
    return Ok(Some(action))
  };
  Ok(None)
}</code></pre>
<p>But, for illustration purposes, in this tutorial we will stick to using <code>Action::None</code> for now.</p>
</div>
</div>
<p>And the <code>update</code> function takes an <code>Action</code> instead:</p>
<pre><code class="language-rust">fn update(app: &amp;mut App, action: Action) {
  match action {
    Action::Quit =&gt; app.should_quit = true,
    Action::Increment =&gt; app.counter += 1,
    Action::Decrement =&gt; app.counter -= 1,
    Action::Tick =&gt; {},
    _ =&gt; {},
  };
}
</code></pre>
<p>Here‚Äôs the full single file version of the counter app using the <code>Action</code> enum for your reference:</p>
<pre><code class="language-rust">mod tui;

use color_eyre::eyre::Result;
use crossterm::{
  event::{self, Event::Key, KeyCode::Char},
  execute,
  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

// App state
struct App {
  counter: i64,
  should_quit: bool,
}

// App actions
pub enum Action {
  Tick,
  Increment,
  Decrement,
  Quit,
  None,
}

// App ui render function
fn ui(app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}

fn get_action(_app: &amp;App, event: Event) -&gt; Action {
  if let Key(key) = event {
    return match key.code {
      Char('j') =&gt; Action::Increment,
      Char('k') =&gt; Action::Decrement,
      Char('q') =&gt; Action::Quit,
      _ =&gt; Action::None,
    };
  };
  Action::None
}

fn update(app: &amp;mut App, action: Action) {
  match action {
    Action::Quit =&gt; app.should_quit = true,
    Action::Increment =&gt; app.counter += 1,
    Action::Decrement =&gt; app.counter -= 1,
    Action::Tick =&gt; {},
    _ =&gt; {},
  };
}

fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut tui = tui::Tui::new()?.tick_rate(1.0).frame_rate(30.0);
  tui.enter()?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    let event = tui.next().await?; // blocks until next event

    if let Event::Render = event.clone() {
      // application render
      tui.draw(|f| {
        ui(f, &amp;app);
      })?;
    }
    let action = get_action(&amp;mut app, event); // new

    // application update
    update(&amp;mut app, action); // new

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  let result = run().await;

  result?;

  Ok(())
}</code></pre>
<p>While this may seem like a lot more boilerplate to achieve the same thing, <code>Action</code> enums have a few
advantages.</p>
<p>Firstly, they can be mapped from keypresses programmatically. For example, you can define a
configuration file that reads which keys are mapped to which <code>Action</code> like so:</p>
<pre><code class="language-toml">[keymap]
&quot;q&quot; = &quot;Quit&quot;
&quot;j&quot; = &quot;Increment&quot;
&quot;k&quot; = &quot;Decrement&quot;
</code></pre>
<p>Then you can add a new key configuration like so:</p>
<pre><code class="language-rust">struct App {
  counter: i64,
  should_quit: bool,
  // new field
  keyconfig: HashMap&lt;KeyCode, Action&gt;
}</code></pre>
<p>If you populate <code>keyconfig</code> with the contents of a user provided <code>toml</code> file, then you can figure
out which action to take by updating the <code>get_action()</code> function:</p>
<pre><code class="language-rust">fn get_action(app: &amp;App, event: Event) -&gt; Action {
  if let Event::Key(key) = event {
    return app.keyconfig.get(key.code).unwrap_or(Action::None)
  };
  Action::None
}</code></pre>
<p>Another advantage of this is that the business logic of the <code>App</code> struct can be tested without
having to create an instance of a <code>Tui</code> or <code>EventHandler</code>, e.g.:</p>
<pre><code class="language-rust">mod tests {
  #[test]
  fn test_app() {
    let mut app = App::new();
    let old_counter = app.counter;
    update(&amp;mut app, Action::Increment);
    assert!(app.counter == old_counter + 1);
  }
}</code></pre>
<p>In the test above, we did not create an instance of the <code>Terminal</code> or the <code>EventHandler</code>, and did
not call the <code>run</code> function, but we are still able to test the business logic of our application.
Updating the app state on <code>Action</code>s gets us one step closer to making our application a ‚Äústate
machine‚Äù, which improves understanding and testability.</p>
<p>If we wanted to be purist about it, we would make a struct called <code>AppState</code> which would be
immutable, and we would have an <code>update</code> function return a new instance of the <code>AppState</code>:</p>
<pre><code class="language-rust">fn update(app_state: AppState, action: Action) -&gt; AppState {
  let mut state = app_state.clone();
  state.counter += 1;
  state
}</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-async-app/actions.html#admonition-note"></a></p>
</div>
<div>
<p><a href="https://github.com/charmbracelet/bubbletea"><code>Charm</code>‚Äôs <code>bubbletea</code></a> also follows the TEA paradigm.
Here‚Äôs an example of what the <code>Update</code> function for a counter example might look like in Go:</p>
<pre><code class="language-go">func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {

    // Is it a key press?
    case tea.KeyMsg:
        // These keys should exit the program.
        case &quot;q&quot;:
            return m, tea.Quit

        case &quot;k&quot;:
            m.counter--

        case &quot;j&quot;:
            m.counter++
    }

    // Note that we're not returning a command.
    return m, nil
}
</code></pre>
</div>
</div>
<p>Like in <code>Charm</code>, we may also want to choose a action to follow up after an <code>update</code> by returning
another <code>Action</code>:</p>
<pre><code class="language-rust">fn update(app_state: AppState, action: Action) -&gt; (AppState, Action) {
  let mut state = app_state.clone();
  state.counter += 1;
  (state, Action::None) // no follow up action
  // OR
  (state, Action::Tick) // force app to tick
}</code></pre>
<p>We would have to modify our <code>run</code> function to handle the above paradigm though. Also, writing code
to follow this architecture in Rust requires more upfront design, mostly because you have to make
your <code>AppState</code> struct <code>Clone</code>-friendly.</p>
<p>For this tutorial, we will stick to having a mutable <code>App</code>:</p>
<pre><code class="language-rust">fn update(app: &amp;mut App, action: Action) {
  match action {
    Action::Quit =&gt; app.should_quit = true,
    Action::Increment =&gt; app.counter += 1,
    Action::Decrement =&gt; app.counter -= 1,
    Action::Tick =&gt; {},
    _ =&gt; {},
  };
}</code></pre>
<p>The other advantage of using an <code>Action</code> enum is that you can tell your application what it should
do next by sending a message over a channel. We will discuss this approach in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-async---actions"><a class="header" href="#full-async---actions">Full Async - <code>Action</code>s</a></h1>
<p>Now that we have introduced <code>Event</code>s and <code>Action</code>s, we are going introduce a new <code>mpsc::channel</code> for
<code>Action</code>s. The advantage of this is that we can programmatically trigger updates to the state of the
app by sending <code>Action</code>s on the channel.</p>
<p>Here‚Äôs the <code>run</code> function refactored from before to introduce an <code>Action</code> channel. In addition to
refactoring, we store the <code>action_tx</code> half of the channel in the <code>App</code>.</p>
<pre><code class="language-rust">async fn run() -&gt; Result&lt;()&gt; {
  let (action_tx, mut action_rx) = mpsc::unbounded_channel(); // new

  // ratatui terminal
  let mut tui = tui::Tui::new()?.tick_rate(1.0).frame_rate(30.0);
  tui.enter()?;

  // application state
  let mut app = App { counter: 0, should_quit: false, action_tx: action_tx.clone() };

  loop {
    let e = tui.next().await?;
    match e {
      tui::Event::Quit =&gt; action_tx.send(Action::Quit)?,
      tui::Event::Tick =&gt; action_tx.send(Action::Tick)?,
      tui::Event::Render =&gt; action_tx.send(Action::Render)?,
      tui::Event::Key(_) =&gt; {
        let action = get_action(&amp;app, e);
        action_tx.send(action.clone())?;
      },
      _ =&gt; {},
    };

    while let Ok(action) = action_rx.try_recv() {
      // application update
      update(&amp;mut app, action.clone());
      // render only when we receive Action::Render
      if let Action::Render = action {
        tui.draw(|f| {
          ui(f, &amp;mut app);
        })?;
      }
    }

    // application exit
    if app.should_quit {
      break;
    }
  }
  tui.exit()?;

  Ok(())
}</code></pre>
<p>Running the code with this change should give the exact same behavior as before.</p>
<p>Now that we have stored the <code>action_tx</code> half of the channel in the <code>App</code>, we can use this to
schedule tasks. For example, let‚Äôs say we wanted to press <code>J</code> and <code>K</code> to perform some network
request and <em>then</em> increment the counter.</p>
<p>First, we have to update my <code>Action</code> enum:</p>
<pre><code class="language-rust">#[derive(Clone)]
pub enum Action {
  Tick,
  Increment,
  Decrement,
  NetworkRequestAndThenIncrement, // new
  NetworkRequestAndThenDecrement, // new
  Quit,
  Render,
  None,
}</code></pre>
<p>Next, we can update my event handler:</p>
<pre><code class="language-rust">fn get_action(_app: &amp;App, event: Event) -&gt; Action {
  match event {
    Event::Error =&gt; Action::None,
    Event::Tick =&gt; Action::Tick,
    Event::Render =&gt; Action::Render,
    Event::Key(key) =&gt; {
      match key.code {
        Char('j') =&gt; Action::Increment,
        Char('k') =&gt; Action::Decrement,
        Char('J') =&gt; Action::NetworkRequestAndThenIncrement, // new
        Char('K') =&gt; Action::NetworkRequestAndThenIncrement, // new
        Char('q') =&gt; Action::Quit,
        _ =&gt; Action::None,
      }
    },
    _ =&gt; Action::None,
  }
}</code></pre>
<p>Finally, we can handle the action in my <code>update</code> function my spawning a tokio task:</p>
<pre><code class="language-rust">fn update(app: &amp;mut App, action: Action) {
  match action {
    Action::Increment =&gt; {
      app.counter += 1;
    },
    Action::Decrement =&gt; {
      app.counter -= 1;
    },
    Action::NetworkRequestAndThenIncrement =&gt; {
      let tx = app.action_tx.clone();
      tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(5)).await; // simulate network request
        tx.send(Action::Increment).unwrap();
      });
    },
    Action::NetworkRequestAndThenDecrement =&gt; {
      let tx = app.action_tx.clone();
      tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(5)).await; // simulate network request
        tx.send(Action::Decrement).unwrap();
      });
    },
    Action::Quit =&gt; app.should_quit = true,
    _ =&gt; {},
  };
}</code></pre>
<p>Here is the full code for reference:</p>
<pre><code class="language-rust">mod tui;

use std::time::Duration;

use color_eyre::eyre::Result;
use crossterm::event::KeyCode::Char;
use ratatui::{prelude::*, widgets::*};
use tokio::sync::mpsc::{self, UnboundedSender};
use tui::Event;

// App state
struct App {
  counter: i64,
  should_quit: bool,
  action_tx: UnboundedSender&lt;Action&gt;,
}

// App actions
#[derive(Clone)]
pub enum Action {
  Tick,
  Increment,
  Decrement,
  NetworkRequestAndThenIncrement, // new
  NetworkRequestAndThenDecrement, // new
  Quit,
  Render,
  None,
}

// App ui render function
fn ui(f: &amp;mut Frame&lt;'_&gt;, app: &amp;mut App) {
  let area = f.size();
  f.render_widget(
    Paragraph::new(format!(&quot;Press j or k to increment or decrement.\n\nCounter: {}&quot;, app.counter,))
      .block(
        Block::default()
          .title(&quot;ratatui async counter app&quot;)
          .title_alignment(Alignment::Center)
          .borders(Borders::ALL)
          .border_type(BorderType::Rounded),
      )
      .style(Style::default().fg(Color::Cyan))
      .alignment(Alignment::Center),
    area,
  );
}

fn get_action(_app: &amp;App, event: Event) -&gt; Action {
  match event {
    Event::Error =&gt; Action::None,
    Event::Tick =&gt; Action::Tick,
    Event::Render =&gt; Action::Render,
    Event::Key(key) =&gt; {
      match key.code {
        Char('j') =&gt; Action::Increment,
        Char('k') =&gt; Action::Decrement,
        Char('J') =&gt; Action::NetworkRequestAndThenIncrement, // new
        Char('K') =&gt; Action::NetworkRequestAndThenIncrement, // new
        Char('q') =&gt; Action::Quit,
        _ =&gt; Action::None,
      }
    },
    _ =&gt; Action::None,
  }
}

fn update(app: &amp;mut App, action: Action) {
  match action {
    Action::Increment =&gt; {
      app.counter += 1;
    },
    Action::Decrement =&gt; {
      app.counter -= 1;
    },
    Action::NetworkRequestAndThenIncrement =&gt; {
      let tx = app.action_tx.clone();
      tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(5)).await; // simulate network request
        tx.send(Action::Increment).unwrap();
      });
    },
    Action::NetworkRequestAndThenDecrement =&gt; {
      let tx = app.action_tx.clone();
      tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(5)).await; // simulate network request
        tx.send(Action::Decrement).unwrap();
      });
    },
    Action::Quit =&gt; app.should_quit = true,
    _ =&gt; {},
  };
}

async fn run() -&gt; Result&lt;()&gt; {
  let (action_tx, mut action_rx) = mpsc::unbounded_channel(); // new

  // ratatui terminal
  let mut tui = tui::Tui::new()?.tick_rate(1.0).frame_rate(30.0);
  tui.enter()?;

  // application state
  let mut app = App { counter: 0, should_quit: false, action_tx: action_tx.clone() };

  loop {
    let e = tui.next().await?;
    match e {
      tui::Event::Quit =&gt; action_tx.send(Action::Quit)?,
      tui::Event::Tick =&gt; action_tx.send(Action::Tick)?,
      tui::Event::Render =&gt; action_tx.send(Action::Render)?,
      tui::Event::Key(_) =&gt; {
        let action = get_action(&amp;app, e);
        action_tx.send(action.clone())?;
      },
      _ =&gt; {},
    };

    while let Ok(action) = action_rx.try_recv() {
      // application update
      update(&amp;mut app, action.clone());
      // render only when we receive Action::Render
      if let Action::Render = action {
        tui.draw(|f| {
          ui(f, &amp;mut app);
        })?;
      }
    }

    // application exit
    if app.should_quit {
      break;
    }
  }
  tui.exit()?;

  Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  let result = run().await;

  result?;

  Ok(())
}</code></pre>
<p>With that, we have a fully async application that is tokio ready to spawn tasks to do work
concurrently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h1>
<p>We touched on the basic framework for building an <code>async</code> application with Ratatui, namely using
<code>tokio</code> and <code>crossterm</code>‚Äôs async features to create an <code>Event</code> and <code>Action</code> enum that contain
<code>Render</code> variants. We also saw how we could use <code>tokio</code> channels to send <code>Action</code>s to run domain
specific async operations concurrently.</p>
<p>There‚Äôs more information in
<a href="https://github.com/ratatui-org/ratatui-async-template"><code>ratatui-async-template</code></a> about structuring
an <code>async</code> application. The template also covers setting up a
<a href="tutorial/counter-async-app/../../concepts/application-patterns/component-architecture.html"><code>Component</code> based architecture</a>.</p>
<p>For more information, refer to the documentation for the template:
<a href="https://ratatui-org.github.io/ratatui-async-template/">https://ratatui-org.github.io/ratatui-async-template/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stopwatch-app"><a class="header" href="#stopwatch-app">Stopwatch App</a></h1>
<p>In this section, we are going to combine what we learnt in the previous tutorials and build a
stopwatch application. We are also going to take advantage of a widget from an external dependency.</p>
<p>Here‚Äôs the dependencies you‚Äôll need in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;ratatui-stopwatch-app&quot;
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
color-eyre = &quot;0.6.2&quot;
crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }
directories = &quot;5.0.1&quot;
futures = &quot;0.3.28&quot;
human-panic = &quot;1.2.0&quot;
itertools = &quot;0.11.0&quot;
libc = &quot;0.2.147&quot;
log = &quot;0.4.20&quot;
ratatui = &quot;0.24.0&quot;
strip-ansi-escapes = &quot;0.2.0&quot;
strum = &quot;0.25.0&quot;
tokio = { version = &quot;1.32.0&quot;, features = [&quot;full&quot;] }
tokio-util = &quot;0.7.8&quot;
tui-big-text = &quot;0.2.1&quot;
</code></pre>
<p>Here‚Äôs a gif of what it will look like if you run this:</p>
<p><img src="https://vhs.charm.sh/vhs-3dTTtrLkyU54hNah22PAR9.gif" alt="Stopwatch" /></p>
<p>This application uses an external dependency called
<a href="https://github.com/joshka/tui-big-text"><code>tui-big-text</code></a>.</p>
<p>This application also combines the <code>AppState</code> (or Mode) pattern from
<a href="tutorial/stopwatch-app/../json-editor/README.html">the JSON Editor</a> with the <code>Message</code> (or <code>Command</code> or <code>Action</code>) pattern
from <a href="tutorial/stopwatch-app/../counter-async-app/README.html">the Async Counter App</a>. This <code>Message</code> pattern is common in
<a href="tutorial/stopwatch-app/../../concepts/application-patterns/the-elm-architecture.html">The Elm Architecture pattern</a>.</p>
<p>This application uses a <code>Tui</code> struct that
<a href="tutorial/stopwatch-app/../../how-to/develop-apps/abstract-terminal-and-event-handler.html">combines the <code>Terminal</code> and <code>Event Handler</code></a>
that we discussed in the previous section.</p>
<p>The full code is available on
<a href="https://github.com/ratatui-org/ratatui-book/tree/main/src/tutorial/stopwatch-app/ratatui-stopwatch-app">GitHub</a>.</p>
<p>Here‚Äôs the relevant application part of the code:</p>
<pre><code class="language-rust">use std::time::{Duration, Instant};

use color_eyre::eyre::{eyre, Result};
use futures::{FutureExt, StreamExt};
use itertools::Itertools;
use ratatui::{backend::CrosstermBackend as Backend, prelude::*, widgets::*};
use strum::EnumIs;
use tui_big_text::BigText;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
  let mut app = StopwatchApp::default();
  app.run().await
}

#[derive(Clone, Debug)]
pub enum Event {
  Error,
  Tick,
  Key(crossterm::event::KeyEvent),
}

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, EnumIs)]
enum AppState {
  #[default]
  Stopped,
  Running,
  Quitting,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Message {
  StartOrSplit,
  Stop,
  Tick,
  Quit,
}

#[derive(Debug, Clone, PartialEq)]
struct StopwatchApp {
  state: AppState,
  splits: Vec&lt;Instant&gt;,
  start_time: Instant,
  frames: u32,
  fps: f64,
}

impl Default for StopwatchApp {
  fn default() -&gt; Self {
    Self::new()
  }
}

impl StopwatchApp {
  fn new() -&gt; Self {
    Self {
      start_time: Instant::now(),
      frames: Default::default(),
      fps: Default::default(),
      splits: Default::default(),
      state: Default::default(),
    }
  }

  async fn run(&amp;mut self) -&gt; Result&lt;()&gt; {
    let mut tui = Tui::new()?;
    tui.enter()?;
    while !self.state.is_quitting() {
      tui.draw(|f| self.ui(f).expect(&quot;Unexpected error during drawing&quot;))?;
      let event = tui.next().await.ok_or(eyre!(&quot;Unable to get event&quot;))?; // blocks until next event
      let message = self.handle_event(event)?;
      self.update(message)?;
    }
    tui.exit()?;
    Ok(())
  }

  fn handle_event(&amp;self, event: Event) -&gt; Result&lt;Message&gt; {
    let msg = match event {
      Event::Key(key) =&gt; {
        match key.code {
          crossterm::event::KeyCode::Char('q') =&gt; Message::Quit,
          crossterm::event::KeyCode::Char(' ') =&gt; Message::StartOrSplit,
          crossterm::event::KeyCode::Char('s') | crossterm::event::KeyCode::Enter =&gt; Message::Stop,
          _ =&gt; Message::Tick,
        }
      },
      _ =&gt; Message::Tick,
    };
    Ok(msg)
  }

  fn update(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
    match message {
      Message::StartOrSplit =&gt; self.start_or_split(),
      Message::Stop =&gt; self.stop(),
      Message::Tick =&gt; self.tick(),
      Message::Quit =&gt; self.quit(),
    }
    Ok(())
  }

  fn start_or_split(&amp;mut self) {
    if self.state.is_stopped() {
      self.start();
    } else {
      self.record_split();
    }
  }

  fn stop(&amp;mut self) {
    self.record_split();
    self.state = AppState::Stopped;
  }

  fn tick(&amp;mut self) {
    self.frames += 1;
    let now = Instant::now();
    let elapsed = (now - self.start_time).as_secs_f64();
    if elapsed &gt;= 1.0 {
      self.fps = self.frames as f64 / elapsed;
      self.start_time = now;
      self.frames = 0;
    }
  }

  fn quit(&amp;mut self) {
    self.state = AppState::Quitting
  }

  fn start(&amp;mut self) {
    self.splits.clear();
    self.state = AppState::Running;
    self.record_split();
  }

  fn record_split(&amp;mut self) {
    if !self.state.is_running() {
      return;
    }
    self.splits.push(Instant::now());
  }

  fn elapsed(&amp;mut self) -&gt; Duration {
    if self.state.is_running() {
      self.splits.first().map_or(Duration::ZERO, Instant::elapsed)
    } else {
      // last - first or 0 if there are no splits
      let now = Instant::now();
      let first = *self.splits.first().unwrap_or(&amp;now);
      let last = *self.splits.last().unwrap_or(&amp;now);
      last - first
    }
  }

  fn ui(&amp;mut self, f: &amp;mut Frame) -&gt; Result&lt;()&gt; {
    let layout = self.layout(f.size());
    f.render_widget(Paragraph::new(&quot;Stopwatch Example&quot;), layout[0]);
    f.render_widget(self.fps_paragraph(), layout[1]);
    f.render_widget(self.timer_paragraph(), layout[2]);
    f.render_widget(Paragraph::new(&quot;Splits:&quot;), layout[3]);
    f.render_widget(self.splits_paragraph(), layout[4]);
    f.render_widget(self.help_paragraph(), layout[5]);
    Ok(())
  }

  fn fps_paragraph(&amp;mut self) -&gt; Paragraph&lt;'_&gt; {
    let fps = format!(&quot;{:.2} fps&quot;, self.fps);
    Paragraph::new(fps).style(Style::new().dim()).alignment(Alignment::Right)
  }

  fn timer_paragraph(&amp;mut self) -&gt; BigText&lt;'_&gt; {
    let style = if self.state.is_running() { Style::new().green() } else { Style::new().red() };
    let elapsed = self.elapsed();
    let duration = self.format_duration(elapsed);
    let lines = vec![duration.into()];
    tui_big_text::BigTextBuilder::default().lines(lines).style(style).build().unwrap()
  }

  /// Renders the splits as a list of lines.
  ///
  /// ```text
  /// #01 -- 00:00.693 -- 00:00.693
  /// #02 -- 00:00.719 -- 00:01.413
  /// ```
  fn splits_paragraph(&amp;mut self) -&gt; Paragraph&lt;'_&gt; {
    let start = *self.splits.first().unwrap_or(&amp;Instant::now());
    let mut splits = self
      .splits
      .iter()
      .copied()
      .tuple_windows()
      .enumerate()
      .map(|(index, (prev, current))| self.format_split(index, start, prev, current))
      .collect::&lt;Vec&lt;_&gt;&gt;();
    splits.reverse();
    Paragraph::new(splits)
  }

  fn help_paragraph(&amp;mut self) -&gt; Paragraph&lt;'_&gt; {
    let space_action = if self.state.is_stopped() { &quot;start&quot; } else { &quot;split&quot; };
    let help_text =
      Line::from(vec![&quot;space &quot;.into(), space_action.dim(), &quot; enter &quot;.into(), &quot;stop&quot;.dim(), &quot; q &quot;.into(), &quot;quit&quot;.dim()]);
    Paragraph::new(help_text).gray()
  }

  fn layout(&amp;self, area: Rect) -&gt; Vec&lt;Rect&gt; {
    let layout = Layout::default()
      .direction(Direction::Vertical)
      .constraints(vec![
        Constraint::Length(2), // top bar
        Constraint::Length(8), // timer
        Constraint::Length(1), // splits header
        Constraint::Min(0),    // splits
        Constraint::Length(1), // help
      ])
      .split(area);
    let top_layout = Layout::default()
      .direction(Direction::Horizontal)
      .constraints(vec![
        Constraint::Length(20), // title
        Constraint::Min(0),     // fps counter
      ])
      .split(layout[0]);

    // return a new vec with the top_layout rects and then rest of layout
    top_layout[..].iter().chain(layout[1..].iter()).copied().collect()
  }

  fn format_split&lt;'a&gt;(&amp;self, index: usize, start: Instant, previous: Instant, current: Instant) -&gt; Line&lt;'a&gt; {
    let split = self.format_duration(current - previous);
    let elapsed = self.format_duration(current - start);
    Line::from(vec![
      format!(&quot;#{:02} -- &quot;, index + 1).into(),
      Span::styled(split, Style::new().yellow()),
      &quot; -- &quot;.into(),
      Span::styled(elapsed, Style::new()),
    ])
  }

  fn format_duration(&amp;self, duration: Duration) -&gt; String {
    format!(&quot;{:02}:{:02}.{:03}&quot;, duration.as_secs() / 60, duration.as_secs() % 60, duration.subsec_millis())
  }
}</code></pre>
<p>It is worth thinking about what it takes to build your own custom widget by looking at
<a href="https://github.com/joshka/tui-big-text/blob/7f9e84968a9ba4db824a7ece7d186e58bb35999d/src/lib.rs#L83-L104">the source for the <code>BigText</code> widget</a>:</p>
<pre><code class="language-rust">#[derive(Debug, Builder, Clone, PartialEq, Eq, Hash)]
pub struct BigText&lt;'a&gt; {
    #[builder(setter(into))]
    lines: Vec&lt;Line&lt;'a&gt;&gt;,

    #[builder(default)]
    style: Style,
}

impl Widget for BigText&lt;'_&gt; {
    fn render(self, area: Rect, buf: &amp;mut Buffer) {
        let layout = layout(area);
        for (line, line_layout) in self.lines.iter().zip(layout) {
            for (g, cell) in line.styled_graphemes(self.style).zip(line_layout) {
                render_symbol(g, cell, buf);
            }
        }
    }
}</code></pre>
<p>To build a custom widget, you have to implement the <code>Widget</code> trait. We cover how to implement the
<code>Widget</code> trait for your own structs in <a href="tutorial/stopwatch-app/../../how-to/widgets/custom.html">a separate section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>In this section, we will cover various concepts associated with terminal user interfaces, such as:</p>
<ul>
<li>Rendering</li>
<li>Layout</li>
<li>Application patterns</li>
<li>Backends</li>
<li>Event handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>The world of UI development consists mainly of two dominant paradigms: retained mode and immediate
mode. Most traditional GUI libraries operate under the retained mode paradigm. However, <code>ratatui</code>
employs the immediate mode rendering approach. for TUI development.</p>
<p>This makes <code>ratatui</code> is different from GUI frameworks you might use, because it only updates when
you tell it to.</p>
<h2 id="what-is-immediate-mode-rendering"><a class="header" href="#what-is-immediate-mode-rendering">What is Immediate Mode Rendering?</a></h2>
<p>Immediate mode rendering is a UI paradigm where the UI is recreated every frame. Instead of creating
a fixed set of UI widgets and updating their state, you ‚Äúdraw‚Äù your UI from scratch in every frame
based on the current application state.</p>
<p>In a nutshell:</p>
<ul>
<li>Retained Mode: You set up your UI once, create widgets, and later modify their properties or
handle their events.</li>
<li>Immediate Mode: You redraw your UI every frame based on your application state. There‚Äôs no
permanent widget object in memory.</li>
</ul>
<p>In <code>ratatui</code>, every frame draws the UI anew.</p>
<pre><code class="language-rust">loop {
    terminal.draw(|f| {
        if state.condition {
            f.render_widget(SomeWidget::new(), layout);
        } else {
            f.render_widget(AnotherWidget::new(), layout);
        }
    })?;
}</code></pre>
<p><a href="https://caseymuratori.com/blog_0001">This article</a> and the accompanying YouTube video is worth your
time if you are new to the immediate mode rendering paradigm.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Z1qyvQsjK5Y?si=eiBHXiXIo3Z0u2zs"
 title="YouTube video player" frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
 allowfullscreen></iframe>
<p>This 4 minute talk about <code>IMGUI</code> is also tangentially relevant.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LSRJ1jZq90k?si=8NB5yiZ8IGS_QE_E"
 title="YouTube video player" frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
 allowfullscreen></iframe>
<h3 id="advantages-of-immediate-mode-rendering"><a class="header" href="#advantages-of-immediate-mode-rendering">Advantages of Immediate Mode Rendering</a></h3>
<ul>
<li><strong>Simplicity</strong>: Without a persistent widget state, your UI logic becomes a direct reflection of
your application state. You don‚Äôt have to sync them or worry about past widget states.</li>
<li><strong>Flexibility</strong>: You can change your UI layout or logic any time, as nothing is set in stone. Want
to hide a widget conditionally? Just don‚Äôt draw it based on some condition.</li>
</ul>
<h3 id="disadvantages-of-immediate-mode-rendering"><a class="header" href="#disadvantages-of-immediate-mode-rendering">Disadvantages of Immediate Mode Rendering</a></h3>
<ul>
<li>
<p><strong>Render loop management</strong>: In Immediate mode rendering, the onus of triggering rendering lies on
the programmer. Every visual update necessitates a call to <code>Backend.draw()</code>. Hence, if the
rendering thread is inadvertently blocked, the UI will not update until the thread resumes. The
<code>ratatui</code> library in particular only handles how widgets are rendered to a ‚ÄúBackend‚Äù (e.g.
<code>CrosstermBackend</code>). The Backend would in turn use an external crate (e.g. <code>crossterm</code>) to
actually draw to the terminal.</p>
</li>
<li>
<p><strong>Event loop orchestration</strong>: Along with managing ‚Äúthe render loop‚Äù, developers are also
responsible for handling ‚Äúthe event loop‚Äù. This involves deciding on a third-party library for the
job. <code>crossterm</code> is a popular crate to handle key inputs and you‚Äôll find plenty of examples in the
repository and online for how to use it. <code>crossterm</code> also supports a <code>async</code> event stream, if you
are interested in using <code>tokio</code>.</p>
</li>
<li>
<p><strong>Architecture design considerations</strong>: With <code>ratatui</code>, out of the box, there‚Äôs little to no help
in organizing large applications. Ultimately, the decision on structure and discipline rests with
the developer to be principled.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-ratatui-work-under-the-hood"><a class="header" href="#how-does-ratatui-work-under-the-hood">How does Ratatui work under the hood?</a></h1>
<p>You may have read in previous sections that Ratatui is a immediate mode rendering library. But what
does that really mean? And how is it implemented? In this section, we will discuss how Ratatui
renders a widget to the screen, starting with the <code>Terminal</code>‚Äôs <code>draw</code> method and ending with your
chosen backend library.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>To render an UI in Ratatui, your application calls the <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/terminal.rs#L325-L360"><code>Terminal::draw()</code></a> method. This method
takes a <a href="https://doc.rust-lang.org/stable/book/ch13-01-closures.html">closure</a> which accepts an instance of <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/terminal.rs#L566-L578"><code>Frame</code></a>. Inside the <code>draw</code> method, applications can
call <a href="https://github.com/ratatui-org/ratatui/blob/88ae3485c2c540b4ee630ab13e613e84efa7440a/src/terminal.rs#L596"><code>Frame::render_widget()</code></a> to render the state of a widget within the available renderable
area. We only discuss the <code>Frame::render_widget()</code> on this page but this discussion about rendering
applies equally to <a href="https://github.com/ratatui-org/ratatui/blob/88ae3485c2c540b4ee630ab13e613e84efa7440a/src/terminal.rs#L628"><code>Frame::render_stateful_widget()</code></a>.</p>
<p>As an example, here is the <code>terminal.draw()</code> call for a simple ‚Äúhello world‚Äù with Ratatui.</p>
<pre><code class="language-rust">terminal.draw(|frame| {
    frame.render_widget(Paragraph::new(&quot;Hello World!&quot;), frame.size());
});</code></pre>
<p>The closure gets an argument <code>frame</code> of type <code>&amp;mut Frame</code>.</p>
<p><code>frame.size()</code> returns a <code>Rect</code> that represents the total renderable area. <code>Frame</code> also holds a
reference to an intermediate buffer which it can render widgets to using the <code>render_widget()</code>
method. At the end of the <code>draw</code> method (after the closure returns), Ratatui persists the content of
the buffer to the terminal. Let‚Äôs walk through more specifics in the following sections.</p>
<h2 id="widget-trait"><a class="header" href="#widget-trait"><code>Widget</code> trait</a></h2>
<p>In Ratatui, the <code>frame.render_widget()</code> method calls a <code>Widget::render()</code> method on the type-erased
struct that implements the <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/widgets.rs#L107-L112"><code>Widget</code></a> trait.</p>
<pre><code class="language-rust">pub trait Widget {
    /// Draws the current state of the widget in the given buffer.
    fn render(self, area: Rect, buf: &amp;mut Buffer);
}</code></pre>
<p>Any struct (inside Ratatui or third party crates) can implement the <code>Widget</code> trait, making an
instance of that struct renderable to the terminal. The <code>Widget::render()</code> method is the only method
required to make a struct a renderable widget.</p>
<!--prettier-ignore-->
<p>In the <code>Paragraph</code> example above, <code>frame.render_widget()</code> calls the
<a href="https://github.com/ratatui-org/ratatui/blob/88ae3485c2c540b4ee630ab13e613e84efa7440a/src/widgets/paragraph.rs#L213-L214"><code>Widget::render()</code> method implemented for <code>Paragraph</code></a>. You can take a look at other widgets‚Äô
<code>render</code> methods for examples of how to draw content.</p>
<p>As a simple example, let‚Äôs take a look at the builtin <code>Clear</code> widget. The <code>Clear</code> widget resets the
style information of every cell in the buffer back to the defaults. Here is the full implementation
for the <code>Clear</code> widget:</p>
<pre><code class="language-rust">pub struct Clear;

impl Widget for Clear {
    fn render(self, area: Rect, buf: &amp;mut Buffer) {
        for x in area.left()..area.right() {
            for y in area.top()..area.bottom() {
                buf.get_mut(x, y).reset();
            }
        }
    }
}</code></pre>
<p>In the <code>Clear</code> widget example above, when the application calls the <code>Frame::render_widget()</code> method,
it will call the <code>Clear</code>‚Äôs <code>Widget::render()</code> method passing it the area (a <code>Rect</code> value) and a
mutable reference to the frame‚Äôs <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/buffer.rs#L149-L157"><code>Buffer</code></a>. You can see that the <code>render</code> loops through the entire
area and calls <code>buf.get_mut(x, y).reset()</code>. Here we only use one of the many methods on <code>Buffer</code>,
i.e. <code>get_mut(x, y)</code> which returns a <code>Cell</code> and <code>reset()</code> is a method on <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/buffer.rs#L15-L26"><code>Cell</code></a>.</p>
<h2 id="buffer"><a class="header" href="#buffer">Buffer</a></h2>
<p>A <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/buffer.rs#L149-L157"><code>Buffer</code></a> represents a rectangular area that covers the Terminal‚Äôs <a href="https://github.com/ratatui-org/ratatui/blob/88ae3485c2c540b4ee630ab13e613e84efa7440a/src/terminal.rs#L41-L65"><code>Viewport</code></a> which the
application can draw into by manipulating its contents. A <code>Buffer</code> contains a collection of
<a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/buffer.rs#L15-L26"><code>Cell</code></a>s to represent the rows and columns of the terminal‚Äôs display area. As we saw in the <code>Clear</code>
example above, widgets interact with these <code>Cell</code>s using <code>Buffer</code> methods.</p>
<p>Here‚Äôs a visual representation of a <code>Buffer</code> that is 12 <code>Cell</code>s wide and 4 <code>Cell</code>s tall.</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="632" height="304">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="632" height="304"></rect>
  <text x="66" y="12" >0</text>
  <text x="114" y="12" >1</text>
  <text x="162" y="12" >2</text>
  <text x="210" y="12" >3</text>
  <text x="258" y="12" >4</text>
  <text x="306" y="12" >5</text>
  <text x="354" y="12" >6</text>
  <text x="402" y="12" >7</text>
  <text x="450" y="12" >8</text>
  <text x="498" y="12" >9</text>
  <text x="538" y="12" >10</text>
  <text x="586" y="12" >11</text>
  <text x="66" y="44" >H</text>
  <text x="114" y="44" >e</text>
  <text x="162" y="44" >l</text>
  <text x="210" y="44" >l</text>
  <text x="258" y="44" >o</text>
  <text x="354" y="44" >W</text>
  <text x="402" y="44" >o</text>
  <text x="450" y="44" >r</text>
  <text x="498" y="44" >l</text>
  <text x="546" y="44" >d</text>
  <text x="594" y="44" >!</text>
  <text x="146" y="204" >symbol</text>
  <text x="330" y="204" >style</text>
  <text x="26" y="44" >0</text>
  <text x="26" y="76" >1</text>
  <text x="26" y="108" >2</text>
  <text x="26" y="140" >3</text>
  <text x="306" y="236" >fg</text>
  <text x="306" y="252" >bg</text>
  <text x="346" y="236" >Reset</text>
  <text x="346" y="252" >Reset</text>
  <text x="322" y="236" >:</text>
  <text x="322" y="252" >:</text>
  <g>
    <line x1="44" y1="24" x2="620" y2="24" class="solid"></line>
    <line x1="44" y1="24" x2="44" y2="152" class="solid"></line>
    <line x1="92" y1="24" x2="92" y2="152" class="solid"></line>
    <line x1="140" y1="24" x2="140" y2="152" class="solid"></line>
    <line x1="188" y1="24" x2="188" y2="128" class="solid"></line>
    <line x1="236" y1="24" x2="236" y2="128" class="solid"></line>
    <line x1="284" y1="24" x2="284" y2="128" class="solid"></line>
    <line x1="332" y1="24" x2="332" y2="128" class="solid"></line>
    <line x1="380" y1="24" x2="380" y2="152" class="solid"></line>
    <line x1="428" y1="24" x2="428" y2="152" class="solid"></line>
    <line x1="476" y1="24" x2="476" y2="152" class="solid"></line>
    <line x1="524" y1="24" x2="524" y2="152" class="solid"></line>
    <line x1="572" y1="24" x2="572" y2="152" class="solid"></line>
    <line x1="620" y1="24" x2="620" y2="152" class="solid"></line>
    <line x1="44" y1="56" x2="620" y2="56" class="solid"></line>
    <line x1="44" y1="88" x2="248" y2="88" class="solid"></line>
    <line x1="272" y1="88" x2="620" y2="88" class="solid"></line>
    <line x1="44" y1="120" x2="248" y2="120" class="solid"></line>
    <line x1="272" y1="120" x2="620" y2="120" class="solid"></line>
    <line x1="44" y1="152" x2="160" y2="152" class="solid"></line>
    <line x1="360" y1="152" x2="620" y2="152" class="solid"></line>
  </g>
  <g>
    <polygon points="256,76 260,64 264,76" class="filled"></polygon>
    <line x1="260" y1="76" x2="260" y2="136" class="solid"></line>
    <line x1="172" y1="136" x2="348" y2="136" class="solid"></line>
    <line x1="172" y1="136" x2="172" y2="184" class="solid"></line>
    <line x1="348" y1="136" x2="348" y2="184" class="solid"></line>
    <line x1="116" y1="184" x2="228" y2="184" class="solid"></line>
    <line x1="116" y1="184" x2="116" y2="280" class="solid"></line>
    <line x1="228" y1="184" x2="228" y2="280" class="solid"></line>
    <line x1="292" y1="184" x2="404" y2="184" class="solid"></line>
    <line x1="292" y1="184" x2="292" y2="280" class="solid"></line>
    <line x1="404" y1="184" x2="404" y2="280" class="solid"></line>
    <line x1="116" y1="280" x2="228" y2="280" class="solid"></line>
    <line x1="292" y1="280" x2="404" y2="280" class="solid"></line>
  </g>
  <g>
    <line x1="188" y1="144" x2="188" y2="152" class="solid"></line>
    <line x1="184" y1="152" x2="336" y2="152" class="solid"></line>
    <line x1="236" y1="144" x2="236" y2="152" class="solid"></line>
    <line x1="284" y1="144" x2="284" y2="152" class="solid"></line>
    <line x1="332" y1="144" x2="332" y2="152" class="solid"></line>
  </g>
  <g>
    <text x="162" y="236">‚Äú</text>
    <text x="170" y="236">o‚Äù</text>
  </g>
</svg></pre>
<p>In Ratatui, a <code>Cell</code> struct is the smallest renderable unit of code. Each <code>Cell</code> tracks symbol and
style information (foreground color, background color, modifiers etc). <code>Cell</code>s are similar to a
‚Äúpixel‚Äù in a graphical UI. Terminals generally render text so that each individual cell takes up
space approximately twice as high as it is wide. A <code>Cell</code> in Ratatui should usually contain 1 wide
string content.</p>
<p><code>Buffer</code> implements methods to write text, set styles on particular areas and manipulate individual
cells. For example,</p>
<ul>
<li><code>buf.get_mut(0, 0)</code> will return a <code>Cell</code> with the symbol and style information for row = 0 and col
= 0.</li>
<li><code>buf.set_string(0, 0, &quot;Hello World!&quot;, Style::default())</code> will render <code>hello world</code> into the
<code>Buffer</code> starting at row = 0 and col = 0 with the style set to default for all those cells.</li>
</ul>
<p>These methods allow any implementation of the <code>Widget</code> trait to write into different parts of the
<code>Buffer</code>.</p>
<p>Every time your application calls <code>terminal.draw(|frame| ...)</code>, Ratatui passes into the closure a
new instance of <a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/terminal.rs#L566-L578"><code>Frame</code></a> which contains a mutable reference to an instance of <code>Buffer</code>. Ratatui
widgets render to this intermediate buffer before any information is written to the terminal and any
content rendered to a <code>Buffer</code> is only stored in <code>Buffer</code> that is attached to the frame during the
<code>draw</code> call. This is in contrast to using a library like <code>crossterm</code> directly, where writing text to
terminal can occur immediately.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/rendering-under-the-hood.html#admonition-note"></a></p>
</div>
<div>
<p>ANSI Escape sequences for color and style that are stored in the cell‚Äôs string content are not
rendered as the style information is stored separately in the cell. If your text has ANSI styling
info, consider using the <a href="https://crates.io/crates/ansi-to-tui"><code>ansi-to-tui</code></a> crate to convert it
to a <code>Text</code> value before rendering. You can learn more about the text related Ratatui features and
displaying text <a href="concepts/./../how-to/render/display-text.html">here</a>.</p>
</div>
</div>
<h2 id="flush"><a class="header" href="#flush"><code>flush()</code></a></h2>
<p>After the closure provided to the <code>draw</code> method finishes, the <code>draw</code> method calls
<a href="https://github.com/ratatui-org/ratatui/blob/e5caf170c8c304b952cbff7499fd4da17ab154ea/src/terminal.rs#L253-L263"><code>Terminal::flush()</code></a>. <code>flush()</code> writes the content of the buffer to the terminal. Ratatui uses a
double buffer approach. It calculates a <code>diff</code> between the current buffer and the previous buffer to
figure out what content to write to the terminal screen efficiently. After <code>flush()</code>, Ratatui swaps
the buffers and the next time it calls <code>terminal.draw(|frame| ...)</code> it constructs <code>Frame</code> with the
other <code>Buffer</code>.</p>
<p>Because all widgets render to the same <code>Buffer</code> within a single <code>terminal.draw(|frame| ...)</code> call,
rendering of different widgets may overwrite the same <code>Cell</code> in the buffer. This means the order in
which widgets are rendered will affect the final UI.</p>
<p>For example, in this <code>draw</code> example below, <code>&quot;content1&quot;</code> will be overwritten by <code>&quot;content2&quot;</code> which
will be overwritten by <code>&quot;content3&quot;</code> in <code>Buffer</code>, and Ratatui will only ever write out <code>&quot;content3&quot;</code>
to the terminal:</p>
<pre><code class="language-rust">terminal.draw(|frame| {
    frame.render_widget(Paragraph::new(&quot;content1&quot;), frame.size());
    frame.render_widget(Paragraph::new(&quot;content2&quot;), frame.size());
    frame.render_widget(Paragraph::new(&quot;content3&quot;), frame.size());
})</code></pre>
<p>Before a new <code>Frame</code> is constructed, Ratatui wipes the current buffer clean. Because of this, when
an application calls <code>terminal.draw()</code> it must draw all the widgets it expects to be rendered to the
terminal, and not just a part of the frame. The diffing algorithm in Ratatui ensures efficient
writing to the terminal screen.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In summary, the application calls <code>terminal.draw(|frame| ...)</code>, and the terminal constructs a frame
that is passed to the closure provided by the application. The closure draws each widget to the
buffer by calling the <code>Frame::render_widget</code>, which in turn calls each widget‚Äôs render method.
Finally, Ratatui writes the contents of the buffer to the terminal.</p>
<pre class="mermaid">sequenceDiagram
    participant A as App
    participant C as Crossterm
    participant T as Terminal
    participant B as Buffer
    A -&gt;&gt;+ T: draw
    create participant F as frame
    T -&gt;&gt; F: new
    T -&gt;&gt;+ A: ui
    create participant W as widget
    A -&gt;&gt; W: new
    A -&gt;&gt;+ F: render_widget
    F -&gt;&gt;+ W: render
    opt
    W -&gt;&gt; B: get_cell
    W -&gt;&gt; B: set_string
    W -&gt;&gt; B: set_line
    W -&gt;&gt;- B: set_style
    end
    deactivate A
    T --&gt;&gt; C: flush()
    T --&gt;&gt; A: return
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p>The coordinate system in Ratatui runs left to right, top to bottom, with the origin <code>(0, 0)</code> in the
top left corner of the terminal. The x and y coordinates are represented by u16 values and are
generally listed in that order in most places.</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="192" height="160">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="192" height="160"></rect>
  <text x="178" y="12" >x</text>
  <text x="26" y="140" >y</text>
  <text x="2" y="12" >(0,0)</text>
  <text x="194" y="12" >(columns)</text>
  <text x="42" y="140" >(rows)</text>
  <g>
    <line x1="56" y1="8" x2="160" y2="8" class="solid"></line>
    <polygon points="160,4 168,8 160,12" class="filled"></polygon>
  </g>
  <g>
    <line x1="28" y1="32" x2="28" y2="100" class="solid"></line>
    <polygon points="24,100 32,100 28,112" class="filled"></polygon>
  </g>
</svg></pre>
<p>Layouts and widgets form the basis of the UI in Ratatui. Layouts dictate the structure of the
interface, dividing the screen into various sections using constraints, while widgets fill these
sections with content.</p>
<p>When rendering widgets to the screen, you first need to define the area where the widget will be
displayed. This area is represented by a rectangle with a specific height and width in the buffer.
You can specify this rectangle as an absolute position and size, or you can use the <a href="https://docs.rs/ratatui/latest/ratatui/layout/struct.Layout.html"><code>Layout</code></a>
struct to divide the terminal window dynamically based on constraints such as <code>Length</code>, <code>Min</code>,
<code>Max</code>, <code>Ratio</code>, <code>Percentage</code>.</p>
<p>The following example renders ‚ÄúHello world!‚Äù 10 times, by manually calculating the areas to render
within.</p>
<pre><code class="language-rust">let greeting = &quot;Hello world!&quot;;
for i in 0..10 {
    let area = Rect::new(0, i, frame.size().width, 1);
    frame.render_widget(Paragraph::new(&quot;Hello world!&quot;), area);
}</code></pre>
<h2 id="the-layout-struct"><a class="header" href="#the-layout-struct">The Layout struct</a></h2>
<p>A simple example of using the layout struct might look like this:</p>
<pre><code class="language-rust">use ratatui::prelude::*;

let layout = Layout::default()
    .direction(Direction::Vertical)
    .constraints(vec![
        Constraint::Percentage(50),
        Constraint::Percentage(50),
    ])
    .split(frame.size());</code></pre>
<p>In this example, we have indicated that we want to split the available space vertically into two
equal parts, allocating 50% of the screen height to each. The <a href="https://docs.rs/ratatui/latest/ratatui/layout/struct.Layout.html#method.split"><code>Layout::split</code></a> function takes the
total size of the terminal window as an argument, returned by the <a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Frame.html#method.size"><code>Frame::size()</code></a> method, and then
calculates the appropriate size and placement for each rectangle based on the specified constraints.</p>
<p>Once you have defined your layout (or a set of nested layouts), you can use one of the rectangle
areas derived from such layout to render your widget. This can be achieved by calling either the
<a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Frame.html#method.render_widget"><code>Frame::render_widget</code></a> or <a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Frame.html#method.render_stateful_widget"><code>frame::render_stateful_widget</code></a> methods:</p>
<pre><code class="language-rust">frame.render_widget(
    Paragraph::new(&quot;Top&quot;)
        .block(Block::new().borders(Borders::ALL)),
    layout[0]);
frame.render_widget(
    Paragraph::new(&quot;Bottom&quot;)
        .block(Block::new().borders(Borders::ALL)),
    layout[1]);</code></pre>
<p>This might look something like:</p>
<pre><code class="language-raw">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇTop                                ‚îÇ
‚îÇ                                   ‚îÇ
‚îÇ                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇBottom                             ‚îÇ
‚îÇ                                   ‚îÇ
‚îÇ                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>In this example, two <code>Paragraph</code> widgets are generated, named ‚ÄúTop‚Äù and ‚ÄúBottom.‚Äù These widgets are
then rendered in the first and second areas (<code>layout[0]</code> and <code>layout[1]</code>) of the split buffer,
respectively. It‚Äôs important to note that layouts return an indexed list of rectangles, defined by
their respective constraints. In this case, <code>layout[0]</code> refers to the top half of the screen, and
<code>layout[1]</code> refers to the bottom half.</p>
<h2 id="nesting-layouts"><a class="header" href="#nesting-layouts">Nesting Layouts</a></h2>
<p>One of the important concepts to understand is that layouts can be nested. This means you can define
another Layout within a rectangle of an outer layout. This nested layouts allow complex and flexible
UI designs to be built while still maintaining control over how your grid of widgets resize with the
terminal window.</p>
<p>Here‚Äôs how you might use nested layouts:</p>
<pre><code class="language-rust">let outer_layout = Layout::default()
    .direction(Direction::Vertical)
    .constraints(vec![
        Constraint::Percentage(50),
        Constraint::Percentage(50),
    ])
    .split(f.size());

let inner_layout = Layout::default()
    .direction(Direction::Horizontal)
    .constraints(vec![
        Constraint::Percentage(25),
        Constraint::Percentage(75),
    ])
    .split(outer_layout[1]);</code></pre>
<p>In this situation, the terminal window is initially split vertically into two equal parts by
<code>outer_layout</code>. Then, <code>inner_layout</code> splits the second rectangle of <code>outer_layout</code> horizontally,
creating two areas that are 25% and 75% of the width of the original rectangle, respectively.</p>
<p>Rendering some Paragraphs of text into the above layouts produces the following:</p>
<pre><code class="language-rust">frame.render_widget(
    Paragraph::new(&quot;outer 0&quot;)
        .block(Block::new().borders(Borders::ALL)),
    outer_layout[0]);
frame.render_widget(
    Paragraph::new(&quot;inner 0&quot;)
        .block(Block::new().borders(Borders::ALL)),
    inner_layout[0]);
frame.render_widget(
    Paragraph::new(&quot;inner 1&quot;)
        .block(Block::new().borders(Borders::ALL)),
    inner_layout[1]);</code></pre>
<pre><code class="language-raw">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇouter 0                            ‚îÇ
‚îÇ                                   ‚îÇ
‚îÇ                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇinner 0         ‚îÇ‚îÇinner 1          ‚îÇ
‚îÇ                ‚îÇ‚îÇ                 ‚îÇ
‚îÇ                ‚îÇ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>This enables you to divide the terminal window into multiple sections of varying sizes, giving you
the flexibility to create complex and adaptive graphical interfaces.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p><a href="https://docs.rs/ratatui/latest/ratatui/layout/enum.Constraint.html"><code>Constraint</code></a>s dictate the size and arrangement of components within layouts. The Ratatui framework
provides several constraint types for fine-tuning your user interface‚Äôs layout:</p>
<ul>
<li>
<p><code>Constraint::Length(u16)</code>: This constraint specifies a specific number of rows or columns that a
rectangle should take up. Note that this is determined by absolute size and is not responsive to
the overall terminal window size.</p>
</li>
<li>
<p><code>Constraint::Percentage(u16)</code>: This constraint offers a size relative to the size of the parent
layout or the terminal window itself. For instance, <code>Constraint::Percentage(50)</code> signifies that a
rectangle should take up half of its parent‚Äôs size.</p>
</li>
<li>
<p><code>Constraint::Ratio(u16, u16)</code>: Utilizing ratios offers an even finer granularity for splitting
your layout. For instance, <code>Constraint::Ratio(1, 3)</code> will allocate 1/3rd of the parent‚Äôs size to
this constraint.</p>
</li>
<li>
<p><code>Constraint::Min(u16)</code>: Immerses a minimum limit to the size of a component. If a <code>Min</code> constraint
is ensured with a <code>Percentage</code> or <code>Ratio</code>, the component will never shrink below the specified
minimum size.</p>
</li>
<li>
<p><code>Constraint::Max(u16)</code>: Limits the maximum size of a component. Similar to <code>Min</code>, if mixed with
<code>Percentage</code> or <code>Ratio</code>, the component will never exceed the specified maximum size.</p>
</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="concepts/layout/index.html#admonition-warning"></a></p>
</div>
<div>
<p>The <code>Ratio</code> and <code>Percentage</code> constraints are defined in terms of the parent‚Äôs size.</p>
<p>This may have unexpected side effects in situations where you expect a fixed and flexible sized
rects to be combined in the same layout. Consider using nested layouts or manually calculating the
sizes if necessary to create complex layouts.</p>
</div>
</div>
<p>Constraints can be mixed and matched within a layout to create dynamic and adjustable interfaces.
These constraints can be used when defining the layout for an application:</p>
<pre><code class="language-rust">let layout = Layout::default()
    .direction(Direction::Horizontal)
    .constraints([
        Constraint::Length(10),
        Constraint::Percentage(70),
        Constraint::Min(5),
    ]
    .into_iter())
    .split(frame.size());</code></pre>
<p>In this example, the initial <code>Length</code> constraint cause the first rectangle to have a width of 10
characters. The next rectangle will be 70% of the <strong>total width</strong>. The final rectangle will take up
the remaining space, but will never be smaller than 5 characters.</p>
<p>Note that the order in which you specify your constraints is the order in which they will apply to
the screen space.</p>
<p>By default, the split method allocates any remaining space in the area to the last area of the
layout. To avoid this, add an unused <code>Min(0)</code> constraint as the last constraint.</p>
<p>Ratatui uses a constraint solver algorithm called Casssowary in order to determine the right size
for the rects. In some cases, not every constraint will be possible to achieve, and the solver can
return an arbitrary solution that is close to fulfilling the constraints. The specific result is
non-deterministic when this occurs.</p>
<h2 id="other-layout-approaches"><a class="header" href="#other-layout-approaches">Other Layout approaches</a></h2>
<p>There are a few PoCs of using <a href="https://crates.io/crate/taffy">Taffy</a> for creating layouts that use
flexbox / grid algorithms (similar to CSS) to layout rects. This can work nicely, but is not built
in to Ratatui (yet). See
<a href="https://github.com/search?q=repo%3Aratatui-org%2Fratatui%20taffy&amp;type=code">taffy in ratatui</a> for
more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-patterns"><a class="header" href="#application-patterns">Application Patterns</a></h1>
<p>This page covers several patterns one can use for their application and acts as a top-level page for
the following articles where these patterns are gone into more in-depth.</p>
<ul>
<li><a href="concepts/application-patterns/./the-elm-architecture.html">The Elm Architecture</a></li>
<li><a href="concepts/application-patterns/./component-architecture.html">Component Architecture</a></li>
<li><a href="concepts/application-patterns/./flux-architecture.html">Flux Architecture</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-elm-architecture-tea-with-ratatui"><a class="header" href="#using-the-elm-architecture-tea-with-ratatui">Using The Elm Architecture (TEA) with <code>ratatui</code></a></h1>
<p>When building terminal user interfaces (TUI) with <code>ratatui</code>, it‚Äôs helpful to have a solid structure
for organizing your application. One proven architecture comes from the Elm language, known simply
as The Elm Architecture (TEA).</p>
<div id="admonition-attention" class="admonition admonish-warning">
<div class="admonition-title">
<p>Attention</p>
<p><a class="admonition-anchor-link" href="concepts/application-patterns/the-elm-architecture.html#admonition-attention"></a></p>
</div>
<div>
<p>If you are interested in a framework that uses <code>ratatui</code> that is based on The Elm Architecture,
you should check out <a href="https://github.com/veeso/tui-realm/">https://github.com/veeso/tui-realm/</a>.
The documentation on this page is for theoretical understanding and pedagogical purposes only.</p>
</div>
</div>
<p>In this section, we‚Äôll explore how to apply The Elm Architecture principles to <code>ratatui</code> TUI apps.</p>
<h2 id="the-elm-architecture-a-quick-overview"><a class="header" href="#the-elm-architecture-a-quick-overview">The Elm Architecture: A Quick Overview</a></h2>
<p>At its core, TEA is split into three main components:</p>
<ul>
<li><strong>Model</strong>: This is your application‚Äôs state. It contains all the data your application works with.</li>
<li><strong>Update</strong>: When there‚Äôs a change (like user input), the update function takes the current model
and the input, and produces a new model.</li>
<li><strong>View</strong>: This function is responsible for displaying your model to the user. In Elm, it produces
HTML. In our case, it‚Äôll produce terminal UI elements.</li>
</ul>
<pre class="mermaid">sequenceDiagram
participant User
participant TUI Application

User-&gt;&gt;TUI Application: Input/Event/Message
TUI Application-&gt;&gt;TUI Application: Update (based on Model and Message)
TUI Application-&gt;&gt;TUI Application: Render View (from Model)
TUI Application--&gt;&gt;User: Display UI
</pre>
<h2 id="applying-the-elm-architecture-to-ratatui"><a class="header" href="#applying-the-elm-architecture-to-ratatui">Applying The Elm Architecture to <code>ratatui</code></a></h2>
<p>Following TEA principles typically involves ensuring that you do the following things:</p>
<ol>
<li>Define Your Model</li>
<li>Handling Updates</li>
<li>Rendering the View</li>
</ol>
<h3 id="1-define-your-model"><a class="header" href="#1-define-your-model">1. Define Your Model</a></h3>
<p>In <code>ratatui</code>, you‚Äôll typically use a <code>struct</code> to represent your model:</p>
<pre><code class="language-rust">struct Model {
    //... your application's data goes here
}</code></pre>
<p>For a counter app, our model may look like this:</p>
<pre><code class="language-rust">struct Model {
  counter: i32,
  should_quit: bool,
}</code></pre>
<h3 id="2-handling-updates"><a class="header" href="#2-handling-updates">2. Handling Updates</a></h3>
<p>Updates in TEA are actions triggered by events, such as user inputs. The core idea is to map each of
these actions or events to a message. This can be achieved by creating an enum to keep track of
messages. Based on the received message, the current state of the model is used to determine the
next state.</p>
<p><strong>Defining a <code>Message</code> enum</strong></p>
<pre><code class="language-rust">enum Message {
    //... various inputs or actions that your app cares about
    // e.g., ButtonPressed, TextEntered, etc.
}</code></pre>
<p>For a counter app, our <code>Message</code> enum may look like this:</p>
<pre><code class="language-rust">enum Message {
  Increment,
  Decrement,
  Reset,
  Quit,
}</code></pre>
<p><strong><code>update()</code> function</strong></p>
<p>The update function is at the heart of this process. It takes the current model and a message, and
decides how the model should change in response to that message.</p>
<p>A key feature of TEA is immutability. Hence, the update function should avoid direct mutation of the
model. Instead, it should produce a new instance of the model reflecting the desired changes.</p>
<pre><code class="language-rust">fn update(model: &amp;Model, msg: Message) -&gt; Model {
    match msg {
        // Match each possible message and decide how the model should change
        // Return a new model reflecting those changes
    }
}</code></pre>
<p>In TEA, it‚Äôs crucial to maintain a clear separation between the data (model) and the logic that
alters it (update). This immutability principle ensures predictability and makes the application
easier to reason about.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/application-patterns/the-elm-architecture.html#admonition-note"></a></p>
</div>
<div>
<p>Hence, while immutability is emphasized in TEA, Rust developers can choose the most
suitable approach based on performance and their application‚Äôs needs.</p>
<p>For example, it would be perfectly valid to do the following:</p>
<pre><code class="language-rust">fn update(model: &amp;mut Model, msg: Message) {
    match msg {
        // Match each possible message and decide how the model should change
        // Modify existing mode reflecting those changes
    };
}</code></pre>
</div>
</div>
<p>In TEA, the <code>update()</code> function can not only modify the model based on the <code>Message</code>, but it can
also return another <code>Message</code>. This design can be particularly useful if you want to chain messages
or have an update lead to another update.</p>
<p>For example, this is what the <code>update()</code> function may look like for a counter app:</p>
<pre><code class="language-rust">fn update(model: &amp;mut Model, msg: Message) -&gt; Option&lt;Message&gt; {
  match msg {
    Message::Increment =&gt; {
      model.counter += 1;
      if model.counter &gt; 50 {
        return Some(Message::Reset);
      }
    },
    Message::Decrement =&gt; {
      model.counter -= 1;
      if model.counter &lt; -50 {
        return Some(Message::Reset);
      }
    },
    Message::Reset =&gt; {
      model.counter = 0;
    },
    Message::Quit =&gt; {
      model.should_quit = true;
    },
    _ =&gt; {},
  }
  None // Default return value if no specific message is to be returned
}</code></pre>
<div id="admonition-attention-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Attention</p>
<p><a class="admonition-anchor-link" href="concepts/application-patterns/the-elm-architecture.html#admonition-attention-1"></a></p>
</div>
<div>
<p>Remember that this design choice means that the <code>main</code> loop will need to handle the
returned message, calling <code>update()</code> again based on that returned message.</p>
</div>
</div>
<p>Returning a <code>Message</code> from the <code>update()</code> function allows a developer to reason about their code as
a ‚ÄúFinite State Machine‚Äù. Finite State Machines operate on defined states and transitions, where an
initial state and an event (in our case, a <code>Message</code>) lead to a subsequent state. This cascading
approach ensures that the system remains in a consistent and predictable state after handling a
series of interconnected events.</p>
<p>Here‚Äôs a state transition diagram of the counter example from above:</p>
<pre class="mermaid">stateDiagram-v2
    state Model {
        counter : counter = 0
        should_quit : should_quit = false
    }

    Model --&gt; Increment
    Model --&gt; Decrement
    Model --&gt; Reset
    Model --&gt; Quit

    Increment --&gt; Model: counter += 1
    Increment --&gt; Reset: if &gt; 50

    Decrement --&gt; Model: counter -= 1
    Decrement --&gt; Reset: if &lt; -50

    Reset --&gt; Model: counter = 0

    Quit --&gt; break: should_quit = true
</pre>
<p>While TEA doesn‚Äôt use the Finite State Machine terminology or strictly enforce that paradigm,
thinking of your application‚Äôs state as a state machine can allow developers to break down intricate
state transitions into smaller, more manageable steps. This can make designing the application‚Äôs
logic clearer and improve code maintainability.</p>
<h3 id="3-rendering-the-view"><a class="header" href="#3-rendering-the-view">3. Rendering the View</a></h3>
<p>The view function in the Elm Architecture is tasked with taking the current model and producing a
visual representation for the user. In the case of ratatui, it translates the model into terminal UI
elements. It‚Äôs essential that the view function remains a pure function: for a given state of the
model, it should always produce the same UI representation.</p>
<pre><code class="language-rust">fn view(model: &amp;Model) {
    //... use `ratatui` functions to draw your UI based on the model's state
}</code></pre>
<p>Every time the model is updated, the view function should be capable of reflecting those changes
accurately in the terminal UI.</p>
<p>In TEA, you are expected to ensure that your view function is side-effect free. The <code>view()</code>
function shouldn‚Äôt modify global state or perform any other actions. Its sole job is to map the
model to a visual representation.</p>
<p>For a given state of the model, the view function should always produce the same visual output. This
predictability makes your TUI application easier to reason about and debug.</p>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/application-patterns/the-elm-architecture.html#admonition-note-1"></a></p>
</div>
<div>
<p>With immediate mode rendering you may run into an issue: the <code>view</code> function is only aware of the
area available to draw in at render time.</p>
<p>This limitation is a recognized constraint of immediate mode GUIs. Overcoming it often involves
trade-offs. One common solution is to store the drawable size and reference it in the subsequent
frame, although this can introduce a frame delay in layout adjustments, leading to potential
flickering during the initial rendering when changes in screen size occur.</p>
<p>An alternative would be using the <code>Resize</code> event from <code>crossterm</code> and to clear the UI and force
redraw everything during that event.</p>
</div>
</div>
<p>In <code>ratatui</code>, there are
<a href="https://docs.rs/ratatui/latest/ratatui/widgets/trait.StatefulWidget.html"><code>StatefulWidget</code>s</a> which
require a mutable reference to state during render.</p>
<p>For this reason, you may choose to forego the <code>view</code> immutability principle. For example, if you
were interested in rendering a <code>List</code>, your <code>view</code> function may look like this:</p>
<pre><code class="language-rust">fn view(model: &amp;mut Model, f: &amp;mut Frame) {
  let items = app.items.items.iter().map(|element| ListItem::new(element)).collect();
  f.render_stateful_widget(List::new(items), f.size(), &amp;mut app.items.state);
}

fn main() {
  loop {
    ...
    terminal
      .draw(|f| {
        view(&amp;mut model, f);
      })?;
    ...
  }
}</code></pre>
<p>Another advantage of having access to the <code>Frame</code> in the <code>view()</code> function is that you have access
to setting the cursor position, which is useful for displaying text fields. For example, if you
wanted to draw an input field using <a href="https://github.com/sayanarijit/tui-input"><code>tui-input</code></a>, you
might have a <code>view</code> that looks like this:</p>
<pre><code class="language-rust">fn view(model: &amp;mut Model, f: &amp;mut Frame) {
  let area = f.size();
  let input = Paragraph::new(app.input.value());
  f.render_widget(input, area);
  if app.mode == Mode::Insert {
    f.set_cursor(
      (area.x + 1 + self.input.cursor() as u16).min(area.x + area.width - 2),
      area.y + 1
    )
  }
}</code></pre>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>When you put it all together, your main application loop might look something like:</p>
<ul>
<li>Listen for user input.</li>
<li>Map input to a <code>Message</code></li>
<li>Pass that message to the update function.</li>
<li>Draw the UI with the view function.</li>
</ul>
<p>This cycle repeats, ensuring your TUI is always up-to-date with user interactions.</p>
<p>As an illustrative example, here‚Äôs the <a href="concepts/application-patterns/../../tutorial/counter-app/single-function.html">Counter App</a>
refactored using TEA.</p>
<p>The notable difference from before is that we have an <code>Model</code> struct that captures the app state,
and a <code>Message</code> enum that captures the various actions your app can take.</p>
<pre><code class="language-rust">// cargo add anyhow ratatui crossterm
use anyhow::Result;
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, ratatui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

// MODEL
struct Model {
  counter: i32,
  should_quit: bool,
}

// MESSAGES
#[derive(PartialEq)]
enum Message {
  Increment,
  Decrement,
  Reset,
  Quit,
}

// UPDATE
fn update(model: &amp;mut Model, msg: Message) -&gt; Option&lt;Message&gt; {
  match msg {
    Message::Increment =&gt; {
      model.counter += 1;
      if model.counter &gt; 50 {
        return Some(Message::Reset);
      }
    },
    Message::Decrement =&gt; {
      model.counter -= 1;
      if model.counter &lt; -50 {
        return Some(Message::Reset);
      }
    },
    Message::Reset =&gt; model.counter = 0,
    Message::Quit =&gt; model.should_quit = true, // You can handle cleanup and exit here
  };
  None
}

// VIEW
fn view(model: &amp;mut Model, f: &amp;mut Frame) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, model.counter)), f.size());
}

// Convert Event to Message
// We don't need to pass in a `model` to this function in this example
// but you might need it as your project evolves
fn handle_event(_: &amp;Model) -&gt; Result&lt;Option&lt;Message&gt;&gt; {
  let message = if crossterm::event::poll(std::time::Duration::from_millis(250))? {
    if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
      match key.code {
        crossterm::event::KeyCode::Char('j') =&gt; Message::Increment,
        crossterm::event::KeyCode::Char('k') =&gt; Message::Decrement,
        crossterm::event::KeyCode::Char('q') =&gt; Message::Quit,
        _ =&gt; return Ok(None),
      }
    } else {
      return Ok(None);
    }
  } else {
    return Ok(None);
  };
  Ok(Some(message))
}

pub fn initialize_panic_handler() {
  let original_hook = std::panic::take_hook();
  std::panic::set_hook(Box::new(move |panic_info| {
    crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen).unwrap();
    crossterm::terminal::disable_raw_mode().unwrap();
    original_hook(panic_info);
  }));
}

fn main() -&gt; Result&lt;()&gt; {
  initialize_panic_handler();

  // Startup
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
  let mut model = Model { counter: 0, should_quit: false };

  loop {
    // Render the current view
    terminal.draw(|f| {
      view(&amp;mut model, f);
    })?;

    // Handle events and map to a Message
    let mut current_msg = handle_event(&amp;model)?;

    // Process updates as long as they return a non-None message
    while current_msg != None {
      current_msg = update(&amp;mut model, current_msg.unwrap());
    }

    // Exit loop if quit flag is set
    if model.should_quit {
      break;
    }
  }

  // Shutdown
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;
  Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-architecture"><a class="header" href="#component-architecture">Component Architecture</a></h1>
<p>If you are interested in a more object oriented approach to organizing TUIs, you can use a
<code>Component</code> based approach.</p>
<p>A couple of projects in the wild use this approach</p>
<ul>
<li><a href="https://github.com/TaKO8Ki/gobang">https://github.com/TaKO8Ki/gobang</a></li>
<li><a href="https://github.com/nomadiz/edma">https://github.com/nomadiz/edma</a></li>
</ul>
<p>We also have a <code>ratatui-async-template</code> that has an example of this <code>Component</code> based approach:</p>
<ul>
<li><a href="https://github.com/ratatui-org/ratatui-async-template">https://github.com/ratatui-org/ratatui-async-template</a></li>
</ul>
<p>We already covered <a href="concepts/application-patterns/./the-elm-architecture.html">TEA</a> in the previous section. The <code>Component</code>
architecture takes a slightly more object oriented trait based approach.</p>
<p>Each component encapsulates its own state, event handlers, and rendering logic.</p>
<ol>
<li>
<p>Component Initialization (<code>init</code>) - This is where a component can set up any initial state or
resources it needs. It‚Äôs a separate process from handling events or rendering.</p>
</li>
<li>
<p>Event Handling (<code>handle_events</code>, <code>handle_key_events</code>, <code>handle_mouse_events</code>) - Each component has
its own event handlers. This allows for a finer-grained approach to event handling, with each
component only dealing with the events it‚Äôs interested in. This contrasts with Elm‚Äôs single
update function that handles messages for the entire application.</p>
</li>
<li>
<p>State Update (<code>update</code>) - Components can have their own local state and can update it in response
to actions. This state is private to the component, which differs from Elm‚Äôs global model.</p>
</li>
<li>
<p>Rendering (<code>render</code>) - Each component defines its own rendering logic. It knows how to draw
itself, given a rendering context. This is similar to Elm‚Äôs view function but on a
component-by-component basis.</p>
</li>
</ol>
<p>Here‚Äôs an example of the <code>Component</code> trait implementation you might use:</p>
<pre><code class="language-rust">use anyhow::Result;
use crossterm::event::{KeyEvent, MouseEvent};
use ratatui::layout::Rect;

use crate::{action::Action, event::Event, terminal::Frame};

pub trait Component {
  fn init(&amp;mut self) -&gt; Result&lt;()&gt; {
    Ok(())
  }
  fn handle_events(&amp;mut self, event: Option&lt;Event&gt;) -&gt; Action {
    match event {
      Some(Event::Quit) =&gt; Action::Quit,
      Some(Event::Tick) =&gt; Action::Tick,
      Some(Event::Key(key_event)) =&gt; self.handle_key_events(key_event),
      Some(Event::Mouse(mouse_event)) =&gt; self.handle_mouse_events(mouse_event),
      Some(Event::Resize(x, y)) =&gt; Action::Resize(x, y),
      Some(_) =&gt; Action::Noop,
      None =&gt; Action::Noop,
    }
  }
  fn handle_key_events(&amp;mut self, key: KeyEvent) -&gt; Action {
    Action::Noop
  }
  fn handle_mouse_events(&amp;mut self, mouse: MouseEvent) -&gt; Action {
    Action::Noop
  }
  fn update(&amp;mut self, action: Action) -&gt; Action {
    Action::Noop
  }
  fn render(&amp;mut self, f: &amp;mut Frame&lt;'_&gt;, rect: Rect);
}</code></pre>
<p>One advantage of this approach is that it incentivizes co-locating the <code>handle_events</code>, <code>update</code> and
<code>render</code> functions on a component level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flux-architecture"><a class="header" href="#flux-architecture">Flux Architecture</a></h1>
<p><a href="https://facebookarchive.github.io/flux/docs/in-depth-overview/">Flux</a> is a design pattern
introduced by Facebook to address the challenges of building large scale web applications. Though
originally designed with web applications in mind, the Flux architecture can be applied to any
client-side project, including terminal applications. Here‚Äôs real world example of using the <code>Flux</code>
architecture with <code>ratatui</code>: <a href="https://github.com/Yengas/rust-chat-server/tree/main/tui">https://github.com/Yengas/rust-chat-server/tree/main/tui</a>.</p>
<h2 id="why-flux-for-ratatui"><a class="header" href="#why-flux-for-ratatui">Why <code>Flux</code> for <code>ratatui</code>?</a></h2>
<p>Terminal applications often have to deal with complex user interactions, multiple views, and dynamic
data sources. Keeping the application predictable and the logic decoupled is crucial. <code>Flux</code>, with
its unidirectional data flow, allows <code>ratatui</code> developers to have a structured way to handle user
input, process data, and update the views.</p>
<h2 id="flux-ratatui-overview"><a class="header" href="#flux-ratatui-overview"><code>Flux</code> <code>ratatui</code> Overview</a></h2>
<h3 id="dispatcher"><a class="header" href="#dispatcher">Dispatcher</a></h3>
<p>The dispatcher remains the central hub that manages all data flow in your application. Every action
in the application, whether it‚Äôs a user input or a response from a server, will be channeled through
the dispatcher. This ensures a unified way of handling data, and since the dispatcher has no logic
of its own, it simply ensures that all registered callbacks receive the action data.</p>
<pre><code class="language-rust">struct Dispatcher {
    store: Store,
}

impl Dispatcher {
    fn dispatch(&amp;mut self, action: Action) {
        self.store.update(action);
    }
}</code></pre>
<h3 id="stores"><a class="header" href="#stores">Stores</a></h3>
<p>Stores in Ratatui hold the application‚Äôs state and its logic. They could represent things like:</p>
<ul>
<li>A list of items in a menu.</li>
<li>The content of a text editor or viewer.</li>
<li>User configurations or preferences.</li>
</ul>
<p>Stores listen for actions dispatched from the Dispatcher. When a relevant action is dispatched, the
store updates its state and notifies any listening components (or views) that a change has occurred.</p>
<pre><code class="language-rust">struct Store {
    counter: i32,
}

impl Store {
    fn new() -&gt; Self {
        Self { counter: 0 }
    }

    fn update(&amp;mut self, action: Action) {
        match action {
            Action::Increment =&gt; self.counter += 1,
            Action::Decrement =&gt; self.counter -= 1,
        }
    }

    fn get_state(&amp;self) -&gt; i32 {
        self.counter
    }
}
</code></pre>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Actions represent any change or event in your application. For instance, when a user presses a key,
selects a menu item, or inputs text, an action is created. This action is dispatched and processed
by the relevant stores, leading to potential changes in application state.</p>
<pre><code class="language-rust">enum Action {
    Increment,
    Decrement,
}</code></pre>
<h3 id="views--widgets"><a class="header" href="#views--widgets">Views / Widgets</a></h3>
<p><code>ratatui</code>‚Äôs widgets display the application‚Äôs UI. They don‚Äôt hold or manage the application state,
but they display it. When a user interacts with a widget, it can create an action that gets
dispatched, which may lead to a change in a store, which in turn may lead to the widget being
updated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backends"><a class="header" href="#backends">Backends</a></h1>
<p>Ratatui interfaces with the terminal emulator through a backend. These libraries enable Ratatui via
the <a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Terminal.html"><code>Terminal</code></a> type to draw styled text to the screen, manipulate the cursor, and interrogate
properties of the terminal such as the console or window size. You application will generally also
use the backend directly to capture keyboard, mouse and window events, and enable raw mode and the
alternate screen.</p>
<p>Ratatui supports the following backends:</p>
<ul>
<li><a href="https://crates.io/crates/crossterm">Crossterm</a> via <a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.CrosstermBackend.html"><code>CrosstermBackend</code></a> and the <code>crossterm</code> (enabled by default).</li>
<li><a href="https://crates.io/crates/termion">Termion</a> via <a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.TermionBackend.html"><code>TermionBackend</code></a> and the <code>termion</code> feature.</li>
<li><a href="https://crates.io/crates/termwiz">Termwiz</a> via <a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.TermwizBackend.html"><code>TermwizBackend</code></a> and the <code>termion</code> feature.</li>
<li>A <a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.TestBackend.html"><code>TestBackend</code></a> which can be useful to unit test your application‚Äôs UI</li>
</ul>
<p>For information on how to choose a backend see: <a href="concepts/backends/./comparison.html">Comparison</a></p>
<p>Each backend supports <a href="concepts/backends/./raw-mode.html">Raw Mode</a> (which changes how the terminal handles input and
output processing), an <a href="concepts/backends/./alternate-screen.html">Alternate Screen</a> which allows it to render to a
separate buffer than your shell commands use, and <a href="concepts/backends/./mouse-capture.html">Mouse Capture</a>, which allows
your application to capture mouse events.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-of-backends"><a class="header" href="#comparison-of-backends">Comparison of Backends</a></h1>
<div id="admonition-tldr" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Tldr</p>
<p><a class="admonition-anchor-link" href="concepts/backends/comparison.html#admonition-tldr"></a></p>
</div>
<div>
<p>Choose <a href="https://crates.io/crates/crossterm">Crossterm</a> for most tasks.</p>
</div>
</div>
<p>Ratatui interfaces with the terminal emulator through its ‚Äúbackends‚Äù. These are powerful libraries
that grant <code>ratatui</code> the ability to capture keypresses, maneuver the cursor, style the text with
colors and other features. As of now, <code>ratatui</code> supports three backends:</p>
<ul>
<li><a href="https://crates.io/crates/crossterm">Crossterm</a></li>
<li><a href="https://crates.io/crates/termion">Termion</a></li>
<li><a href="https://crates.io/crates/termwiz">Termwiz</a></li>
</ul>
<p>Selecting a backend does influence your project‚Äôs structure, but the core functionalities remain
consistent across all options. Here‚Äôs a flowchart that can help you make your decision.</p>
<pre class="mermaid">graph TD;
    Q1[Is the TUI only for Wezterm users?]
    Q2[Is Windows compatibility important?]
    Q3[Are you familiar with Crossterm?]
    Q4[Are you familiar with Termion?]
    Crossterm
    Termwiz
    Termion

    Q1 --&gt;|Yes| Termwiz
    Q1 --&gt;|No| Q2
    Q2 --&gt;|Yes| Crossterm
    Q2 --&gt;|No| Q3
    Q3 --&gt;|Yes| Crossterm
    Q3 --&gt;|No| Q4
    Q4 --&gt;|Yes| Termion
    Q4 --&gt;|No| Crossterm
</pre>
<p>Though we try to make sure that all backends are fully-supported, the most commonly-used backend is
Crossterm. If you have no particular reason to use Termion or Termwiz, you will find it easiest to
learn Crossterm simply due to its popularity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-mode"><a class="header" href="#raw-mode">Raw Mode</a></h1>
<p>Raw mode is a mode where the terminal does not perform any processing or handling of the input and
output. This means that features such as echoing input characters, line buffering, and special
character processing (e.g., <code>CTRL-C</code> or <code>SIGINT</code>) are disabled. This is useful for applications that
want to have complete control over the terminal input and output, processing each keystroke
themselves.</p>
<p>For example, in raw mode, the terminal will not perform line buffering on the input, so the
application will receive each key press as it is typed, instead of waiting for the user to press
enter. This makes it suitable for real-time applications like text editors, terminal-based games,
and more.</p>
<p>Each backend handles raw mode differently, so the behavior may vary depending on the backend being
used. Be sure to consult the backend‚Äôs specific documentation for exact details on how it implements
raw mode.</p>
<ul>
<li><a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.CrosstermBackend.html"><code>CrosstermBackend</code></a></li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.TermionBackend.html"><code>TermionBackend</code></a></li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.TermwizBackend.html"><code>TermwizBackend</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternate-screen"><a class="header" href="#alternate-screen">Alternate Screen</a></h1>
<p>The alternate screen is a separate buffer that some terminals provide, distinct from the main
screen. When activated, the terminal will display the alternate screen, hiding the current content
of the main screen. Applications can write to this screen as if it were the regular terminal
display, but when the application exits, the terminal will switch back to the main screen, and the
contents of the alternate screen will be cleared. This is useful for applications like text editors
or terminal games that want to use the full terminal window without disrupting the command line or
other terminal content.</p>
<p>This creates a seamless transition between the application and the regular terminal session, as the
content displayed before launching the application will reappear after the application exits.</p>
<p>Take this ‚Äúhello world‚Äù program below. If we run it with and without the
<code>std::io::stderr().execute(EnterAlternateScreen)?</code> (and the corresponding <code>LeaveAlternateScreen</code>),
you can see how the program behaves differently.</p>
<pre><code class="language-rust"><span class="boring">use std::{
</span><span class="boring">  io::{stderr, Result},
</span><span class="boring">  thread::sleep,
</span><span class="boring">  time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crossterm::{
</span><span class="boring">  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
</span><span class="boring">  ExecutableCommand,
</span><span class="boring">};
</span><span class="boring">use ratatui::{prelude::*, widgets::*};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;()&gt; {
</span><span class="boring">  let should_enter_alternate_screen = std::env::args().nth(1).unwrap().parse::&lt;bool&gt;().unwrap();
</span><span class="boring">  if should_enter_alternate_screen {
</span>  stderr().execute(EnterAlternateScreen)?; // remove this line
<span class="boring">  }
</span>
  let mut terminal = Terminal::new(CrosstermBackend::new(stderr()))?;

  terminal.draw(|f| {
    f.render_widget(Paragraph::new(&quot;Hello World!&quot;), Rect::new(10, 20, 20, 1));
  })?;
  sleep(Duration::from_secs(2));

<span class="boring">  if should_enter_alternate_screen {
</span>  stderr().execute(LeaveAlternateScreen)?; // remove this line
<span class="boring">  }
</span><span class="boring">  Ok(())
</span><span class="boring">}</span></code></pre>
<!--
Output ./demo.gif

Set FontSize 18
Set Width 1200
Set Height 800
Set Theme "Catppuccin Mocha"

Type "# WITH Alternate Screen"
Enter
Type "# Cursor is here before program starts"
Enter

Sleep 5s

Type "cargo run -- true"
Enter
Sleep 5s

Type "# Cursor is here after program completes"
Enter

Sleep 5s

# Type "reset"
# Enter
# Sleep 2s

Type "# WITHOUT Alternate Screen"
Enter
Type "# Cursor is here before program starts"
Enter

Sleep 5s

Type "cargo run -- false"
Enter
Sleep 5s

Type "# Cursor is here after program completes"
Enter

Sleep 5s
-->
<p><img src="https://user-images.githubusercontent.com/1813121/272299743-f666980f-93b8-40d4-a979-1fce26d0f84a.gif" alt="" /></p>
<p>Try running this code on your own and experiment with <code>EnterAlternateScreen</code> and
<code>LeaveAlternateScreen</code>.</p>
<p>Note that not all terminal emulators support the alternate screen, and even those that do may handle
it differently. As a result, the behavior may vary depending on the backend being used. Always
consult the specific backend‚Äôs documentation to understand how it implements the alternate screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse-capture"><a class="header" href="#mouse-capture">Mouse Capture</a></h1>
<p>Mouse capture is a mode where the terminal captures mouse events such as clicks, scrolls, and
movement, and sends them to the application as special sequences or events. This enables the
application to handle and respond to mouse actions, providing a more interactive and graphical user
experience within the terminal. It‚Äôs particularly useful for applications like terminal-based games,
text editors, or other programs that require more direct interaction from the user.</p>
<p>Each backend handles mouse capture differently, with variations in the types of events that can be
captured and how they are represented. As such, the behavior may vary depending on the backend being
used, and developers should consult the specific backend‚Äôs documentation to understand how it
implements mouse capture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h1>
<p>There are many ways to handle events with the <code>ratatui</code> library. Mostly because <code>ratatui</code> does not
directly expose any event catching; the programmer will depend on the chosen backend‚Äôs library.</p>
<p>However, there are a few ways to think about event handling that may help you. While this is not an
exhaustive list, it covers a few of the more common implementations. But remember, the correct way,
is the one that works for you and your current application.</p>
<h2 id="centralized-event-handling"><a class="header" href="#centralized-event-handling">Centralized event handling</a></h2>
<p>This is the simplest way to handle events because it handles all of the events as they appear. It is
often simply a match on the results of <code>event::read()?</code> (in crossterm) on the different supported
keys. Pros: This has the advantage of requiring no message passing, and allows the programmer to
edit all of the possible keyboard events in one place.</p>
<p>Cons: However, this particular way of handling events simply does not scale well. Because <em>all</em>
events are handled in one place, you will be unable to split different groups of keybinds out into
separate locations.</p>
<h2 id="centralized-catching-message-passing"><a class="header" href="#centralized-catching-message-passing">Centralized catching, message passing</a></h2>
<p>This way of handling events involves polling for events in one place, and then sending
messages/calling sub functions with the event that was caught. Pros: This has a similar appeal to
the first method in its simplicity. With this paradigm, you can easily split extensive pattern
matching into sub functions that can go in separate files. This way is also the idea often used in
basic multi-threaded applications because message channels are used to pass multi-threaded safe
messages.</p>
<p>Cons: This method requires a main loop to be running to consistently poll for events in a
centralized place.</p>
<h2 id="distributed-event-loopssegmented-applications"><a class="header" href="#distributed-event-loopssegmented-applications">Distributed event loops/segmented applications</a></h2>
<p>In this style, control of the <code>Terminal</code> and the main loop to a sub-module. In this case, the entire
rendering and event handling responsibilities can be safely passed to the sub-module. In theory, an
application built like this doesn‚Äôt need a centralized event listener. Pros: There is no centralized
event loop that you need to update whenever a new sub-module is created.</p>
<p>Cons: However, if several sub-modules in your application have similar event handling loops, this
way could lead to a lot of duplicated code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to"><a class="header" href="#how-to">How To</a></h1>
<ul>
<li><a href="how-to/./layout/">Layout UIs</a>: Articles regarding how to layout your application‚Äôs User Interface
including widgets and nesting blocks</li>
<li><a href="how-to/./render/">Render Text</a>: Articles related to actually rendering test and widgets to the screen
including how to style and write to the buffer.</li>
<li><a href="how-to/./widgets/">Use Widgets</a>: Articles related to using individual widgets suchs as the paragraph,
block, and creating your own custom widget.</li>
<li><a href="how-to/./develop-apps/">Develop Applications</a>: Articles related to developing applications. E.g. how to
handle CLI arguments, tracing, configuration, panics, etc.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-1"><a class="header" href="#layout-1">Layout</a></h1>
<p>In this section we will cover layout basics and advanced techniques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-layouts"><a class="header" href="#dynamic-layouts">Dynamic layouts</a></h1>
<p>With real world applications, the content can often be dynamic. For example, a chat application may
need to resize the chat input area based on the number of incoming messages. To achieve this, you
can generate layouts dynamically:</p>
<pre><code class="language-rust">fn get_layout_based_on_messages(msg_count: usize, f: &amp;Frame) -&gt; Vec&lt;Rect&gt; {
    let msg_percentage = if msg_count &gt; 50 { 80 } else { 50 };

    Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage(msg_percentage),
            Constraint::Percentage(100 - msg_percentage),
        ])
        .split(f.size())
}</code></pre>
<p>You can even update the layout based on some user input or command:</p>
<pre><code class="language-rust">match action {
    Action::IncreaseSize =&gt; {
        current_percentage += 5;
        if current_percentage &gt; 95 {
            current_percentage = 95;
        }
    },
    Action::DecreaseSize =&gt; {
        current_percentage -= 5;
        if current_percentage &lt; 5 {
            current_percentage = 5;
        }
    },
    _ =&gt; {}
}

let chunks = Layout::default()
    .direction(Direction::Horizontal)
    .constraints([
        Constraint::Percentage(current_percentage),
        Constraint::Percentage(100 - current_percentage),
    ])
    .split(f.size());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="center-a-rect"><a class="header" href="#center-a-rect">Center a <code>Rect</code></a></h1>
<p>You can use a <code>Vertical</code> layout followed by a <code>Horizontal</code> layout to get a centered <code>Rect</code>.</p>
<pre><code class="language-rust">/// # Usage
///
/// ```rust
/// let rect = centered_rect(f.size(), 50, 50);
/// ```
fn centered_rect(r: Rect, percent_x: u16, percent_y: u16) -&gt; Rect {
  let popup_layout = Layout::default()
    .direction(Direction::Vertical)
    .constraints([
      Constraint::Percentage((100 - percent_y) / 2),
      Constraint::Percentage(percent_y),
      Constraint::Percentage((100 - percent_y) / 2),
    ])
    .split(r);

  Layout::default()
    .direction(Direction::Horizontal)
    .constraints([
      Constraint::Percentage((100 - percent_x) / 2),
      Constraint::Percentage(percent_x),
      Constraint::Percentage((100 - percent_x) / 2),
    ])
    .split(popup_layout[1])[1]
}</code></pre>
<p>Then you can use it to draw any widget like this:</p>
<pre><code class="language-rust">terminal.draw(|f| {
    f.render_widget(Block::default().borders(Borders::all()).title(&quot;Main&quot;), centered_rect(f.size(), 35, 35));
})?;</code></pre>
<pre><code class="language-text">





                    ‚îåMain‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò










</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collapse-borders-in-a-layout"><a class="header" href="#collapse-borders-in-a-layout">Collapse borders in a layout</a></h1>
<p>A common layout for applications is to split up the screen into panes, with borders around each
pane. Often this leads to making UIs that look disconnected. E.g., the following layout:</p>
<p><img src="https://user-images.githubusercontent.com/381361/279935613-01b5083d-dcca-4ee3-981c-38fe700bbfe4.png" alt="problem" /></p>
<p>Created by the following code:</p>
<pre><code class="language-rust">fn ui(frame: &amp;mut Frame) {
    // create a layout that splits the screen into 2 equal columns and the right column
    // into 2 equal rows
    let layout = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
        .split(frame.size());
    let sub_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
        .split(layout[1]);

    frame.render_widget(
        Block::new().borders(Borders::ALL).title(&quot;Left Block&quot;),
        layout[0],
    );

    frame.render_widget(
        Block::new().borders(Borders::ALL).title(&quot;Top Right Block&quot;),
        sub_layout[0],
    );

    frame.render_widget(
        Block::new()
            .borders(Borders::ALL)
            .title(&quot;Bottom Right Block&quot;),
        sub_layout[1],
    );
}</code></pre>
<p>We can do better though, by collapsing borders. E.g.:</p>
<p><img src="https://user-images.githubusercontent.com/381361/279935618-3b411b45-1a02-4f4c-af9f-7b68f766023e.png" alt="solution" /></p>
<p>The first thing we need to do is work out which borders to collapse. Because in the layout above we
want to connect the bottom right block to the middle vertical border, we‚Äôre going to need this to be
rendered by the top left and bottom left blocks rather than the right block.</p>
<p>We need to use the symbols module to acheive this so we add this to the imports:</p>
<pre><code class="language-rust">use ratatui::{prelude::*, symbols, widgets::*};</code></pre>
<p>Our first change is to the left block where we remove the right border:</p>
<pre><code class="language-rust">    frame.render_widget(
        Block::new()
            // don't render the right border because it will be rendered by the right block
            .border_set(symbols::border::PLAIN)
            .borders(Borders::TOP | Borders::LEFT | Borders::BOTTOM)
            .title(&quot;Left Block&quot;),
        layout[0],
    );</code></pre>
<p>Next, we see that the top left corner of the top right block joins with the top right corner of the
left block, so we need to replace that with a T shape. We also see omit the bottom border as that
will be rendered by the bottom right block. We use a custom <a href="https://docs.rs/ratatui/latest/ratatui/symbols/border/struct.Set.html"><code>symbols::border::Set</code></a> to acheive
this.</p>
<pre><code class="language-rust">    // top right block must render the top left border to join with the left block
    let top_right_border_set = symbols::border::Set {
        top_left: symbols::line::NORMAL.horizontal_down,
        ..symbols::border::PLAIN
    };
    frame.render_widget(
        Block::new()
            .border_set(top_right_border_set)
            // don't render the bottom border because it will be rendered by the bottom block
            .borders(Borders::TOP | Borders::LEFT | Borders::RIGHT)
            .title(&quot;Top Right Block&quot;),
        sub_layout[0],
    );</code></pre>
<p>In the bottom right block, we see that the top right corner joins the left block‚Äôs right border and
so we need to rend this with a horizontal T shape pointing to the right. We need to do the same for
the top right corner and the bottom left corner.</p>
<pre><code class="language-rust">    // bottom right block must render:
    // - top left border to join with the left block and top right block
    // - top right border to join with the top right block
    // - bottom left border to join with the left block
    let collapsed_top_and_left_border_set = symbols::border::Set {
        top_left: symbols::line::NORMAL.vertical_right,
        top_right: symbols::line::NORMAL.vertical_left,
        bottom_left: symbols::line::NORMAL.horizontal_up,
        ..symbols::border::PLAIN
    };
    frame.render_widget(
        Block::new()
            .border_set(collapsed_top_and_left_border_set)
            .borders(Borders::ALL)
            .title(&quot;Bottom Right Block&quot;),
        sub_layout[1],
    );</code></pre>
<p>If we left it here, then we‚Äôd be mostly fine, but in small areas we‚Äôd notice that the 50/50 split no
longer looks right. This is due to the fact that by default we round up when splitting an odd number
of rows or columns in 2 (e.g. 5 rows =&gt; 2.5/2.5 =&gt; 3/2). This is fine normally, but when we collapse
borders between blocks, the first block has one extra row (or columns) already as it does not have
the collapsed block. We can easily work around this issue by allocating a small amount of extra
space to the last layout item (e.g. by using 49/51 or 33/33/34).</p>
<pre><code class="language-rust">    let layout = Layout::default()
        .direction(Direction::Horizontal)
        // use a 49/51 split instead of 50/50 to ensure that any extra space is on the right
        // side of the screen. This is important because the right side of the screen is
        // where the borders are collapsed.
        .constraints([Constraint::Percentage(49), Constraint::Percentage(51)])
        .split(frame.size());
    let sub_layout = Layout::default()
        .direction(Direction::Vertical)
        // use a 49/51 split to ensure that any extra space is on the bottom
        .constraints([Constraint::Percentage(49), Constraint::Percentage(51)])
        .split(layout[1]);</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="how-to/layout/collapse-borders.html#admonition-note"></a></p>
</div>
<div>
<p>If this sounds too complex, we‚Äôre looking for some help to make this easier in
<a href="https://github.com/ratatui-org/ratatui/issues/605">https://github.com/ratatui-org/ratatui/issues/605</a>.</p>
</div>
</div>
<p>The full code for this example is available at
<a href="https://github.com/ratatui-org/ratatui-book/code/how-to-collapse-borders">https://github.com/ratatui-org/ratatui-book/code/how-to-collapse-borders</a></p>
<details><summary>Full ui() function</summary>
<pre><code class="language-rust">fn ui(frame: &amp;mut Frame) {
    // create a layout that splits the screen into 2 equal columns and the right column
    // into 2 equal rows

    let layout = Layout::default()
        .direction(Direction::Horizontal)
        // use a 49/51 split instead of 50/50 to ensure that any extra space is on the right
        // side of the screen. This is important because the right side of the screen is
        // where the borders are collapsed.
        .constraints([Constraint::Percentage(49), Constraint::Percentage(51)])
        .split(frame.size());
    let sub_layout = Layout::default()
        .direction(Direction::Vertical)
        // use a 49/51 split to ensure that any extra space is on the bottom
        .constraints([Constraint::Percentage(49), Constraint::Percentage(51)])
        .split(layout[1]);

    frame.render_widget(
        Block::new()
            // don't render the right border because it will be rendered by the right block
            .border_set(symbols::border::PLAIN)
            .borders(Borders::TOP | Borders::LEFT | Borders::BOTTOM)
            .title(&quot;Left Block&quot;),
        layout[0],
    );

    // top right block must render the top left border to join with the left block
    let top_right_border_set = symbols::border::Set {
        top_left: symbols::line::NORMAL.horizontal_down,
        ..symbols::border::PLAIN
    };
    frame.render_widget(
        Block::new()
            .border_set(top_right_border_set)
            // don't render the bottom border because it will be rendered by the bottom block
            .borders(Borders::TOP | Borders::LEFT | Borders::RIGHT)
            .title(&quot;Top Right Block&quot;),
        sub_layout[0],
    );

    // bottom right block must render:
    // - top left border to join with the left block and top right block
    // - top right border to join with the top right block
    // - bottom left border to join with the left block
    let collapsed_top_and_left_border_set = symbols::border::Set {
        top_left: symbols::line::NORMAL.vertical_right,
        top_right: symbols::line::NORMAL.vertical_left,
        bottom_left: symbols::line::NORMAL.horizontal_up,
        ..symbols::border::PLAIN
    };
    frame.render_widget(
        Block::new()
            .border_set(collapsed_top_and_left_border_set)
            .borders(Borders::ALL)
            .title(&quot;Bottom Right Block&quot;),
        sub_layout[1],
    );
}</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-text"><a class="header" href="#render-text">Render Text</a></h1>
<ul>
<li><a href="how-to/render/./display-text.html">Display Text</a></li>
<li><a href="how-to/render/./style-text.html">Style Text</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-text"><a class="header" href="#displaying-text">Displaying Text</a></h1>
<p>This page covers how text displaying works. It will cover <code>Span</code>, <code>Line</code>, and <code>Text</code>, and how these
can be created, styled, displayed, altered, and such.</p>
<h2 id="span"><a class="header" href="#span"><code>Span</code></a></h2>
<p>A <code>Span</code> is a styled segment of text. You can think of it as a substring with its own unique style.
It is the most basic unit of displaying text in <code>ratatui</code>.</p>
<p>The examples below assume the following imports:</p>
<pre><code class="language-rust">use ratatui::{prelude::*, widgets::*};
pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;</code></pre>
<p>A <code>Span</code> consists of ‚Äúcontent‚Äù and a ‚Äústyle‚Äù for the content. And a <code>Span</code> can be created in a few
different ways.</p>
<ol>
<li>
<p>using <code>Span::raw</code>:</p>
<pre><code class="language-rust">fn ui(_app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let span = Span::raw(&quot;This is text that is not styled&quot;);
    // --snip--
}</code></pre>
</li>
<li>
<p>using <code>Span::styled</code>:</p>
<pre><code class="language-rust">fn ui(_app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let span = Span::styled(&quot;This is text that will be yellow&quot;, Style::default().fg(Color::Yellow));
    // --snip--
}</code></pre>
</li>
<li>
<p>using the <code>Stylize</code> trait:</p>
<pre><code class="language-rust">fn ui(_app: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let span = &quot;This is text that will be yellow&quot;.yellow();
    // --snip--
}</code></pre>
</li>
</ol>
<p>A <code>Span</code> is the basic building block for any styled text, and can be used anywhere text is
displayed.</p>
<h2 id="line"><a class="header" href="#line"><code>Line</code></a></h2>
<p>The next building block that we are going to talk about is a <code>Line</code>. A <code>Line</code> represents a cluster
of graphemes, where each unit in the cluster can have its own style. You can think of an instance of
the <code>Line</code> struct as essentially a collection of <code>Span</code> objects, i.e. <code>Vec&lt;Span&gt;</code>.</p>
<p>Since each <code>Line</code> struct consists of multiple <code>Span</code> objects, this allows for varied styling in a
row of words, phrases or sentences.</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let line = Line::from(vec![
        &quot;hello&quot;.red(),
        &quot; &quot;.into(),
        &quot;world&quot;.red().bold()
    ]);
    // --snip--
}</code></pre>
<p>A <code>Line</code> can be constructed directly from content, where the content is <code>Into&lt;Cow&lt;'a, &amp;str&gt;&gt;</code>.</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let line = Line::from(&quot;hello world&quot;);
    // --snip--
}</code></pre>
<p>You can even style a full line directly:</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let line = Line::styled(&quot;hello world&quot;, Style::default().fg(Color::Yellow));
    // --snip--
}</code></pre>
<p>And you can use the <code>Stylize</code> trait on the line directly by using <code>into()</code>:</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let line: Line = &quot;hello world&quot;.yellow().into();
    // --snip--
}</code></pre>
<h2 id="text"><a class="header" href="#text"><code>Text</code></a></h2>
<p><code>Text</code> is the final building block of outputting text. A <code>Text</code> object represents a collection of
<code>Line</code>s.</p>
<p>Most widgets accept content that can be converted to <code>Text</code>.</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let span1 = &quot;hello&quot;.red();
    let span2 = &quot;world&quot;.red().bold();
    let line = Line::from(vec![span1, &quot; &quot;.into(), span2]);
    let text = Text::from(line);
    f.render_widget(Paragraph::new(text).block(Block::default().borders(Borders::ALL)), f.size());
}</code></pre>
<p>Here‚Äôs an HTML representation of what you‚Äôd get in the terminal:</p>
<div style="border: 1px solid black; display: inline-block; padding: 5px;">
    <span style="color: red;">hello</span>
    <span style="color: red; font-weight: bold;">world</span>
</div>
<p>Often code like the one above can be simplified:</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let line: Line = vec![
        &quot;hello&quot;.red(),
        &quot; &quot;.into(),
        &quot;world&quot;.red().bold()
    ].into();
    f.render_widget(Paragraph::new(line).block(Block::default().borders(Borders::ALL)), f.size());
}</code></pre>
<p>This is because in this case, Rust is able to infer the types and convert them into appropriately.</p>
<p><code>Text</code> instances can be created using the <code>raw</code> or <code>styled</code> constructors too.</p>
<p>Something that you might find yourself doing pretty often for a <code>Paragraph</code> is wanting to have
multiple lines styled differently. This is one way you might go about that:</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
    let text = vec![
        &quot;hello world 1&quot;.into(),
        &quot;hello world 2&quot;.blue().into(),
        Line::from(vec![&quot;hello&quot;.green(), &quot; &quot;.into(), &quot;world&quot;.green().bold(), &quot;3&quot;.into()]),
    ]
    .into();
    f.render_widget(Paragraph::new(text).block(Block::default().borders(Borders::ALL)), f.size());
}</code></pre>
<div style="border: 1px solid black; display: inline-block; padding: 5px;">
    <p>
        hello world 1
    </p>
    <p>
        <span style="color: blue;">hello world 2</span>
    </p>
    <p>
        <span style="color: green;">hello</span>
        <span style="color: green; font-weight: bold;">world</span> 3
    </p>
</div>
<p>We will talk more about styling in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-text"><a class="header" href="#styling-text">Styling Text</a></h1>
<p>Styling enhances user experience by adding colors, emphasis, and other visual aids. In <code>ratatui</code>,
the primary tool for this is the <code>ratatui::style::Style</code> struct.</p>
<p><code>ratatui::style::Style</code> provides a set of methods to apply styling attributes to your text. These
styles can then be applied to various text structures like <code>Text</code>, <code>Span</code>, and <code>Line</code> (as well as
other non text structures).</p>
<p>Common styling attributes include:</p>
<ul>
<li>Foreground and Background Colors (<code>fg</code> and <code>bg</code>)</li>
<li>Modifiers (like <code>bold</code>, <code>italic</code>, and <code>underline</code>)</li>
</ul>
<ol>
<li>
<p>Basic Color Styling</p>
<p>Setting the foreground (text color) and background:</p>
<pre><code class="language-rust">let styled_text = Span::styled(
    &quot;Hello, Ratatui!&quot;,
    Style::default().fg(Color::Red).bg(Color::Yellow)
);</code></pre>
</li>
<li>
<p>Using <code>Modifiers</code></p>
<p>Making text bold or italic:</p>
<pre><code class="language-rust">let bold_text = Span::styled(
    &quot;This is bold&quot;,
    Style::default().modifier(Modifier::BOLD)
);

let italic_text = Span::styled(
    &quot;This is italic&quot;,
    Style::default().modifier(Modifier::ITALIC)
);</code></pre>
<p>You can also combine multiple modifiers:</p>
<pre><code class="language-rust">let bold_italic_text = Span::styled(
    &quot;This is bold and italic&quot;,
    Style::default().modifier(Modifier::BOLD | Modifier::ITALIC)
);</code></pre>
</li>
<li>
<p>Styling within a Line</p>
<p>You can mix and match different styled spans within a single line:</p>
<pre><code class="language-rust">let mixed_line = Line::from(vec![
    Span::styled(&quot;This is mixed&quot;, Style::default().fg(Color::Green)),
    Span::styled(&quot;styling&quot;, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
    Span::from(&quot;!&quot;),
]);</code></pre>
</li>
</ol>
<p>This is what it would look like if you rendered a <code>Paragraph</code> with different styles for each line:</p>
<pre><code class="language-rust">fn ui(_: &amp;App, f: &amp;mut Frame&lt;'_&gt;) {
  let styled_text = Span::styled(&quot;Hello, Ratatui!&quot;, Style::default().fg(Color::Red).bg(Color::Yellow));
  let bold_text = Span::styled(&quot;This is bold&quot;, Style::default().add_modifier(Modifier::BOLD));
  let italic_text = Span::styled(&quot;This is italic&quot;, Style::default().add_modifier(Modifier::ITALIC));
  let bold_italic_text =
    Span::styled(&quot;This is bold and italic&quot;, Style::default().add_modifier(Modifier::BOLD | Modifier::ITALIC));
  let mixed_line = vec![
    Span::styled(&quot;This is mixed&quot;, Style::default().fg(Color::Green)),
    Span::styled(&quot;styling&quot;, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
    Span::from(&quot;!&quot;),
  ];
  let text: Vec&lt;Line&lt;'_&gt;&gt; =
    vec![styled_text.into(), bold_text.into(), italic_text.into(), bold_italic_text.into(), mixed_line.into()];
  f.render_widget(Paragraph::new(text).block(Block::default().borders(Borders::ALL)), f.size());
}</code></pre>
<p>Here‚Äôs the HTML representation of the above styling:</p>
<div style="border: 1px solid black; display: inline-block; padding: 5px;">
    <p style="color: red; background-color: yellow;">Hello, Ratatui!</p>
    <p style="font-weight: bold;">This is bold</p>
    <p style="font-style: italic;">This is italic</p>
    <p style="font-weight: bold; font-style: italic;">This is bold and italic</p>
    <p>
        <span style="color: green;">This is mixed</span>
        <span style="color: red; font-weight: bold;">styling</span>
        !
    </p>
</div>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="how-to/render/style-text.html#admonition-tip"></a></p>
</div>
<div>
<p>You can also create instances of <code>Color</code> from a string:</p>
<pre><code class="language-rust">use std::str::FromStr;

let color: Color = Color::from_str(&quot;blue&quot;).unwrap();
assert_eq!(color, Color::Blue);

let color: Color = Color::from_str(&quot;#FF0000&quot;).unwrap();
assert_eq!(color, Color::Rgb(255, 0, 0));

let color: Color = Color::from_str(&quot;10&quot;).unwrap();
assert_eq!(color, Color::Indexed(10));</code></pre>
</div>
</div>
<p>You can read more about the
<a href="https://docs.rs/ratatui/latest/ratatui/style/enum.Color.html"><code>Color</code> enum</a> and
<a href="https://docs.rs/ratatui/latest/ratatui/style/struct.Modifier.html"><code>Modifier</code></a> in the reference
documentation online.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-widgets"><a class="header" href="#use-widgets">Use Widgets</a></h1>
<ul>
<li><a href="how-to/widgets/./paragraph.html">Paragraph</a></li>
<li><a href="how-to/widgets/./block.html">Block</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paragraph"><a class="header" href="#paragraph">Paragraph</a></h1>
<p>The <code>Paragraph</code> widget provides a way to display text content in your terminal user interface. It
allows not only plain text display but also handling text wrapping, alignment, and styling. This
page will delve deeper into the functionality of the <code>Paragraph</code> widget.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-rust">let p = Paragraph::new(&quot;Hello, World!&quot;);
f.render_widget(p, chunks[0]);</code></pre>
<h2 id="styling-and-borders"><a class="header" href="#styling-and-borders">Styling and Borders</a></h2>
<p>You can also apply styles to your text and wrap it with a border:</p>
<pre><code class="language-rust">let p = Paragraph::new(&quot;Hello, World!&quot;)
    .style(Style::default().fg(Color::Yellow))
    .block(
        Block::default()
            .borders(Borders::ALL)
            .title(&quot;Title&quot;)
            .border_type(BorderType::Rounded)
    );
f.render_widget(p, chunks[0]);</code></pre>
<h2 id="wrapping"><a class="header" href="#wrapping">Wrapping</a></h2>
<p>The <code>Paragraph</code> widget will wrap the content based on the available width in its containing block.
You can also control the wrapping behavior using the <code>wrap</code> method:</p>
<pre><code class="language-rust">let p = Paragraph::new(&quot;A very long text that might not fit the container...&quot;)
    .wrap(Wrap { trim: true });
f.render_widget(p, chunks[0]);</code></pre>
<p>Setting <code>trim</code> to <code>true</code> will ensure that trailing whitespaces at the end of each line are removed.</p>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<pre><code class="language-rust">let p = Paragraph::new(&quot;Centered Text&quot;)
    .alignment(Alignment::Center);
f.render_widget(p, chunks[0]);</code></pre>
<h2 id="styled-text"><a class="header" href="#styled-text">Styled Text</a></h2>
<p><code>Paragraph</code> supports rich text through <code>Span</code>, <code>Line</code>, and <code>Text</code>:</p>
<pre><code class="language-rust">let lines = vec![];
lines.push(Line::from(vec![
    Span::styled(&quot;Hello &quot;, Style::default().fg(Color::Yellow)),
    Span::styled(&quot;World&quot;, Style::default().fg(Color::Blue).bg(Color::White)),
]));
lines.push(Line::from(vec![
    Span::styled(&quot;Goodbye &quot;, Style::default().fg(Color::Yellow)),
    Span::styled(&quot;World&quot;, Style::default().fg(Color::Blue).bg(Color::White)),
]));
let text = Text::from(lines);
let p = Paragraph::new(text);
f.render_widget(p, chunks[0]);</code></pre>
<h2 id="scrolling"><a class="header" href="#scrolling">Scrolling</a></h2>
<p>For long content, <code>Paragraph</code> supports scrolling:</p>
<pre><code class="language-rust">let mut p = Paragraph::new(&quot;Lorem ipsum ...&quot;)
    .scroll((1, 0));  // Scroll down by one line
f.render_widget(p, chunks[0]);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<p>The <code>Block</code> widget serves as a foundational building block for structuring and framing other widgets.
It‚Äôs essentially a container that can have borders, a title, and other styling elements to enhance
the aesthetics and structure of your terminal interface. This page provides an in-depth exploration
of the <code>Block</code> widget.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>The simplest use case for a <code>Block</code> is to create a container with borders:</p>
<pre><code class="language-rust">let b = Block::default()
    .borders(Borders::ALL);
f.render_widget(b, chunks[0]);</code></pre>
<h2 id="titles"><a class="header" href="#titles">Titles</a></h2>
<p>A common use case for Block is to give a section of the UI a title or a label:</p>
<pre><code class="language-rust">let b = Block::default()
    .title(&quot;Header&quot;)
    .borders(Borders::ALL);
f.render_widget(b, chunks[0]);</code></pre>
<p>You can also use the <code>Title</code> struct for better positioning or multiple titles.</p>
<pre><code class="language-rust">let b = Block::default()
    .title(block::Title::from(&quot;Left Title&quot;).alignment(Alignment::Left))
    .title(block::Title::from(&quot;Middle Title&quot;).alignment(Alignment::Center))
    .title(block::Title::from(&quot;Right Title&quot;).alignment(Alignment::Right))
    .borders(Borders::ALL);
f.render_widget(b, chunks[0]);</code></pre>
<h2 id="border-style"><a class="header" href="#border-style">Border style</a></h2>
<p>Block provides flexibility in both the borders style and type:</p>
<pre><code class="language-rust">let b = Block::default()
    .title(&quot;Styled Header&quot;)
    .border_style(Style::default().fg(Color::Magenta))
    .border_type(BorderType::Rounded)
    .borders(Borders::ALL);
f.render_widget(b, chunks[0]);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-widget"><a class="header" href="#create-a-custom-widget">Create a custom widget</a></h1>
<p>While Ratatui offers a rich set of pre-built widgets, there may be scenarios where you require a
unique component tailored to specific needs. In such cases, creating a custom widget becomes
invaluable. This page will guide you through the process of designing and implementing custom
widgets.</p>
<h2 id="widget-trait-1"><a class="header" href="#widget-trait-1"><code>Widget</code> trait</a></h2>
<p>At the core of creating a custom widget is the <code>Widget</code> trait. Any struct that implements this trait
can be rendered using the framework‚Äôs drawing capabilities.</p>
<pre><code class="language-rust">
pub struct MyWidget {
    // Custom widget properties
    content: String,
}

impl Widget for MyWidget {
    fn render(self, area: Rect, buf: &amp;mut Buffer) {
        // Rendering logic goes here
    }
}</code></pre>
<p>The <code>render</code> method must draw into the current <code>Buffer</code>. There are a number of methods implemented
on <code>Buffer</code>.</p>
<pre><code class="language-rust">impl Widget for MyWidget {
    fn render(self, area: Rect, buf: &amp;mut Buffer) {
        buf.set_string(area.left(), area.top(), &amp;self.content, Style::default().fg(Color::Green));
    }
}</code></pre>
<p>For a given state, the <code>Widget</code> trait implements how that struct should be rendered.</p>
<pre><code class="language-rust">pub struct Button {
    label: String,
    is_pressed: bool,
    style: Style,
    pressed_style: Option&lt;Style&gt;,
}

impl Widget for Button {
    fn render(self, area: Rect, buf: &amp;mut Buffer) {
        let style = if self.is_pressed {
            self.pressed_style.unwrap_or_else(|| Style::default().fg(Color::Blue))
        } else {
            self.style
        };
        buf.set_string(area.left(), area.top(), &amp;self.label, style);
    }
}</code></pre>
<p>Ratatui also has a <code>StatefulWidget</code>. This is essentially a widget that can ‚Äúremember‚Äù information
between two draw calls. This is essential when you have interactive UI components, like lists, where
you might need to remember which item was selected or how much the user has scrolled.</p>
<p>Here‚Äôs a breakdown of the trait:</p>
<pre><code class="language-rust">pub trait StatefulWidget {
    type State;
    fn render(self, area: Rect, buf: &amp;mut Buffer, state: &amp;mut Self::State);
}</code></pre>
<ul>
<li><code>type State</code>: This represents the type of the state that this widget will use to remember details
between draw calls.</li>
<li><code>fn render(...)</code>: This method is responsible for drawing the widget on the terminal. Notably, it
also receives a mutable reference to the state, allowing you to read from and modify the state as
needed.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-applications"><a class="header" href="#develop-applications">Develop Applications</a></h1>
<p>This section covers topics on how to develop applications:</p>
<ul>
<li><a href="how-to/develop-apps/./cli-arguments.html">CLI arguments</a></li>
<li><a href="how-to/develop-apps/./config-directories.html">Configuration Directories</a></li>
<li><a href="how-to/develop-apps/./tracing.html">Tracing</a></li>
<li><a href="how-to/develop-apps/./abstract-terminal-and-event-handler.html">Arrange your App Code</a></li>
<li><a href="how-to/develop-apps/./setup-panic-hooks.html">Setup Panic Hooks</a></li>
<li><a href="how-to/develop-apps/./better-panic-hooks.html">Better Panic Hooks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handle-cli-arguments"><a class="header" href="#handle-cli-arguments">Handle CLI arguments</a></h1>
<p>Command Line Interface (CLI) tools often require input parameters to dictate their behavior.
<a href="https://docs.rs/clap/latest/clap/"><code>clap</code></a> (Command Line Argument Parser) is a feature-rich Rust
library that facilitates the parsing of these arguments in an intuitive manner.</p>
<h2 id="defining-command-line-arguments"><a class="header" href="#defining-command-line-arguments">Defining Command Line Arguments</a></h2>
<p>In this snippet, we utilize the <code>clap</code> library to define an <code>Args</code> struct, which will be used to
capture and structure the arguments passed to the application:</p>
<pre><code class="language-rust">use clap::Parser;

#[derive(Parser, Debug)]
#[command(version = version(), about = &quot;ratatui template with crossterm and tokio&quot;)]
struct Args {
  /// App tick rate
  #[arg(short, long, default_value_t = 1000)]
  app_tick_rate: u64,
}</code></pre>
<p>Here, the Args struct defines one command-line arguments:</p>
<ul>
<li><code>app_tick_rate</code>: Dictates the application‚Äôs tick rate.</li>
</ul>
<p>This is supplied with default values, ensuring that even if the user doesn‚Äôt provide this argument,
the application can still proceed with its defaults.</p>
<h2 id="displaying-version-information"><a class="header" href="#displaying-version-information">Displaying Version Information</a></h2>
<p>One common convention in CLIs is the ability to display version information. Here, the version
information is presented as a combination of various parameters, including the Git commit hash.</p>
<p>The <code>version()</code> function, as seen in the snippet, fetches this information:</p>
<pre><code class="language-rust">pub fn version() -&gt; String {
  let author = clap::crate_authors!();

  let commit_hash = env!(&quot;RATATUI_TEMPLATE_GIT_INFO&quot;);

  // let current_exe_path = PathBuf::from(clap::crate_name!()).display().to_string();
  let config_dir_path = get_config_dir().unwrap().display().to_string();
  let data_dir_path = get_data_dir().unwrap().display().to_string();

  format!(
    &quot;\
{commit_hash}

Authors: {author}

Config directory: {config_dir_path}
Data directory: {data_dir_path}&quot;
  )
}</code></pre>
<p>This function uses the <code>get_data_dir()</code> and <code>get_config_dir()</code> from
<a href="how-to/develop-apps/./config-directories.html">the section on XDG directories</a>.</p>
<p>This function also makes use of an environment variable <code>RATATUI_TEMPLATE_GIT_INFO</code> to derive the
Git commit hash. The variable can be populated during the build process by <code>build.rs</code>:</p>
<pre><code class="language-rust">  println!(&quot;cargo:rustc-env=RATATUI_TEMPLATE_GIT_INFO={}&quot;, git_describe);</code></pre>
<p>By invoking the CLI tool with the <code>--version</code> flag, users will be presented with the version
details, including the authors, commit hash, and the paths to the configuration and data
directories.</p>
<p><img src="https://user-images.githubusercontent.com/1813121/252721469-4d5ec38b-e868-46b4-b7b7-1c2c8bc496ac.png" alt="‚Äìversion output" /></p>
<p>The <code>version()</code> function‚Äôs output is just an example. You can easily adjust its content by amending
the string template code above.</p>
<p>Here‚Äôs the full <code>build.rs</code> for your reference:</p>
<pre><code class="language-rust">fn main() {
  let git_output = std::process::Command::new(&quot;git&quot;).args([&quot;rev-parse&quot;, &quot;--git-dir&quot;]).output().ok();
  let git_dir = git_output.as_ref().and_then(|output| {
    std::str::from_utf8(&amp;output.stdout).ok().and_then(|s| s.strip_suffix('\n').or_else(|| s.strip_suffix(&quot;\r\n&quot;)))
  });

  // Tell cargo to rebuild if the head or any relevant refs change.
  if let Some(git_dir) = git_dir {
    let git_path = std::path::Path::new(git_dir);
    let refs_path = git_path.join(&quot;refs&quot;);
    if git_path.join(&quot;HEAD&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/HEAD&quot;, git_dir);
    }
    if git_path.join(&quot;packed-refs&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/packed-refs&quot;, git_dir);
    }
    if refs_path.join(&quot;heads&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/refs/heads&quot;, git_dir);
    }
    if refs_path.join(&quot;tags&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/refs/tags&quot;, git_dir);
    }
  }

  let git_output =
    std::process::Command::new(&quot;git&quot;).args([&quot;describe&quot;, &quot;--always&quot;, &quot;--tags&quot;, &quot;--long&quot;, &quot;--dirty&quot;]).output().ok();
  let git_info = git_output.as_ref().and_then(|output| std::str::from_utf8(&amp;output.stdout).ok().map(str::trim));
  let cargo_pkg_version = env!(&quot;CARGO_PKG_VERSION&quot;);

  // Default git_describe to cargo_pkg_version
  let mut git_describe = String::from(cargo_pkg_version);

  if let Some(git_info) = git_info {
    // If the `git_info` contains `CARGO_PKG_VERSION`, we simply use `git_info` as it is.
    // Otherwise, prepend `CARGO_PKG_VERSION` to `git_info`.
    if git_info.contains(cargo_pkg_version) {
      // Remove the 'g' before the commit sha
      let git_info = &amp;git_info.replace('g', &quot;&quot;);
      git_describe = git_info.to_string();
    } else {
      git_describe = format!(&quot;v{}-{}&quot;, cargo_pkg_version, git_info);
    }
  }

  println!(&quot;cargo:rustc-env=RATATUI_TEMPLATE_GIT_INFO={}&quot;, git_describe);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handle-xdg-directories"><a class="header" href="#handle-xdg-directories">Handle XDG Directories</a></h1>
<p>Handling files and directories correctly in a command-line or TUI application ensures that the
application fits seamlessly into a user‚Äôs workflow and adheres to established conventions. One of
the key conventions on Linux-based systems is the XDG Base Directory Specification.</p>
<h2 id="why-the-xdg-base-directory-specification"><a class="header" href="#why-the-xdg-base-directory-specification">Why the XDG Base Directory Specification?</a></h2>
<p>The XDG Base Directory Specification is a set of standards that define where user files should
reside, ensuring a cleaner home directory and a more organized storage convention. By adhering to
this standard, your application will store files in the expected directories, making it more
predictable and user-friendly.</p>
<h2 id="using-directories-rs-for-path-resolution"><a class="header" href="#using-directories-rs-for-path-resolution">Using <code>directories-rs</code> for Path Resolution</a></h2>
<p>The <code>directories-rs</code> library offers a Rust-friendly interface to locate common directories (like
config and data directories) based on established conventions, including the XDG Base Directory
Specification.</p>
<ol>
<li>
<p>Add <code>directories-rs</code> to your <code>Cargo.toml</code></p>
<pre><code class="language-shell">cargo add directories
</code></pre>
</li>
<li>
<p>Use the <code>ProjectDirs</code> struct to retrieve paths based on your project‚Äôs domain and project name
and create helper functions for getting the <code>data_dir</code> and <code>config_dir</code>.</p>
</li>
<li>
<p>Allow users to specify custom locations using environment variables. This flexibility can be
crucial for users with unique directory structures or for testing.</p>
</li>
<li>
<p>A good practice is to notify the user about the location of the configuration and data
directories. An example from the template is to print out these locations when the user invokes
the <code>--version</code> command-line argument. See the section on
<a href="how-to/develop-apps/./cli-arguments.html">Command line argument parsing</a></p>
</li>
</ol>
<p>Here‚Äôs an example <code>get_data_dir()</code> and <code>get_config_dir()</code> functions for your reference:</p>
<pre><code class="language-rust">use std::path::PathBuf;

use anyhow::{anyhow, Context, Result};
use directories::ProjectDirs;

pub fn get_data_dir() -&gt; Result&lt;PathBuf&gt; {
  let directory = if let Ok(s) = std::env::var(&quot;RATATUI_TEMPLATE_DATA&quot;) {
    PathBuf::from(s)
  } else if let Some(proj_dirs) = ProjectDirs::from(&quot;com&quot;, &quot;kdheepak&quot;, &quot;ratatui-template&quot;) {
    proj_dirs.data_local_dir().to_path_buf()
  } else {
    return Err(anyhow!(&quot;Unable to find data directory for ratatui-template&quot;));
  };
  Ok(directory)
}

pub fn get_config_dir() -&gt; Result&lt;PathBuf&gt; {
  let directory = if let Ok(s) = std::env::var(&quot;RATATUI_TEMPLATE_CONFIG&quot;) {
    PathBuf::from(s)
  } else if let Some(proj_dirs) = ProjectDirs::from(&quot;com&quot;, &quot;kdheepak&quot;, &quot;ratatui-template&quot;) {
    proj_dirs.config_local_dir().to_path_buf()
  } else {
    return Err(anyhow!(&quot;Unable to find config directory for ratatui-template&quot;));
  };
  Ok(directory)
}</code></pre>
<p>You will want to replace <code>kdheepak</code> with your user name or company name (or any unique name for that
matter); and <code>ratatui-app</code> with the name of your CLI.</p>
<p>I own <a href="https://kdheepak.com">https://kdheepak.com</a> so I tend to use <code>com.kdheepak.ratatui-app</code> for my project directories.
That way it is unlikely that any other program will mess with the configuration files for the app I
plan on distributing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-logging-with-tracing"><a class="header" href="#setup-logging-with-tracing">Setup Logging with tracing</a></h1>
<p>You‚Äôll need to install <code>tracing</code> and a few related dependencies:</p>
<pre><code class="language-shell">cargo add tracing-error tracing
cargo add tracing-subscriber --features env-filter
cargo add directories lazy_static color-eyre # (optional)
</code></pre>
<p>You can paste the following in any module in your project.</p>
<pre><code class="language-rust">use std::path::PathBuf;

use color_eyre::eyre::{Context, Result};
use directories::ProjectDirs;
use lazy_static::lazy_static;
use tracing::error;
use tracing_error::ErrorLayer;
use tracing_subscriber::{self, layer::SubscriberExt, util::SubscriberInitExt, Layer};

lazy_static! {
  pub static ref PROJECT_NAME: String = env!(&quot;CARGO_CRATE_NAME&quot;).to_uppercase().to_string();
  pub static ref DATA_FOLDER: Option&lt;PathBuf&gt; =
    std::env::var(format!(&quot;{}_DATA&quot;, PROJECT_NAME.clone())).ok().map(PathBuf::from);
  pub static ref LOG_ENV: String = format!(&quot;{}_LOGLEVEL&quot;, PROJECT_NAME.clone());
  pub static ref LOG_FILE: String = format!(&quot;{}.log&quot;, env!(&quot;CARGO_PKG_NAME&quot;));
}

fn project_directory() -&gt; Option&lt;ProjectDirs&gt; {
  ProjectDirs::from(&quot;com&quot;, &quot;kdheepak&quot;, env!(&quot;CARGO_PKG_NAME&quot;))
}

pub fn get_data_dir() -&gt; PathBuf {
  let directory = if let Some(s) = DATA_FOLDER.clone() {
    s
  } else if let Some(proj_dirs) = project_directory() {
    proj_dirs.data_local_dir().to_path_buf()
  } else {
    PathBuf::from(&quot;.&quot;).join(&quot;.data&quot;)
  };
  directory
}

pub fn initialize_logging() -&gt; Result&lt;()&gt; {
  let directory = get_data_dir();
  std::fs::create_dir_all(directory.clone())?;
  let log_path = directory.join(LOG_FILE.clone());
  let log_file = std::fs::File::create(log_path)?;
  std::env::set_var(
    &quot;RUST_LOG&quot;,
    std::env::var(&quot;RUST_LOG&quot;)
      .or_else(|_| std::env::var(LOG_ENV.clone()))
      .unwrap_or_else(|_| format!(&quot;{}=info&quot;, env!(&quot;CARGO_CRATE_NAME&quot;))),
  );
  let file_subscriber = tracing_subscriber::fmt::layer()
    .with_file(true)
    .with_line_number(true)
    .with_writer(log_file)
    .with_target(false)
    .with_ansi(false)
    .with_filter(tracing_subscriber::filter::EnvFilter::from_default_env());
  tracing_subscriber::registry().with(file_subscriber).with(ErrorLayer::default()).init();
  Ok(())
}

/// Similar to the `std::dbg!` macro, but generates `tracing` events rather
/// than printing to stdout.
///
/// By default, the verbosity level for the generated events is `DEBUG`, but
/// this can be customized.
#[macro_export]
macro_rules! trace_dbg {
    (target: $target:expr, level: $level:expr, $ex:expr) =&gt; {{
        match $ex {
            value =&gt; {
                tracing::event!(target: $target, $level, ?value, stringify!($ex));
                value
            }
        }
    }};
    (level: $level:expr, $ex:expr) =&gt; {
        trace_dbg!(target: module_path!(), level: $level, $ex)
    };
    (target: $target:expr, $ex:expr) =&gt; {
        trace_dbg!(target: $target, level: tracing::Level::DEBUG, $ex)
    };
    ($ex:expr) =&gt; {
        trace_dbg!(level: tracing::Level::DEBUG, $ex)
    };
}
</code></pre>
<p>Call <code>initialize_logging()?</code> in your <code>main()</code> function.</p>
<p>The log level is decided by the <code>${YOUR_CRATE_NAME}_LOGLEVEL</code> environment variable (default =
<code>log::LevelFilter::Info</code>).</p>
<p>Additionally, the location of the log files would be decided by your environment variables. See
<a href="how-to/develop-apps/./config-directories.html">the section on XDG directories</a> for more information.</p>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="how-to/develop-apps/tracing.html#admonition-tip"></a></p>
</div>
<div>
<p>Check out <a href="https://github.com/gin66/tui-logger"><code>tui-logger</code></a> for setting up a
tui logger widget with tracing.</p>
</div>
</div>
<p><img src="https://user-images.githubusercontent.com/1813121/254093932-46d8c6fd-c572-4675-bcaf-45a36eed51ff.png" alt="Top half is a terminal with the TUI showing a Vertical split with tui-logger widget. Bottom half is a terminal showing the output of running tail -f on the log file." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-tui-with-terminal-and-eventhandler-using-tokio-and-crossterm"><a class="header" href="#async-tui-with-terminal-and-eventhandler-using-tokio-and-crossterm">Async <code>Tui</code> with <code>Terminal</code> and <code>EventHandler</code> using <code>tokio</code> and <code>crossterm</code></a></h1>
<p>If you want a <code>Tui</code> struct:</p>
<ul>
<li>with <code>Deref</code> and <code>DerefMut</code></li>
<li>with <code>Terminal</code> enter raw mode, exit raw mode etc</li>
<li>with signal handling support</li>
<li>with key event <code>EventHandler</code> with <code>crossterm</code>‚Äôs <code>EventStream</code> support</li>
<li>and with <code>tokio</code>‚Äôs <code>select!</code></li>
</ul>
<p>then you can copy-paste this <code>Tui</code> struct into your project.</p>
<p>Add the following dependencies:</p>
<pre><code class="language-bash">cargo add ratatui crossterm tokio tokio_util futures # required
cargo add color_eyre serde serde_derive # optional
</code></pre>
<p>You‚Äôll need to copy the code to a <code>./src/tui.rs</code>:</p>
<pre><code class="language-rust">use std::{
  ops::{Deref, DerefMut},
  time::Duration,
};

use color_eyre::eyre::Result;
use crossterm::{
  cursor,
  event::{
    DisableBracketedPaste, DisableMouseCapture, EnableBracketedPaste, EnableMouseCapture, Event as CrosstermEvent,
    KeyEvent, KeyEventKind, MouseEvent,
  },
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use futures::{FutureExt, StreamExt};
use ratatui::backend::CrosstermBackend as Backend;
use serde::{Deserialize, Serialize};
use tokio::{
  sync::mpsc::{self, UnboundedReceiver, UnboundedSender},
  task::JoinHandle,
};
use tokio_util::sync::CancellationToken;

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, Backend&lt;std::io::Stderr&gt;&gt;;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Event {
  Init,
  Quit,
  Error,
  Closed,
  Tick,
  Render,
  FocusGained,
  FocusLost,
  Paste(String),
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

pub struct Tui {
  pub terminal: ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;,
  pub task: JoinHandle&lt;()&gt;,
  pub cancellation_token: CancellationToken,
  pub event_rx: UnboundedReceiver&lt;Event&gt;,
  pub event_tx: UnboundedSender&lt;Event&gt;,
  pub frame_rate: f64,
  pub tick_rate: f64,
  pub mouse: bool,
  pub paste: bool,
}

impl Tui {
  pub fn new() -&gt; Result&lt;Self&gt; {
    let tick_rate = 4.0;
    let frame_rate = 60.0;
    let terminal = ratatui::Terminal::new(Backend::new(std::io::stderr()))?;
    let (event_tx, event_rx) = mpsc::unbounded_channel();
    let cancellation_token = CancellationToken::new();
    let task = tokio::spawn(async {});
    let mouse = false;
    let paste = false;
    Ok(Self { terminal, task, cancellation_token, event_rx, event_tx, frame_rate, tick_rate, mouse, paste })
  }

  pub fn tick_rate(mut self, tick_rate: f64) -&gt; Self {
    self.tick_rate = tick_rate;
    self
  }

  pub fn frame_rate(mut self, frame_rate: f64) -&gt; Self {
    self.frame_rate = frame_rate;
    self
  }

  pub fn mouse(mut self, mouse: bool) -&gt; Self {
    self.mouse = mouse;
    self
  }

  pub fn paste(mut self, paste: bool) -&gt; Self {
    self.paste = paste;
    self
  }

  pub fn start(&amp;mut self) {
    let tick_delay = std::time::Duration::from_secs_f64(1.0 / self.tick_rate);
    let render_delay = std::time::Duration::from_secs_f64(1.0 / self.frame_rate);
    self.cancel();
    self.cancellation_token = CancellationToken::new();
    let _cancellation_token = self.cancellation_token.clone();
    let _event_tx = self.event_tx.clone();
    self.task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut tick_interval = tokio::time::interval(tick_delay);
      let mut render_interval = tokio::time::interval(render_delay);
      _event_tx.send(Event::Init).unwrap();
      loop {
        let tick_delay = tick_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          _ = _cancellation_token.cancelled() =&gt; {
            break;
          }
          maybe_event = crossterm_event =&gt; {
            match maybe_event {
              Some(Ok(evt)) =&gt; {
                match evt {
                  CrosstermEvent::Key(key) =&gt; {
                    if key.kind == KeyEventKind::Press {
                      _event_tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  CrosstermEvent::Mouse(mouse) =&gt; {
                    _event_tx.send(Event::Mouse(mouse)).unwrap();
                  },
                  CrosstermEvent::Resize(x, y) =&gt; {
                    _event_tx.send(Event::Resize(x, y)).unwrap();
                  },
                  CrosstermEvent::FocusLost =&gt; {
                    _event_tx.send(Event::FocusLost).unwrap();
                  },
                  CrosstermEvent::FocusGained =&gt; {
                    _event_tx.send(Event::FocusGained).unwrap();
                  },
                  CrosstermEvent::Paste(s) =&gt; {
                    _event_tx.send(Event::Paste(s)).unwrap();
                  },
                }
              }
              Some(Err(_)) =&gt; {
                _event_tx.send(Event::Error).unwrap();
              }
              None =&gt; {},
            }
          },
          _ = tick_delay =&gt; {
              _event_tx.send(Event::Tick).unwrap();
          },
          _ = render_delay =&gt; {
              _event_tx.send(Event::Render).unwrap();
          },
        }
      }
    });
  }

  pub fn stop(&amp;self) -&gt; Result&lt;()&gt; {
    self.cancel();
    let mut counter = 0;
    while !self.task.is_finished() {
      std::thread::sleep(Duration::from_millis(1));
      counter += 1;
      if counter &gt; 50 {
        self.task.abort();
      }
      if counter &gt; 100 {
        log::error!(&quot;Failed to abort task in 100 milliseconds for unknown reason&quot;);
        break;
      }
    }
    Ok(())
  }

  pub fn enter(&amp;mut self) -&gt; Result&lt;()&gt; {
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(std::io::stderr(), EnterAlternateScreen, cursor::Hide)?;
    if self.mouse {
      crossterm::execute!(std::io::stderr(), EnableMouseCapture)?;
    }
    if self.paste {
      crossterm::execute!(std::io::stderr(), EnableBracketedPaste)?;
    }
    self.start();
    Ok(())
  }

  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.stop()?;
    if crossterm::terminal::is_raw_mode_enabled()? {
      self.flush()?;
      if self.paste {
        crossterm::execute!(std::io::stderr(), DisableBracketedPaste)?;
      }
      if self.mouse {
        crossterm::execute!(std::io::stderr(), DisableMouseCapture)?;
      }
      crossterm::execute!(std::io::stderr(), LeaveAlternateScreen, cursor::Show)?;
      crossterm::terminal::disable_raw_mode()?;
    }
    Ok(())
  }

  pub fn cancel(&amp;self) {
    self.cancellation_token.cancel();
  }

  pub fn suspend(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.exit()?;
    #[cfg(not(windows))]
    signal_hook::low_level::raise(signal_hook::consts::signal::SIGTSTP)?;
    Ok(())
  }

  pub fn resume(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.enter()?;
    Ok(())
  }

  pub async fn next(&amp;mut self) -&gt; Option&lt;Event&gt; {
    self.event_rx.recv().await
  }
}

impl Deref for Tui {
  type Target = ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;;

  fn deref(&amp;self) -&gt; &amp;Self::Target {
    &amp;self.terminal
  }
}

impl DerefMut for Tui {
  fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
    &amp;mut self.terminal
  }
}

impl Drop for Tui {
  fn drop(&amp;mut self) {
    self.exit().unwrap();
  }
}</code></pre>
<p>Then you‚Äôll be able write code like this:</p>
<pre><code class="language-rust">mod tui;

impl App {
  async fn run(&amp;mut self) -&gt; Result&lt;()&gt; {

    let mut tui = tui::Tui::new()?
            .tick_rate(4.0) // 4 ticks per second
            .frame_rate(30.0); // 30 frames per second

    tui.enter()?; // Starts event handler, enters raw mode, enters alternate screen

    loop {

      tui.draw(|f| { // Deref allows calling `tui.terminal.draw`
        self.ui(f);
      })?;

      if let Some(evt) = tui.next().await { // `tui.next().await` blocks till next event
        let mut maybe_action = self.handle_event(evt);
        while let Some(action) = maybe_action {
          maybe_action = self.update(action);
        }
      };

      if self.should_quit {
        break;
      }
    }

    tui.exit()?; // stops event handler, exits raw mode, exits alternate screen

    Ok(())
  }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-panic-hooks"><a class="header" href="#setup-panic-hooks">Setup Panic Hooks</a></h1>
<p>When building TUIs with <code>ratatui</code>, it‚Äôs vital to ensure that if your application encounters a panic,
it gracefully returns to the original terminal state. This prevents the terminal from getting stuck
in a modified state, which can be quite disruptive for users.</p>
<p>Here‚Äôs an example <code>initialize_panic_handler</code> that works with <code>crossterm</code> and with the Rust standard
library functionality and no external dependencies.</p>
<pre><code class="language-rust">pub fn initialize_panic_handler() {
    let original_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen).unwrap();
        crossterm::terminal::disable_raw_mode().unwrap();
        original_hook(panic_info);
    }));
}</code></pre>
<p>With this function, all your need to do is call <code>initialize_panic_handler()</code> in <code>main()</code> before
running any terminal initialization code:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
    initialize_panic_handler();

    // Startup
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

    let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

    // ...

    // Shutdown
    crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
    crossterm::terminal::disable_raw_mode()?;
    Ok(())
}</code></pre>
<p>We used <code>crossterm</code> for panic handling. If you are using <code>termion</code> you can do something like the
following:</p>
<pre><code class="language-rust">use std::panic;
use std::error::Error;

pub fn initialize_panic_handler() {
    let panic_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic| {
        let panic_cleanup = || -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
            let mut output = io::stderr();
            write!(
                output,
                &quot;{}{}{}&quot;,
                termion::clear::All,
                termion::screen::ToMainScreen,
                termion::cursor::Show
            )?;
            output.into_raw_mode()?.suspend_raw_mode()?;
            io::stderr().flush()?;
            Ok(())
        };
        panic_cleanup().expect(&quot;failed to clean up for panic&quot;);
        panic_hook(panic);
    }));
}</code></pre>
<p>As a general rule, you want to take the original panic hook and execute it after cleaning up the
terminal. In the next sections we will discuss some third party packages that can help give better
stacktraces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-panic-hooks-using-better-panic-color-eyre-and-human-panic"><a class="header" href="#better-panic-hooks-using-better-panic-color-eyre-and-human-panic">Better Panic Hooks using <code>better-panic</code>, <code>color-eyre</code> and <code>human-panic</code></a></h1>
<p>Your application may panic for a number of reasons (e.g. when you call <code>.unwrap()</code> on a <code>None</code>). And
when this happens, you want to be a good citizen and:</p>
<ol>
<li>provide a useful stacktrace so that they can report errors back to you.</li>
<li>not leave the users terminal state in a botched condition, resetting it back to the way it was.</li>
</ol>
<h2 id="better-panic"><a class="header" href="#better-panic"><code>better-panic</code></a></h2>
<p><a href="https://github.com/mitsuhiko/better-panic"><code>better-panic</code></a> gives you pretty backtraces for panics.</p>
<pre><code class="language-shell">cargo add better-panic
</code></pre>
<p>Here‚Äôs an example of <code>initialize_panic_handler()</code> using <code>better-panic</code> to provide a prettier
backtrace by default.</p>
<pre><code class="language-rust">use better_panic::Settings;

pub fn initialize_panic_handler() {
  std::panic::set_hook(Box::new(|panic_info| {
    crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen).unwrap();
    crossterm::terminal::disable_raw_mode().unwrap();
    Settings::auto().most_recent_first(false).lineno_suffix(true).create_panic_handler()(panic_info);
  }));
}</code></pre>
<p>I personally like to reuse the <a href="how-to/develop-apps/./abstract-terminal-and-event-handler.html"><code>Tui</code></a> struct in the panic
handler. That way, if I ever decide to move from <code>crossterm</code> to <code>termion</code> in the future, there‚Äôs one
less place in the project that I have to worry about refactoring.</p>
<p>Here‚Äôs an example of <code>initialize_panic_handler()</code> using
<a href="https://docs.rs/better-panic/latest/better_panic/"><code>better_panic</code></a> and
<a href="https://docs.rs/libc/latest/libc/"><code>libc</code></a> to provide a prettier backtrace by default.</p>
<pre><code class="language-rust">use better_panic::Settings;

pub fn initialize_panic_handler() {
  std::panic::set_hook(Box::new(|panic_info| {
    match crate::tui::Tui::new() {
      Ok(t) =&gt; {
        if let Err(r) = t.exit() {
          error!(&quot;Unable to exit Terminal: {r:?}&quot;);
        }
      },
      Err(r) =&gt; error!(&quot;Unable to exit Terminal: {r:?}&quot;),
    }
    better_panic::Settings::auto()
      .most_recent_first(false)
      .lineno_suffix(true)
      .verbosity(better_panic::Verbosity::Full)
      .create_panic_handler()(panic_info);
    std::process::exit(libc::EXIT_FAILURE);
  }));
}</code></pre>
<p>Now, let‚Äôs say I added a <code>panic!</code> to
<a href="https://github.com/ratatui-org/ratatui-async-template">an application</a> as an example:</p>
<pre><code class="language-diff">diff --git a/src/components/app.rs b/src/components/app.rs
index 289e40b..de48392 100644
--- a/src/components/app.rs
+++ b/src/components/app.rs
@@ -77,6 +77,7 @@ impl App {
   }

   pub fn increment(&amp;mut self, i: usize) {
+    panic!(&quot;At the disco&quot;);
     self.counter = self.counter.saturating_add(i);
   }
</code></pre>
<p>This is what a prettier stacktrace would look like with <code>better-panic</code>:</p>
<pre><code class="language-plain">Backtrace (most recent call last):
  File &quot;/Users/kd/gitrepos/ratatui-async-template/src/main.rs:46&quot;, in ratatui_async_template::main
    Ok(())
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/runtime.rs:304&quot;, in tokio::runtime::runtime::Runtime::block_on
    Scheduler::MultiThread(exec) =&gt; exec.block_on(&amp;self.handle.inner, future),
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/scheduler/multi_thread/mod.rs:66&quot;, in tokio::runtime::scheduler::multi_thread::MultiThread::block_on
    enter
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/context.rs:315&quot;, in tokio::runtime::context::BlockingRegionGuard::block_on
    park.block_on(f)
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/park.rs:283&quot;, in tokio::runtime::park::CachedParkThread::block_on
    if let Ready(v) = crate::runtime::coop::budget(|| f.as_mut().poll(&amp;mut cx)) {
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/coop.rs:73&quot;, in tokio::runtime::coop::budget
    with_budget(Budget::initial(), f)
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/coop.rs:107&quot;, in tokio::runtime::coop::with_budget
    f()
  File &quot;/Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/park.rs:283&quot;, in tokio::runtime::park::CachedParkThread::block_on::{{closure}}
    if let Ready(v) = crate::runtime::coop::budget(|| f.as_mut().poll(&amp;mut cx)) {
  File &quot;/Users/kd/gitrepos/ratatui-async-template/src/main.rs:44&quot;, in ratatui_async_template::main::{{closure}}
    runner.run().await?;
  File &quot;/Users/kd/gitrepos/ratatui-async-template/src/runner.rs:80&quot;, in ratatui_async_template:üèÉ:Runner::run::{{closure}}
    if let Some(action) = component.update(action.clone())? {
  File &quot;/Users/kd/gitrepos/ratatui-async-template/src/components/app.rs:132&quot;, in &lt;ratatui_async_template::components::app::App as ratatui_async_template::components::Component&gt;::update
    Action::Increment(i) =&gt; self.increment(i),
  File &quot;/Users/kd/gitrepos/ratatui-async-template/src/components/app.rs:80&quot;, in ratatui_async_template::components::app::App::increment
    panic!(&quot;At the disco&quot;);

The application panicked (crashed).
  At the disco
in src/components/app.rs:80
thread: main
</code></pre>
<p>With <code>.most_recent_first(false)</code> the last line of the stacktrace is typically where the error has
occurred. This makes it fast and easy to find the error without having to scroll up the terminal
history, and iterate on your application rapidly during development.</p>
<p>This kind of detailed stacktrace is only available in debug builds. For release builds, you may get
inlined or truncated stacktraces.</p>
<p>For example, here‚Äôs what I get when I compile with all optimizations on:</p>
<pre><code class="language-plain">Backtrace (most recent call last):
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header
  File &quot;&lt;unknown&gt;:0&quot;, in __mh_execute_header

The application panicked (crashed).
  At the disco
in src/components/app.rs:80
thread: main
</code></pre>
<p>This is not particularly useful to show to the average user. We‚Äôll discuss better solutions for what
to show the users of your application in the following subsections.</p>
<h3 id="color-eyre-panic-hook"><a class="header" href="#color-eyre-panic-hook">color-eyre panic hook</a></h3>
<p>Another way to manage printing of stack-traces is by using
<a href="https://github.com/eyre-rs/color-eyre"><code>color-eyre</code></a>:</p>
<pre><code class="language-shell">cargo add color-eyre
</code></pre>
<p><code>color-eyre</code> has a panic hook that is better suited for users in my opinion.</p>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="how-to/develop-apps/better-panic-hooks.html#admonition-tip"></a></p>
</div>
<div>
<p>You will also want to add a <code>repository</code> key to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">repository = &quot;https://github.com/ratatui-org/ratatui-async-template&quot; # used by env!(&quot;CARGO_PKG_REPOSITORY&quot;)
</code></pre>
</div>
</div>
<p>When a <code>panic!</code> occurs, after the application cleanly restores the terminal, we can print out a nice
error message created by <code>color-eyre</code> like so:</p>
<pre><code class="language-plain">The application panicked (crashed).
Message:  At the disco
Location: src/components/app.rs:80

This is a bug. Consider reporting it at https://github.com/ratatui-org/ratatui-async-template

Backtrace omitted. Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre>
<p>This is short and clear, providing a link to the user to report the bug.</p>
<p>Users can also opt to give you a more detailed stacktrace if they can reproduce the error (with a
debug build and with <code>export RUST_BACKTRACE=1</code>):</p>
<pre><code class="language-plain">The application panicked (crashed).
Message:  At the disco
Location: src/components/app.rs:80

This is a bug. Consider reporting it at https://github.com/ratatui-org/ratatui-async-template

  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ BACKTRACE ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                                ‚ãÆ 13 frames hidden ‚ãÆ
  14: ratatui_async_template::components::app::App::increment::h4e8b6e0d83d3d575
      at /Users/kd/gitrepos/ratatui-async-template/src/components/app.rs:80
  15: &lt;ratatui_async_template::components::app::App as ratatui_async_template::components::Component&gt;::update::hc78145b4a91e06b6
      at /Users/kd/gitrepos/ratatui-async-template/src/components/app.rs:132
  16: ratatui_async_template:üèÉ:Runner::run::{{closure}}::h802b0d3c3413762b
      at /Users/kd/gitrepos/ratatui-async-template/src/runner.rs:80
  17: ratatui_async_template::main::{{closure}}::hd78d335f19634c3f
      at /Users/kd/gitrepos/ratatui-async-template/src/main.rs:44
  18: tokio::runtime::park::CachedParkThread::block_on::{{closure}}::hd7949515524de9f8
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/park.rs:283
  19: tokio::runtime::coop::with_budget::h39648e20808374d3
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/coop.rs:107
  20: tokio::runtime::coop::budget::h653c1593abdd982d
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/coop.rs:73
  21: tokio::runtime::park::CachedParkThread::block_on::hb0a0dd4a7c3cf33b
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/park.rs:283
  22: tokio::runtime::context::BlockingRegionGuard::block_on::h4d02ab23bd93d0fd
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/context.rs:315
  23: tokio::runtime::scheduler::multi_thread::MultiThread::block_on::h8aaba9030519c80d
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/scheduler/multi_thread/mod.rs:66
  24: tokio::runtime::runtime::Runtime::block_on::h73a6fbfba201fac9
      at /Users/kd/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.28.2/src/runtime/runtime.rs:304
  25: ratatui_async_template::main::h6da543b193746523
      at /Users/kd/gitrepos/ratatui-async-template/src/main.rs:46
  26: core::ops::function::FnOnce::call_once::h6cac3edc975fcef2
      at /rustc/eb26296b556cef10fb713a38f3d16b9886080f26/library/core/src/ops/function.rs:250
                                ‚ãÆ 13 frames hidden ‚ãÆ
</code></pre>
<h2 id="human-panic"><a class="header" href="#human-panic">human-panic</a></h2>
<p>To use <a href="https://github.com/rust-cli/human-panic">human-panic</a>, you‚Äôll have to install it as a
dependency:</p>
<pre><code class="language-shell">cargo add human-panic
</code></pre>
<p>Personally, I think <code>human-panic</code> provides the most user friendly panic handling functionality out
of the box when users experience an unexpected panic:</p>
<pre><code class="language-plain">Well, this is embarrassing.

ratatui-async-template had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/l4/bnjjc6p15zd3jnty8c_qkrtr0000gn/T/report-ce1e29cb-c17c-4684-b9d4-92d9678242b7.toml&quot;. Submit an issue or email with the subject of &quot;ratatui-async-template Crash Report&quot; and include the report as an attachment.

- Authors: Dheepak Krishnamurthy

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<p>It generates a report where information relevant to the crash is logged. Here‚Äôs the content of the
temporary report file that <code>human-panic</code> creates (with optimizations turned on):</p>
<pre><code class="language-plain">name = &quot;ratatui-async-template&quot;
operating_system = &quot;Mac OS 13.5.2 [64-bit]&quot;
crate_version = &quot;0.1.0&quot;
explanation = &quot;&quot;&quot;
Panic occurred in file 'src/components/app.rs' at line 80
&quot;&quot;&quot;
cause = &quot;At the disco&quot;
method = &quot;Panic&quot;
backtrace = &quot;&quot;&quot;

   0: 0x10448f5f8 - __mh_execute_header
   1: 0x1044a43c8 - __mh_execute_header
   2: 0x1044a01ac - __mh_execute_header
   3: 0x10446f8c0 - __mh_execute_header
   4: 0x1044ac850 - __mh_execute_header&quot;&quot;&quot;
</code></pre>
<p>In debug mode, the stacktrace is as descriptive as earlier.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>You can mix and match these different panic handlers, using <code>better-panic</code> for debug builds and
<code>color-eyre</code> and <code>human-panic</code> for release builds. The code below also prints the <code>color-eyre</code>
stacktrace to <code>log::error!</code> for good measure (after striping ansi escape sequences).</p>
<pre><code class="language-shell">cargo add color-eyre human-panic libc better-panic strip-ansi-escapes
</code></pre>
<p>Here‚Äôs code you can copy paste into your project (if you use the
<a href="how-to/develop-apps/./abstract-terminal-and-event-handler.html"><code>Tui</code></a> struct to handle terminal exits):</p>
<pre><code class="language-rust">pub fn initialize_panic_handler() -&gt; Result&lt;()&gt; {
  let (panic_hook, eyre_hook) = color_eyre::config::HookBuilder::default()
    .panic_section(format!(&quot;This is a bug. Consider reporting it at {}&quot;, env!(&quot;CARGO_PKG_REPOSITORY&quot;)))
    .display_location_section(true)
    .display_env_section(true)
    .into_hooks();
  eyre_hook.install()?;
  std::panic::set_hook(Box::new(move |panic_info| {
    if let Ok(t) = crate::tui::Tui::new() {
      if let Err(r) = t.exit() {
        error!(&quot;Unable to exit Terminal: {:?}&quot;, r);
      }
    }

    let msg = format!(&quot;{}&quot;, panic_hook.panic_report(panic_info));
    #[cfg(not(debug_assertions))]
    {
      eprintln!(&quot;{}&quot;, msg); // prints color-eyre stack trace to stderr
      use human_panic::{handle_dump, print_msg, Metadata};
      let meta = Metadata {
        version: env!(&quot;CARGO_PKG_VERSION&quot;).into(),
        name: env!(&quot;CARGO_PKG_NAME&quot;).into(),
        authors: env!(&quot;CARGO_PKG_AUTHORS&quot;).replace(':', &quot;, &quot;).into(),
        homepage: env!(&quot;CARGO_PKG_HOMEPAGE&quot;).into(),
      };

      let file_path = handle_dump(&amp;meta, panic_info);
      // prints human-panic message
      print_msg(file_path, &amp;meta).expect(&quot;human-panic: printing error message to console failed&quot;);
    }
    log::error!(&quot;Error: {}&quot;, strip_ansi_escapes::strip_str(msg));

    #[cfg(debug_assertions)]
    {
      // Better Panic stacktrace that is only enabled when debugging.
      better_panic::Settings::auto()
        .most_recent_first(false)
        .lineno_suffix(true)
        .verbosity(better_panic::Verbosity::Full)
        .create_panic_handler()(panic_info);
    }

    std::process::exit(libc::EXIT_FAILURE);
  }));
  Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrate-from-tui-rs"><a class="header" href="#migrate-from-tui-rs">Migrate from tui-rs</a></h1>
<p><a href="https://github.com/tui-rs-revival/ratatui">Ratatui</a> is a fork of
<a href="https://github.com/fdehau/tui-rs/">tui-rs</a>, created to continue maintenance of the project.</p>
<p>Several options are available to migrate apps and libs:</p>
<ul>
<li>Fully replace <code>tui-rs</code> with <code>ratatui</code> (preferred approach)</li>
<li>Use <code>ratatui</code> as a drop in replacement aliased as <code>tui</code></li>
<li>Support both <code>tui</code> and <code>ratatui</code></li>
</ul>
<h2 id="fully-replace-tui-with-ratatui"><a class="header" href="#fully-replace-tui-with-ratatui">Fully replace Tui with Ratatui</a></h2>
<p>Most new code should use the following. To take this approach to migration requires find and
replace <code>tui::</code>-&gt;<code>ratatui::</code> on the entire codebase.</p>
<pre><code class="language-toml">ratatui = { version = &quot;0.24.0&quot; }
crossterm = { version = &quot;0.27.0&quot; }
</code></pre>
<h2 id="drop-in-replacement"><a class="header" href="#drop-in-replacement">Drop in replacement</a></h2>
<p>The simplest approach to migrating to <code>ratatui</code> is to use it as drop in replacement for tui and
update the terminal libraries used (<code>crossterm</code> / <code>termion</code>). E.g.:</p>
<pre><code class="language-toml">tui = { package = &quot;ratatui&quot;, version = &quot;0.24.0&quot;, features = [&quot;crossterm&quot;] }
crossterm = { version = &quot;0.27.0&quot; }
</code></pre>
<h2 id="support-both-tui-and-ratatui"><a class="header" href="#support-both-tui-and-ratatui">Support both tui and ratatui</a></h2>
<p>For more complex scenarios where a library (or in some cases an app) needs to support both ratatui
and maintain existing support for tui, it may be feasible to use feature flags to select which
library to use. See <a href="https://github.com/gin66/tui-logger">tui-logger</a> for an example of this
approach.</p>
<h2 id="backwards-compatibility-and-breaking-changes"><a class="header" href="#backwards-compatibility-and-breaking-changes">Backwards compatibility and breaking changes</a></h2>
<ul>
<li><a href="https://github.com/ratatui-org/ratatui/blob/main/BREAKING-CHANGES.md">BREAKING-CHANGES.md</a></li>
<li>PRs tagged with the <a href="https://github.com/ratatui-org/ratatui/pulls?q=is%3Apr+label%3A%22breaking+change%22+is%3Aclosed">breaking changes</a> label</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<ul>
<li><a href="faq/./duplicate-key-events-windows.html">Duplicate Key Events on Windows</a></li>
<li><a href="faq/./tokio-async.html"><code>tokio</code> / <code>async</code></a></li>
<li><a href="faq/./tui-rs-history.html"><code>tui.rs</code> history</a></li>
</ul>
<h2 id="what-is-the-difference-between-a-library-and-a-framework"><a class="header" href="#what-is-the-difference-between-a-library-and-a-framework">What is the difference between a library and a framework?</a></h2>
<p>The terms library and framework are often used interchangeably in software development, but they
serve different purposes and have distinct characteristics.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Library</th><th>Framework</th></tr></thead><tbody>
<tr><td><strong>Usage</strong></td><td>A library is a collection of functions and procedures that a programmer can call in their application. The library provides specific functionality, but it‚Äôs the developer‚Äôs responsibility to explicitly call and use it.</td><td>A framework is a pre-built structure or scaffold that developers build their application within. It provides a foundation, enforcing a particular way of creating an application.</td></tr>
<tr><td><strong>Control Flow</strong></td><td>In the case of a library, the control flow remains with the developer‚Äôs application. The developer chooses when and where to use the library.</td><td>With a framework, the control flow is inverted. The framework decides the flow of control by providing places for the developer to plug in their own logic (often referred to as ‚ÄúInversion of Control‚Äù or IoC).</td></tr>
<tr><td><strong>Nature</strong></td><td>Libraries are passive in nature. They wait for the application‚Äôs code to invoke their methods.</td><td>Frameworks are active and have a predefined flow of their own. The developer fills in specific pieces of the framework with their own code.</td></tr>
<tr><td><strong>Example</strong></td><td>Imagine you‚Äôre building a house. A library would be like a toolbox with tools (functions) that you can use at will. You decide when and where to use each tool.</td><td>Using the house-building analogy, a framework would be like a prefabricated house where the main structure is already built. You‚Äôre tasked with filling in the interiors and decor, but you have to follow the design and architecture already provided by the prefabricated design.</td></tr>
</tbody></table>
</div>
<h2 id="what-is-the-difference-between-a-ratatui-a-library-and-a-tui-realm-a-framework"><a class="header" href="#what-is-the-difference-between-a-ratatui-a-library-and-a-tui-realm-a-framework">What is the difference between a <code>ratatui</code> (a library) and a <a href="https://github.com/veeso/tui-realm/"><code>tui-realm</code></a> (a framework)?</a></h2>
<p>While <code>ratatui</code> provides tools (widgets) for building terminal UIs, it doesn‚Äôt dictate or enforce a
specific way to structure your application. You need to decide how to best use the library in your
particular context, giving you more flexibility.</p>
<p>In contrast, <code>tui-realm</code> might provide more guidelines and enforcements about how your application
should be structured or how data flows through it. And, for the price of that freedom, you get more
features out of the box with <code>tui-realm</code> and potentially lesser code in your application to do the
same thing that you would with <code>ratatui</code>.</p>
<h2 id="what-is-the-difference-between-ratatui-and-cursive"><a class="header" href="#what-is-the-difference-between-ratatui-and-cursive">What is the difference between <code>ratatui</code> and <code>cursive</code>?</a></h2>
<p><a href="https://github.com/gyscos/cursive">Cursive</a> and Ratatui are both libraries that make TUIs easier to
write. Both libraries are great! Both also work on linux, macOS and windows.</p>
<h3 id="cursive"><a class="header" href="#cursive">Cursive</a></h3>
<p>Cursive uses a more declarative UI: the user defines the layout, then cursive handles the event
loop. Cursive also handles most input (including mouse clicks), and forwards events to the currently
focused view. User-code is more focused on ‚Äúevents‚Äù than on keyboard input. Cursive also supports
different backends like ncurses, pancurses, termion, and crossterm.</p>
<p>One of cursive‚Äôs main features is its built-in event loop. You can easily attach callbacks to events
like clicks or key presses, making it straightforward to handle user interactions.</p>
<pre><code class="language-rust">use cursive::views::{Dialog, TextView};

fn main() {
    // Creates the cursive root - required for every application.
    let mut siv = cursive::default();

    // Creates a dialog with a single &quot;Quit&quot; button
    siv.add_layer(Dialog::around(TextView::new(&quot;Hello World!&quot;))
                         .title(&quot;Cursive&quot;)
                         .button(&quot;Quit&quot;, |s| s.quit()));

    // Starts the event loop.
    siv.run();
}</code></pre>
<p><img src="https://user-images.githubusercontent.com/1813121/271896508-d5f6192c-d51b-4299-9b5e-9d91e4618f64.png" alt="" /></p>
<h3 id="ratatui"><a class="header" href="#ratatui">Ratatui</a></h3>
<p>In Ratatui, the user handles the event loop, the application state, and re-draws the entire UI on
each iteration. It does not handle input and users have use another library (like
<a href="https://github.com/TimonPost/crossterm">crossterm</a>). Ratatui supports Crossterm, termion, wezterm
as backends.</p>
<pre><code class="language-rust">use ratatui::{prelude::*, widgets::*};

fn init() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;
  Ok(())
}

fn exit() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;
  Ok(())
}

fn centered_rect(r: Rect, percent_x: u16, percent_y: u16) -&gt; Rect {
  let popup_layout = Layout::default()
    .direction(Direction::Vertical)
    .constraints([
      Constraint::Percentage((100 - percent_y) / 2),
      Constraint::Percentage(percent_y),
      Constraint::Percentage((100 - percent_y) / 2),
    ])
    .split(r);

  Layout::default()
    .direction(Direction::Horizontal)
    .constraints([
      Constraint::Percentage((100 - percent_x) / 2),
      Constraint::Percentage(percent_x),
      Constraint::Percentage((100 - percent_x) / 2),
    ])
    .split(popup_layout[1])[1]
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  init()?;

  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  loop {
    terminal.draw(|f| {
      let rect = centered_rect(f.size(), 35, 35);
      f.render_widget(
        Paragraph::new(&quot;Hello World!\n\n\n'q' to quit&quot;)
          .block(
            Block::default().title(block::Title::from(&quot;Ratatui&quot;).alignment(Alignment::Center)).borders(Borders::all()),
          )
          .alignment(Alignment::Center),
        rect,
      );
    })?;

    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        if key.code == crossterm::event::KeyCode::Char('q') {
          break;
        }
      }
    }
  }
  exit()?;

  Ok(())
}</code></pre>
<p><img src="https://user-images.githubusercontent.com/1813121/271896510-c8db19d1-f132-49b5-89da-c32cc21ab765.png" alt="" /></p>
<p>You may have to write more code but you get precise control over exact UI you want to display with
Ratatui.</p>
<h2 id="can-you-change-font-size-in-a-terminal-using-ratatui"><a class="header" href="#can-you-change-font-size-in-a-terminal-using-ratatui">Can you change font size in a terminal using <code>ratatui</code>?</a></h2>
<p><code>ratatui</code> itself doesn‚Äôt control the terminal‚Äôs font size. <code>ratatui</code> renders content based on the
size and capabilities of the terminal it‚Äôs running in. If you want to change the font size, you‚Äôll
need to adjust the settings of your terminal emulator.</p>
<p><img src="https://user-images.githubusercontent.com/1813121/269147939-0ed031f2-1977-4e92-b4b4-6c217d02e79b.png" alt="" /></p>
<p>However, changing this setting in your terminal emulator will only change the font size for you
while you are developing your <code>ratatui</code> based application.</p>
<p>When a user zooms in and out using terminal shortcuts, that will typically change the font size in
their terminal. You typically will not know what the terminal font size is ahead of time.</p>
<p>However, you can know the current terminal size (i.e. columns and rows). Additionally, when zooming
in and out <code>ratatui</code> applications will see a terminal resize event that will contain the new columns
and rows. You should ensure your <code>ratatui</code> application can handle these changes gracefully.</p>
<p>You can detect changes in the terminal‚Äôs size by listening for terminal resize events from the
backend of your choice and you can adjust your application layout as needed.</p>
<p>For example, here‚Äôs how you might do it in
<a href="https://docs.rs/crossterm/0.27.0/crossterm/event/enum.Event.html#variant.Resize">crossterm</a>:</p>
<pre><code class="language-rust">    match crossterm::terminal::read() {
        Ok(evt) =&gt; {
            match evt {
                crossterm::event::Event::Resize(x, y) =&gt; {
                    // handle resize event here
                },
                _ =&gt; {}
            }
        }
    }</code></pre>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="faq/index.html#admonition-tip"></a></p>
</div>
<div>
<p>Since this can happen on the user end without your control, this means that you‚Äôll have to design
your <code>ratatui</code> based terminal user interface application to display content well in a
number of different terminal sizes.</p>
</div>
</div>
<p><code>ratatui</code> does support various styles, including bold, italic, underline, and more, and while this
doesn‚Äôt change the font size, it does provide you with the capability to emphasize or de-emphasize
text content in your application.</p>
<p>Additionally you can use <a href="https://docs.rs/figlet-rs/latest/figlet_rs/"><code>figlet</code></a> or
<a href="https://github.com/joshka/tui-big-text/"><code>tui-big-text</code></a> to display text content across multiple
lines. Here‚Äôs an example using <a href="https://github.com/joshka/tui-big-text/"><code>tui-big-text</code></a>:</p>
<p><img src="https://camo.githubusercontent.com/3a738ce21da3ae67660181538ef27473b86bebca73f42944e8012d52f86e500d/68747470733a2f2f7668732e636861726d2e73682f7668732d3364545474724c6b79553534684e61683232504152392e676966" alt="tui-big-text" /></p>
<h2 id="can-you-use-multiple-terminaldraw-calls-consequently"><a class="header" href="#can-you-use-multiple-terminaldraw-calls-consequently">Can you use multiple <code>terminal.draw()</code> calls consequently?</a></h2>
<p>You <em>cannot</em> use <code>terminal.draw()</code> multiple times in the same <code>main</code> loop.</p>
<p>Because Ratatui uses a double buffer rendering technique, writing code like this will <em><strong>NOT</strong></em>
render all three widgets:</p>
<pre><code class="language-rust">  loop {
    terminal.draw(|f| {
      f.render_widget(widget1, f.size());
    })?;
    terminal.draw(|f| {
      f.render_widget(widget2, f.size());
    })?;
    terminal.draw(|f| {
      f.render_widget(widget3, f.size());
    })?;
    // handle events
    // manage state
  }</code></pre>
<p>You want to write the code like this instead:</p>
<pre><code class="language-rust">  loop {
    terminal.draw(|f| {
      f.render_widget(widget1, f.size());
      f.render_widget(widget2, f.size());
      f.render_widget(widget3, f.size());
    })?;
    // handle events
    // manage state
  }</code></pre>
<h2 id="should-i-use-stdout-or-stderr"><a class="header" href="#should-i-use-stdout-or-stderr">Should I use <code>stdout</code> or <code>stderr</code>?</a></h2>
<p>When using <code>crossterm</code>, application developers have the option of rendering to <code>stdout</code> or <code>stderr</code>.</p>
<pre><code class="language-rust">let mut t = Terminal::new(CrosstermBackend::new(std::io::stdout()))?;
// OR
let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;</code></pre>
<p>Both of these will work fine for normal purposes. The question you have to ask if how would you like
your application to behave in non-TTY environments.</p>
<p>For example, if you run <code>ratatui-application | grep foo</code> with <code>stdout</code>, your application won‚Äôt
render anything to the screen and there would be no indication of anything going wrong. With
<code>stderr</code> the application will still render a TUI.</p>
<p>With <code>stdout</code>:</p>
<ul>
<li>Every app needs to add code to check if the output is a TTY and do something different based on
the result</li>
<li>App can‚Äôt write a result to the user that can be passed in a pipeline, e.g.
<code>my-select-some-value-app | grep foo</code></li>
<li>Tends to be what most command line applications do by default.</li>
</ul>
<p>With <code>stderr</code>:</p>
<ul>
<li>No special setup necessary in order to run in a pipe command</li>
<li>Unconventional and that might subvert users expectations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-am-i-getting-duplicate-key-events-on-windows"><a class="header" href="#why-am-i-getting-duplicate-key-events-on-windows">Why am I getting duplicate key events on Windows?</a></h1>
<p>A lot of examples out there in the wild might use the following code for sending key presses:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),</code></pre>
<p>However, on Windows, when using <code>Crossterm</code>, this will send the same <code>Event::Key(e)</code> twice; one for
when you press the key, i.e. <code>KeyEventKind::Press</code> and one for when you release the key, i.e.
<code>KeyEventKind::Release</code>. On <code>MacOS</code> and <code>Linux</code> only <code>KeyEventKind::Press</code> kinds of <code>key</code> event is
generated.</p>
<p>To make the code work as expected across all platforms, you can do this instead:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(key) =&gt; {
    if key.kind == KeyEventKind::Press {
      event_tx.send(Event::Key(key)).unwrap();
    }
  },</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-should-i-use-tokio-and-asyncawait"><a class="header" href="#when-should-i-use-tokio-and-asyncawait">When should I use <code>tokio</code> and <code>async</code>/<code>await</code>?</a></h1>
<p><code>ratatui</code> isn‚Äôt a native <code>async</code> library. So is it beneficial to use <code>tokio</code> or <code>async</code>/<code>await</code>?</p>
<p>As a user of <code>rataui</code>, there really is only one point of interface with the <code>ratatui</code> library and
that‚Äôs the <code>terminal.draw(|f| ui(f))</code> functionality (the creation of widgets provided by <code>ratatui</code>
typically happens in <code>ui(f)</code>). Everything else in your code is your own to do as you wish.</p>
<p>Should <code>terminal.draw(|f| ui(f))</code> be <code>async</code>? Possibly. Rendering to the terminal buffer is
relatively fast, especially using the double buffer technique that only renders diffs that <code>ratatui</code>
uses. Creating of the widgets can also be done quite efficiently.</p>
<p>So one question you may ask is can we make <code>terminal.draw(|f| ui(f))</code> <code>async</code> ourselves? Yes, we
can. Check out <a href="https://github.com/ratatui-org/ratatui-async-template/tree/v0.1.0">https://github.com/ratatui-org/ratatui-async-template/tree/v0.1.0</a> for an example.</p>
<p>The only other part related to <code>ratatui</code> that is beneficial to being <code>async</code> is reading the key
event inputs from <code>stdin</code>, and that can be made <code>async</code> with <code>crossterm</code>‚Äôs event-stream.</p>
<p>So the real question is what other parts of your app require <code>async</code> or benefit from being <code>async</code>?
If the answer is not much, maybe it is simpler to not use <code>async</code> and avoiding <code>tokio</code>.</p>
<p>Another way to think about it is, do you think your app would work better with 1 thread like this?</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="136" height="224">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="136" height="224"></rect>
  <text x="18" y="28" >Get</text>
  <text x="50" y="28" >Key</text>
  <text x="82" y="28" >Event</text>
  <text x="18" y="108" >Update</text>
  <text x="74" y="108" >State</text>
  <text x="42" y="188" >Render</text>
  <g>
    <path d="M 16,8 A 4,4 0,0,0 12,12" class="nofill"></path>
    <line x1="12" y1="12" x2="12" y2="36" class="solid"></line>
    <line x1="16" y1="8" x2="120" y2="8" class="solid"></line>
    <path d="M 120,8 A 4,4 0,0,1 124,12" class="nofill"></path>
    <line x1="124" y1="12" x2="124" y2="36" class="solid"></line>
    <path d="M 12,36 A 4,4 0,0,0 16,40" class="nofill"></path>
    <line x1="16" y1="40" x2="120" y2="40" class="solid"></line>
    <line x1="60" y1="40" x2="60" y2="84" class="solid"></line>
    <path d="M 124,36 A 4,4 0,0,1 120,40" class="nofill"></path>
    <polygon points="56,84 64,84 60,96" class="filled"></polygon>
  </g>
  <g>
    <path d="M 16,88 A 4,4 0,0,0 12,92" class="nofill"></path>
    <line x1="12" y1="92" x2="12" y2="116" class="solid"></line>
    <line x1="16" y1="88" x2="56" y2="88" class="solid"></line>
    <path d="M 12,116 A 4,4 0,0,0 16,120" class="nofill"></path>
    <line x1="16" y1="120" x2="112" y2="120" class="solid"></line>
    <line x1="60" y1="120" x2="60" y2="164" class="solid"></line>
    <polygon points="56,164 64,164 60,176" class="filled"></polygon>
    <line x1="64" y1="88" x2="112" y2="88" class="solid"></line>
    <path d="M 112,88 A 4,4 0,0,1 116,92" class="nofill"></path>
    <line x1="116" y1="92" x2="116" y2="116" class="solid"></line>
    <path d="M 116,116 A 4,4 0,0,1 112,120" class="nofill"></path>
  </g>
  <g>
    <path d="M 32,168 A 4,4 0,0,0 28,172" class="nofill"></path>
    <line x1="28" y1="172" x2="28" y2="196" class="solid"></line>
    <line x1="32" y1="168" x2="56" y2="168" class="solid"></line>
    <path d="M 28,196 A 4,4 0,0,0 32,200" class="nofill"></path>
    <line x1="32" y1="200" x2="96" y2="200" class="solid"></line>
    <line x1="64" y1="168" x2="96" y2="168" class="solid"></line>
    <path d="M 96,168 A 4,4 0,0,1 100,172" class="nofill"></path>
    <line x1="100" y1="172" x2="100" y2="196" class="solid"></line>
    <path d="M 100,196 A 4,4 0,0,1 96,200" class="nofill"></path>
  </g>
</svg></pre><div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="faq/tokio-async.html#admonition-note"></a></p>
</div>
<div>
<p>Even with the above architecture, you can use tokio to spawn tasks during <code>Update State</code>,
and follow up on the work done by those tasks in the next iteration.</p>
</div>
</div>
<p>Or would it work with 3 threads / <code>tokio</code> tasks like this:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="664" height="352">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="664" height="352"></rect>
  <text x="34" y="12" >Render</text>
  <text x="90" y="12" >Thread</text>
  <line x1="196" y1="0" x2="196" y2="336" class="broken"></line>
  <line x1="476" y1="0" x2="476" y2="336" class="broken"></line>
  <text x="274" y="60" >Get</text>
  <text x="306" y="60" >Key</text>
  <text x="338" y="60" >Event</text>
  <text x="258" y="124" >Map</text>
  <text x="290" y="124" >Event</text>
  <text x="338" y="124" >to</text>
  <text x="362" y="124" >Action</text>
  <text x="234" y="188" >Send</text>
  <text x="274" y="188" >Action</text>
  <text x="330" y="188" >on</text>
  <text x="354" y="188" >action</text>
  <line x1="400" y1="192" x2="408" y2="192" class="solid"></line>
  <text x="410" y="188" >tx</text>
  <text x="538" y="188" >Recv</text>
  <text x="578" y="188" >Action</text>
  <text x="18" y="252" >Recv</text>
  <text x="58" y="252" >on</text>
  <text x="82" y="252" >render</text>
  <line x1="128" y1="256" x2="136" y2="256" class="solid"></line>
  <text x="138" y="252" >rx</text>
  <line x1="200" y1="248" x2="472" y2="248" class="solid"></line>
  <text x="514" y="252" >Dispatch</text>
  <text x="586" y="252" >Action</text>
  <text x="18" y="316" >Render</text>
  <text x="74" y="316" >Component</text>
  <text x="530" y="316" >Update</text>
  <text x="586" y="316" >State</text>
  <text x="274" y="12" >Event</text>
  <text x="322" y="12" >Thread</text>
  <text x="522" y="12" >Main</text>
  <text x="562" y="12" >Thread</text>
  <g>
    <path d="M 256,40 A 4,4 0,0,0 252,44" class="nofill"></path>
    <line x1="252" y1="44" x2="252" y2="68" class="solid"></line>
    <line x1="256" y1="40" x2="400" y2="40" class="solid"></line>
    <path d="M 400,40 A 4,4 0,0,1 404,44" class="nofill"></path>
    <line x1="404" y1="44" x2="404" y2="68" class="solid"></line>
    <path d="M 252,68 A 4,4 0,0,0 256,72" class="nofill"></path>
    <line x1="256" y1="72" x2="400" y2="72" class="solid"></line>
    <line x1="324" y1="72" x2="324" y2="100" class="solid"></line>
    <path d="M 404,68 A 4,4 0,0,1 400,72" class="nofill"></path>
    <polygon points="320,100 328,100 324,112" class="filled"></polygon>
  </g>
  <g>
    <path d="M 248,104 A 4,4 0,0,0 244,108" class="nofill"></path>
    <line x1="244" y1="108" x2="244" y2="132" class="solid"></line>
    <line x1="248" y1="104" x2="320" y2="104" class="solid"></line>
    <path d="M 244,132 A 4,4 0,0,0 248,136" class="nofill"></path>
    <line x1="248" y1="136" x2="416" y2="136" class="solid"></line>
    <line x1="324" y1="136" x2="324" y2="164" class="solid"></line>
    <polygon points="320,164 328,164 324,176" class="filled"></polygon>
    <line x1="328" y1="104" x2="416" y2="104" class="solid"></line>
    <path d="M 416,104 A 4,4 0,0,1 420,108" class="nofill"></path>
    <line x1="420" y1="108" x2="420" y2="132" class="solid"></line>
    <path d="M 420,132 A 4,4 0,0,1 416,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 224,168 A 4,4 0,0,0 220,172" class="nofill"></path>
    <line x1="220" y1="172" x2="220" y2="196" class="solid"></line>
    <line x1="224" y1="168" x2="320" y2="168" class="solid"></line>
    <path d="M 220,196 A 4,4 0,0,0 224,200" class="nofill"></path>
    <line x1="224" y1="200" x2="440" y2="200" class="solid"></line>
    <line x1="328" y1="168" x2="440" y2="168" class="solid"></line>
    <path d="M 440,168 A 4,4 0,0,1 444,172" class="nofill"></path>
    <line x1="444" y1="172" x2="444" y2="196" class="solid"></line>
    <line x1="444" y1="184" x2="472" y2="184" class="solid"></line>
    <path d="M 444,196 A 4,4 0,0,1 440,200" class="nofill"></path>
  </g>
  <g>
    <path d="M 528,168 A 4,4 0,0,0 524,172" class="nofill"></path>
    <line x1="524" y1="172" x2="524" y2="196" class="solid"></line>
    <line x1="528" y1="168" x2="632" y2="168" class="solid"></line>
    <path d="M 632,168 A 4,4 0,0,1 636,172" class="nofill"></path>
    <line x1="636" y1="172" x2="636" y2="196" class="solid"></line>
    <path d="M 524,196 A 4,4 0,0,0 528,200" class="nofill"></path>
    <line x1="528" y1="200" x2="632" y2="200" class="solid"></line>
    <line x1="572" y1="200" x2="572" y2="228" class="solid"></line>
    <path d="M 636,196 A 4,4 0,0,1 632,200" class="nofill"></path>
    <polygon points="568,228 576,228 572,240" class="filled"></polygon>
  </g>
  <g>
    <line x1="480" y1="184" x2="512" y2="184" class="solid"></line>
    <polygon points="512,180 520,184 512,188" class="filled"></polygon>
  </g>
  <g>
    <path d="M 8,232 A 4,4 0,0,0 4,236" class="nofill"></path>
    <line x1="4" y1="236" x2="4" y2="260" class="solid"></line>
    <line x1="8" y1="232" x2="160" y2="232" class="solid"></line>
    <path d="M 160,232 A 4,4 0,0,1 164,236" class="nofill"></path>
    <line x1="164" y1="236" x2="164" y2="260" class="solid"></line>
    <path d="M 4,260 A 4,4 0,0,0 8,264" class="nofill"></path>
    <line x1="8" y1="264" x2="160" y2="264" class="solid"></line>
    <line x1="76" y1="264" x2="76" y2="292" class="solid"></line>
    <path d="M 164,260 A 4,4 0,0,1 160,264" class="nofill"></path>
    <polygon points="72,292 80,292 76,304" class="filled"></polygon>
  </g>
  <g>
    <path d="M 504,232 A 4,4 0,0,0 500,236" class="nofill"></path>
    <line x1="500" y1="236" x2="500" y2="260" class="solid"></line>
    <line x1="504" y1="232" x2="568" y2="232" class="solid"></line>
    <line x1="480" y1="248" x2="500" y2="248" class="solid"></line>
    <path d="M 500,260 A 4,4 0,0,0 504,264" class="nofill"></path>
    <line x1="504" y1="264" x2="640" y2="264" class="solid"></line>
    <line x1="572" y1="264" x2="572" y2="292" class="solid"></line>
    <polygon points="568,292 576,292 572,304" class="filled"></polygon>
    <line x1="576" y1="232" x2="640" y2="232" class="solid"></line>
    <path d="M 640,232 A 4,4 0,0,1 644,236" class="nofill"></path>
    <line x1="644" y1="236" x2="644" y2="260" class="solid"></line>
    <path d="M 644,260 A 4,4 0,0,1 640,264" class="nofill"></path>
  </g>
  <g>
    <polygon points="176,244 168,248 176,252" class="filled"></polygon>
    <line x1="176" y1="248" x2="192" y2="248" class="solid"></line>
  </g>
  <g>
    <path d="M 8,296 A 4,4 0,0,0 4,300" class="nofill"></path>
    <line x1="4" y1="300" x2="4" y2="324" class="solid"></line>
    <line x1="8" y1="296" x2="72" y2="296" class="solid"></line>
    <path d="M 4,324 A 4,4 0,0,0 8,328" class="nofill"></path>
    <line x1="8" y1="328" x2="152" y2="328" class="solid"></line>
    <line x1="80" y1="296" x2="152" y2="296" class="solid"></line>
    <path d="M 152,296 A 4,4 0,0,1 156,300" class="nofill"></path>
    <line x1="156" y1="300" x2="156" y2="324" class="solid"></line>
    <path d="M 156,324 A 4,4 0,0,1 152,328" class="nofill"></path>
  </g>
  <g>
    <path d="M 504,296 A 4,4 0,0,0 500,300" class="nofill"></path>
    <line x1="500" y1="300" x2="500" y2="324" class="solid"></line>
    <line x1="504" y1="296" x2="568" y2="296" class="solid"></line>
    <path d="M 500,324 A 4,4 0,0,0 504,328" class="nofill"></path>
    <line x1="504" y1="328" x2="648" y2="328" class="solid"></line>
    <line x1="576" y1="296" x2="648" y2="296" class="solid"></line>
    <path d="M 648,296 A 4,4 0,0,1 652,300" class="nofill"></path>
    <line x1="652" y1="300" x2="652" y2="324" class="solid"></line>
    <path d="M 652,324 A 4,4 0,0,1 648,328" class="nofill"></path>
  </g>
</svg></pre>
<p>In your <code>main</code> thread or <code>tokio</code> task, do you expect to be spawning more <code>tokio</code> tasks? How many
more tasks do you plan to be spawning?</p>
<p>The former can be done without any <code>async</code> code and the latter is the approach showcased in
<a href="https://github.com/ratatui-org/ratatui-async-template/tree/v0.1.0"><code>ratatui-async-template#v1.0</code></a>
with <code>tokio</code>.</p>
<p>The most recent version of the <code>ratatui-async-template</code> uses this architecture instead with tokio:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="584" height="384">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="584" height="384"></rect>
  <text x="58" y="12" >Event</text>
  <text x="106" y="12" >Thread</text>
  <line x1="260" y1="0" x2="260" y2="368" class="broken"></line>
  <text x="58" y="60" >Get</text>
  <text x="90" y="60" >Key</text>
  <text x="122" y="60" >Event</text>
  <text x="18" y="124" >Send</text>
  <text x="58" y="124" >Event</text>
  <text x="106" y="124" >on</text>
  <text x="130" y="124" >event</text>
  <line x1="168" y1="128" x2="176" y2="128" class="solid"></line>
  <text x="178" y="124" >tx</text>
  <text x="322" y="124" >Recv</text>
  <text x="362" y="124" >Event</text>
  <text x="298" y="188" >Map</text>
  <text x="330" y="188" >Event</text>
  <text x="378" y="188" >to</text>
  <text x="402" y="188" >Action</text>
  <text x="338" y="236" >Tick</text>
  <text x="314" y="284" >Update</text>
  <text x="370" y="284" >State</text>
  <text x="474" y="284" >Render</text>
  <text x="434" y="348" >Render</text>
  <text x="490" y="348" >Component</text>
  <text x="306" y="12" >Main</text>
  <text x="346" y="12" >Thread</text>
  <g>
    <path d="M 40,40 A 4,4 0,0,0 36,44" class="nofill"></path>
    <line x1="36" y1="44" x2="36" y2="68" class="solid"></line>
    <line x1="40" y1="40" x2="184" y2="40" class="solid"></line>
    <path d="M 184,40 A 4,4 0,0,1 188,44" class="nofill"></path>
    <line x1="188" y1="44" x2="188" y2="68" class="solid"></line>
    <path d="M 36,68 A 4,4 0,0,0 40,72" class="nofill"></path>
    <line x1="40" y1="72" x2="184" y2="72" class="solid"></line>
    <line x1="108" y1="72" x2="108" y2="100" class="solid"></line>
    <path d="M 188,68 A 4,4 0,0,1 184,72" class="nofill"></path>
    <polygon points="104,100 112,100 108,112" class="filled"></polygon>
  </g>
  <g>
    <path d="M 8,104 A 4,4 0,0,0 4,108" class="nofill"></path>
    <line x1="4" y1="108" x2="4" y2="132" class="solid"></line>
    <line x1="8" y1="104" x2="104" y2="104" class="solid"></line>
    <path d="M 4,132 A 4,4 0,0,0 8,136" class="nofill"></path>
    <line x1="8" y1="136" x2="224" y2="136" class="solid"></line>
    <line x1="112" y1="104" x2="224" y2="104" class="solid"></line>
    <path d="M 224,104 A 4,4 0,0,1 228,108" class="nofill"></path>
    <line x1="228" y1="108" x2="228" y2="132" class="solid"></line>
    <line x1="228" y1="120" x2="256" y2="120" class="solid"></line>
    <path d="M 228,132 A 4,4 0,0,1 224,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 312,104 A 4,4 0,0,0 308,108" class="nofill"></path>
    <line x1="308" y1="108" x2="308" y2="132" class="solid"></line>
    <line x1="312" y1="104" x2="416" y2="104" class="solid"></line>
    <path d="M 416,104 A 4,4 0,0,1 420,108" class="nofill"></path>
    <line x1="420" y1="108" x2="420" y2="132" class="solid"></line>
    <path d="M 308,132 A 4,4 0,0,0 312,136" class="nofill"></path>
    <line x1="312" y1="136" x2="416" y2="136" class="solid"></line>
    <line x1="356" y1="136" x2="356" y2="164" class="solid"></line>
    <path d="M 420,132 A 4,4 0,0,1 416,136" class="nofill"></path>
    <polygon points="352,164 360,164 356,176" class="filled"></polygon>
  </g>
  <g>
    <line x1="264" y1="120" x2="296" y2="120" class="solid"></line>
    <polygon points="296,116 304,120 296,124" class="filled"></polygon>
  </g>
  <g>
    <path d="M 288,168 A 4,4 0,0,0 284,172" class="nofill"></path>
    <line x1="284" y1="172" x2="284" y2="196" class="solid"></line>
    <line x1="288" y1="168" x2="352" y2="168" class="solid"></line>
    <path d="M 284,196 A 4,4 0,0,0 288,200" class="nofill"></path>
    <line x1="288" y1="200" x2="456" y2="200" class="solid"></line>
    <line x1="356" y1="200" x2="356" y2="224" class="solid"></line>
    <line x1="404" y1="200" x2="404" y2="228" class="solid"></line>
    <path d="M 404,228 A 4,4 0,0,0 408,232" class="nofill"></path>
    <line x1="408" y1="232" x2="488" y2="232" class="solid"></line>
    <path d="M 488,232 A 4,4 0,0,1 492,236" class="nofill"></path>
    <line x1="492" y1="236" x2="492" y2="272" class="solid"></line>
    <line x1="360" y1="168" x2="456" y2="168" class="solid"></line>
    <path d="M 456,168 A 4,4 0,0,1 460,172" class="nofill"></path>
    <line x1="460" y1="172" x2="460" y2="196" class="solid"></line>
    <path d="M 460,196 A 4,4 0,0,1 456,200" class="nofill"></path>
  </g>
  <g>
    <line x1="356" y1="240" x2="356" y2="260" class="solid"></line>
    <polygon points="352,260 360,260 356,272" class="filled"></polygon>
  </g>
  <g>
    <path d="M 288,264 A 4,4 0,0,0 284,268" class="nofill"></path>
    <line x1="284" y1="268" x2="284" y2="292" class="solid"></line>
    <line x1="288" y1="264" x2="352" y2="264" class="solid"></line>
    <path d="M 284,292 A 4,4 0,0,0 288,296" class="nofill"></path>
    <line x1="288" y1="296" x2="432" y2="296" class="solid"></line>
    <line x1="360" y1="264" x2="432" y2="264" class="solid"></line>
    <path d="M 432,264 A 4,4 0,0,1 436,268" class="nofill"></path>
    <line x1="436" y1="268" x2="436" y2="292" class="solid"></line>
    <path d="M 436,292 A 4,4 0,0,1 432,296" class="nofill"></path>
  </g>
  <g>
    <line x1="492" y1="288" x2="492" y2="324" class="solid"></line>
    <polygon points="488,324 496,324 492,336" class="filled"></polygon>
  </g>
  <g>
    <path d="M 424,328 A 4,4 0,0,0 420,332" class="nofill"></path>
    <line x1="420" y1="332" x2="420" y2="356" class="solid"></line>
    <line x1="424" y1="328" x2="488" y2="328" class="solid"></line>
    <path d="M 420,356 A 4,4 0,0,0 424,360" class="nofill"></path>
    <line x1="424" y1="360" x2="568" y2="360" class="solid"></line>
    <line x1="496" y1="328" x2="568" y2="328" class="solid"></line>
    <path d="M 568,328 A 4,4 0,0,1 572,332" class="nofill"></path>
    <line x1="572" y1="332" x2="572" y2="356" class="solid"></line>
    <path d="M 572,356 A 4,4 0,0,1 568,360" class="nofill"></path>
  </g>
</svg></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="tuirs-history"><a class="header" href="#tuirs-history">tui.rs history</a></h1>
<p>This project was forked from <a href="https://github.com/fdehau/tui-rs/"><code>tui-rs</code></a> in February 2023, with
the <a href="https://github.com/fdehau/tui-rs/issues/654">blessing of the original author</a>, Florian Dehau
(<a href="https://github.com/fdehau">@fdehau</a>).</p>
<p>The original repository contains all the issues, PRs and discussion that were raised originally, and
it is useful to refer to when contributing code, documentation, or issues with Ratatui.</p>
<p>We imported all the PRs from the original repository and implemented many of the smaller ones and
made notes on the leftovers. These are marked as draft PRs and labelled as
<a href="https://github.com/ratatui-org/ratatui/pulls?q=is%3Apr+is%3Aopen+label%3A%22imported+from+tui%22">imported from tui</a>.
We have documented the current state of those PRs, and anyone is welcome to pick them up and
continue the work on them.</p>
<p>We have not imported all issues opened on the previous repository. For that reason, anyone wanting
to <strong>work on or discuss</strong> an issue will have to follow the following workflow:</p>
<ul>
<li>Recreate the issue</li>
<li>Start by referencing the <strong>original issue</strong>:
<code>Referencing issue #[&lt;issue number&gt;](&lt;original issue link&gt;)</code></li>
<li>Then, paste the original issues <strong>opening</strong> text</li>
</ul>
<p>You can then resume the conversation by replying to the new issue you have created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v0240"><a class="header" href="#v0240"><a href="https://github.com/ratatui-org/ratatui/releases/tag/v0.24.0">v0.24.0</a></a></h1>
<p>‚ö†Ô∏è We created a <a href="https://github.com/ratatui-org/ratatui/blob/main/BREAKING-CHANGES.md">breaking changes</a> document for easily going through the breaking changes in each version.</p>
<h2 id="ratatui-websitebook-"><a class="header" href="#ratatui-websitebook-">Ratatui Website/Book üìö</a></h2>
<p>The site you are browsing right now (<code>ratatui.rs</code>) is the new homepage of <code>ratatui</code>!
For now, we host the book here which contains a bunch of useful tutorials, concepts and FAQ sections and there
is a <a href="https://github.com/ratatui-org/ratatui-book/issues/115">plan</a> to create a landing page <a href="https://github.com/ratatui-org/ratatui-book/pull/116">pretty soon</a>!</p>
<p>All the code is available at <a href="https://github.com/ratatui-org/ratatui-book">https://github.com/ratatui-org/ratatui-book</a></p>
<hr />
<h2 id="frame-no-more-generics-"><a class="header" href="#frame-no-more-generics-">Frame: no more generics üö´</a></h2>
<p>If you were using the <code>Frame</code> type with a <code>Backend</code> parameter before:</p>
<pre><code class="language-rust">fn draw&lt;B: Backend&gt;(frame: &amp;mut Frame&lt;B&gt;) {
    // ...
}</code></pre>
<hr />
<p>You no longer need to provide a generic over backend (<code>B</code>):</p>
<pre><code class="language-rust">fn draw(frame: &amp;mut Frame) {
    // ...
}</code></pre>
<hr />
<h2 id="new-demo--examples-"><a class="header" href="#new-demo--examples-">New Demo / Examples ‚ú®</a></h2>
<p>We have a new kick-ass demo!</p>
<p><img src="https://raw.githubusercontent.com/ratatui-org/ratatui/aa09e59dc0058347f68d7c1e0c91f863c6f2b8c9/examples/demo2.gif" alt="demo2" /></p>
<p>To try it out:</p>
<pre><code class="language-sh">cargo run --example=demo2 --features=&quot;crossterm widget-calendar&quot;
</code></pre>
<blockquote>
<p>The code is available <a href="https://github.com/ratatui-org/ratatui/tree/main/examples/demo2">here</a>.</p>
</blockquote>
<p>We also have a new example demonstrating how to create a custom widget.</p>
<p><img src="https://raw.githubusercontent.com/ratatui-org/ratatui/images/examples/custom_widget.gif" alt="custom widget" /></p>
<pre><code class="language-sh">cargo run --example=custom_widget --features=crossterm
</code></pre>
<blockquote>
<p>The code is available <a href="https://github.com/ratatui-org/ratatui/blob/main/examples/custom_widget.rs">here</a>.</p>
</blockquote>
<p>Lastly, we added an example to demonstrate RGB color options:</p>
<p><img src="https://raw.githubusercontent.com/ratatui-org/ratatui/images/examples/colors_rgb.png" alt="RGB colors" /></p>
<pre><code class="language-sh">cargo run --example=colors_rgb --features=crossterm
</code></pre>
<blockquote>
<p>The code is available <a href="https://github.com/ratatui-org/ratatui/blob/main/examples/colors_rgb.rs">here</a>.</p>
</blockquote>
<hr />
<h2 id="window-size-api-"><a class="header" href="#window-size-api-">Window Size API ü™ü</a></h2>
<p>A new method called <code>window_size</code> is added for retrieving the window size.
It returns a struct called <code>WindowSize</code> that contains both pixels (width, height) and columns/rows
information.</p>
<pre><code class="language-rust">let stdout = std::io::stdout();
let mut backend = CrosstermBackend::new(stdout);
println!(&quot;{:#?}&quot;, backend.window_size()?;</code></pre>
<p>Outputs:</p>
<pre><code>WindowSize {
    columns_rows: Size {
        width: 240,
        height: 30,
    },
    pixels: Size {
        width: 0,
        height: 0,
    },
}
</code></pre>
<p>With this new API, the goal is to improve image handling in terminal emulators
by sharing terminal size and layout information,
enabling precise image placement and resizing within rectangles.</p>
<p>See the pull request for more information:
<a href="https://github.com/ratatui-org/ratatui/pull/276">https://github.com/ratatui-org/ratatui/pull/276</a></p>
<hr />
<h2 id="barchart-render-smol-charts-"><a class="header" href="#barchart-render-smol-charts-">BarChart: Render <em>smol</em> charts üìä</a></h2>
<p>We had a bug where the <code>BarChart</code> widget doesn‚Äôt render labels that are full width.
Now this is fixed and we are able to render charts smaller than 3 lines!</p>
<p>For example, here is how <code>BarChart</code> is rendered and resized from a single line to 4 lines in order:</p>
<pre><code>  ‚ñÅ ‚ñÇ ‚ñÉ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá 8


  ‚ñÅ ‚ñÇ ‚ñÉ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá 8
a b c d e f g h i

  ‚ñÅ ‚ñÇ ‚ñÉ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá 8
a b c d e f g h i
      Group

          ‚ñÇ ‚ñÑ ‚ñÜ ‚ñà
  ‚ñÇ ‚ñÑ ‚ñÜ 4 5 6 7 8
a b c d e f g h i
      Group
</code></pre>
<p>If you set <code>bar_width(2)</code> for 3 lines, then it is rendered as:</p>
<pre><code>          ‚ñÇ ‚ñÑ ‚ñÜ ‚ñà
  ‚ñÇ ‚ñÑ ‚ñÜ 4 5 6 7 8
a b c d e f g h i
      Group
</code></pre>
<hr />
<h2 id="block-custom-symbols-for-borders-"><a class="header" href="#block-custom-symbols-for-borders-">Block: custom symbols for borders üõ°Ô∏è</a></h2>
<p>The <code>Block</code> widget has a new method called <code>border_set</code> that can be used to specify the symbols that are
going to be used for the borders.</p>
<pre><code class="language-rust">Block::default()
    .borders(Borders::ALL)
    .border_set(border::Set {
        top_left: &quot;1&quot;,
        top_right: &quot;2&quot;,
        bottom_left: &quot;3&quot;,
        bottom_right: &quot;4&quot;,
        vertical_left: &quot;L&quot;,
        vertical_right: &quot;R&quot;,
        horizontal_top: &quot;T&quot;,
        horizontal_bottom: &quot;B&quot;,
    })</code></pre>
<p>When rendered:</p>
<pre><code>1TTTTTTTTTTTTT2
L             R
3BBBBBBBBBBBBB4
</code></pre>
<p>There are also 2 new border types added (<code>QuadrantInside</code>, <code>QuadrantOutside</code>).</p>
<p>See the available border types at <a href="https://docs.rs/ratatui/latest/ratatui/widgets/block/enum.BorderType.html">https://docs.rs/ratatui/latest/ratatui/widgets/block/enum.BorderType.html</a></p>
<p>Also, there are breaking changes to note here:</p>
<ul>
<li><code>BorderType::to_line_set</code> is renamed to <code>to_border_set</code></li>
<li><code>BorderType::line_symbols</code> is renamed to <code>border_symbols</code></li>
</ul>
<hr />
<h2 id="canvas-half-block-marker-"><a class="header" href="#canvas-half-block-marker-">Canvas: half block marker üñºÔ∏è</a></h2>
<p>A new marker named <code>HalfBlock</code> is added to <code>Canvas</code> widget along with the associated
<code>HalfBlockGrid</code>.</p>
<p>The idea is to use half blocks to draw a grid
of ‚Äúpixels‚Äù on the screen. Because we can set two colors per cell, and
because terminal cells are about twice as tall as they are wide, we can
draw a grid of half blocks that looks like a grid of square pixels.</p>
<pre><code class="language-rust">Canvas::default()
    .marker(Marker::HalfBlock)
    .x_bounds([0.0, 10.0])
    .y_bounds([0.0, 10.0])
    .paint(|context| {
        context.draw(&amp;Rectangle {
            x: 0.0,
            y: 0.0,
            width: 10.0,
            height: 10.0,
            color: Color::Red,
        });
    });</code></pre>
<p>Rendered as:</p>
<pre><code>‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà        ‚ñà
‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà
</code></pre>
<hr />
<h2 id="line-raw-constructor-"><a class="header" href="#line-raw-constructor-">Line: raw constructor üìù</a></h2>
<p>You can simply construct <code>Line</code> widgets from strings using <code>raw</code> (similar to <code>Span::raw</code> and
<code>Text::raw</code>):</p>
<pre><code class="language-rust">let line = Line::raw(&quot;test content&quot;);</code></pre>
<p>One thing to note here is that multi-line content is converted to multiple spans with the new lines removed.</p>
<hr />
<h2 id="rect-is-empty-"><a class="header" href="#rect-is-empty-">Rect: is empty? üõçÔ∏è</a></h2>
<p>With the newly added <code>is_empty</code> method, you can check if a <code>Rect</code> has any area or not:</p>
<pre><code class="language-rust">assert!(!Rect::new(1, 2, 3, 4).is_empty());
assert!(Rect::new(1, 2, 0, 4).is_empty());
assert!(Rect::new(1, 2, 3, 0).is_empty());</code></pre>
<hr />
<h2 id="layout-lru-cache-"><a class="header" href="#layout-lru-cache-">Layout: LRU cache üìö</a></h2>
<p>The layout cache now uses a <a href="https://docs.rs/lru/latest/lru/struct.LruCache.html"><code>LruCache</code></a> with default size set to 16 entries.
Previously the cache was backed by a <code>HashMap</code>, and was able to grow
without bounds as a new entry was added for every new combination of
layout parameters.</p>
<p>We also added a new method called <code>init_cache</code> for changing the cache size if necessary:</p>
<pre><code class="language-rust">Layout::init_cache(10);</code></pre>
<p>This will only have an effect if it is called prior to any calls to <code>layout::split()</code>.</p>
<hr />
<h2 id="backend-optional-underline-colors-"><a class="header" href="#backend-optional-underline-colors-">Backend: optional underline colors üé®</a></h2>
<p>Windows 7 doesn‚Äôt support the underline color attribute, so we need to make it optional. For that,
we added a feature fla called <code>underline-color</code> and enabled it as default.</p>
<p>It can be disabled as follows for applications that supports Windows 7:</p>
<pre><code class="language-toml">ratatui = { version = &quot;0.24.0&quot;, default-features = false, features = [&quot;crossterm&quot;] }
</code></pre>
<hr />
<h2 id="stylized-strings-"><a class="header" href="#stylized-strings-">Stylized strings ‚ú®</a></h2>
<p>Although the <a href="https://docs.rs/ratatui/latest/ratatui/style/trait.Stylize.html"><code>Stylize</code></a> trait is already implemented for <code>&amp;str</code> which
extends to <code>String</code>, it is not implemented for <code>String</code> itself.</p>
<p>So we added an implementation of <code>Stylize</code> for <code>String</code> that returns <code>Span&lt;'static&gt;</code> which makes the
following code compile just fine instead of failing with a temporary value error:</p>
<pre><code class="language-rust">let s = format!(&quot;hello {name}!&quot;, &quot;world&quot;).red();</code></pre>
<p>This may break some code that expects to call <code>Stylize</code>
methods on <code>String</code> values and then use the String value later.
For example, following code will now fail to compile because the <code>String</code> is consumed by <code>set_style</code>
instead of a slice being created and consumed.</p>
<pre><code class="language-rust">let s = String::from(&quot;hello world&quot;);
let line = Line::from(vec![s.red(), s.green()]); // fails to compile</code></pre>
<p>Simply clone the <code>String</code> to fix the compilation error:</p>
<pre><code class="language-rust">let s = String::from(&quot;hello world&quot;);
let line = Line::from(vec![s.clone().red(), s.green()]);</code></pre>
<hr />
<h2 id="spans-rip-"><a class="header" href="#spans-rip-">Spans: RIP üíÄ</a></h2>
<p>The <code>Spans</code> was deprecated and replaced with a more ergonomic <code>Line</code> type in 0.21.0 and now it is
removed.</p>
<p>Long live <code>Line</code>!</p>
<hr />
<h2 id="other-"><a class="header" href="#other-">Other üíº</a></h2>
<ul>
<li>Simplified the internal implementation of <code>BarChart</code> and add benchmarks</li>
<li>Add documentation to various places including <code>Block</code>, <code>Gauge</code>, <code>Table</code>, <code>BarChart</code>, etc.</li>
<li>Used modern modules syntax throughout the codebase (<code>xxx/mod.rs</code> -&gt; <code>xxx.rs</code>)</li>
<li>Added <code>buffer_mut</code> method to <code>Frame</code></li>
<li>Integrated <code>Dependabot</code> for dependency updates and bump dependencies</li>
<li>Refactored examples</li>
<li>Fixed arithmetic overflow edge cases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v0230"><a class="header" href="#v0230"><a href="https://github.com/ratatui-org/ratatui/releases/tag/v0.23.0">v0.23.0</a></a></h1>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="highlights/v0.23.html#admonition-note"></a></p>
</div>
<div>
<p>reposted from <a href="https://blog.orhun.dev/ratatui-0-23-0/">https://blog.orhun.dev/ratatui-0-23-0/</a></p>
</div>
</div>
<h2 id="coolify-everything-"><a class="header" href="#coolify-everything-">Coolify everything üòé</a></h2>
<p>We already had a cool name and a logo, and now we have a cool description as well:</p>
<pre><code class="language-diff">- ratatui: A Rust library to build rich terminal user interfaces or dashboards.
+ ratatui: A Rust library that's all about cooking up terminal user interfaces.
</code></pre>
<p>We also renamed our organization from <code>tui-rs-revival</code> to <code>ratatui-org</code>:</p>
<ul>
<li><a href="https://github.com/ratatui-org/ratatui"><strong>https://github.com/ratatui-org/ratatui</strong></a></li>
</ul>
<h2 id="barchart-horizontal-bars"><a class="header" href="#barchart-horizontal-bars">Barchart: horizontal bars</a></h2>
<p>You can now render the bars horizontally for the <code>Barchart</code> widget. This is especially useful in
some cases to make more efficient use of the available space.</p>
<p>Simply use the <code>Direction</code> attribute for rendering horizontal bars:</p>
<pre><code class="language-rs">let mut barchart = BarChart::default()
    .block(Block::default().title(&quot;Data1&quot;).borders(Borders::ALL))
    .bar_width(1)
    .group_gap(1)
    .bar_gap(0)
    .direction(Direction::Horizontal);
</code></pre>
<p>Here is an example of what you can do with the <code>Barchart</code> widget (see the bottom right for
horizontal bars):</p>
<p><img src="https://user-images.githubusercontent.com/15311024/263077132-ff80b2c4-9d2d-480b-9a72-f3779688bec8.png" alt="horizontal bars" /></p>
<hr />
<h2 id="voluntary-skipping-capability-for-sixel"><a class="header" href="#voluntary-skipping-capability-for-sixel">Voluntary skipping capability for Sixel</a></h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Sixel">Sixel</a> is a bitmap graphics format supported by terminals.
‚ÄúSixel mode‚Äù is entered by sending the sequence <code>ESC+Pq</code>. The ‚ÄúString Terminator‚Äù sequence <code>ESC+\</code>
exits the mode.</p>
</blockquote>
<p><code>Cell</code> widget now has a <code>set_skip</code> method that allows the cell to be skipped when copying (diffing)
the buffer to the screen. This is helpful when it is necessary to prevent the buffer from
overwriting a cell that is covered by an image from some terminal graphics protocol such as Sixel,
iTerm, Kitty, etc.</p>
<p>See the pull request for more information:
<a href="https://github.com/ratatui-org/ratatui/pull/215">https://github.com/ratatui-org/ratatui/pull/215</a></p>
<p>In this context, there is also an experimental image rendering crate:
<a href="https://github.com/benjajaja/ratatui-image"><em>ratatui-image</em></a></p>
<p><img src="https://raw.githubusercontent.com/benjajaja/ratatu-image/master/assets/Recording.gif" alt="ratatui-image" /></p>
<hr />
<h2 id="tablelist-highlight-spacing"><a class="header" href="#tablelist-highlight-spacing">Table/List: Highlight spacing</a></h2>
<p>We added a new property called <code>HighlightSpacing</code> to the <code>Table</code> and <code>List</code> widgets and it can be
optionally set via calling <code>highlight_spacing</code> function.</p>
<p>Before this option was available, selecting a row in the table when no row was selected previously
made the tables layout change (the same applies to unselecting) by adding the width of the
‚Äúhighlight symbol‚Äù in the front of the first column. The idea is that we want this behaviour to be
configurable with this newly added option.</p>
<pre><code class="language-rs">let list = List::new(items)
    .highlight_symbol(&quot;&gt;&gt;&quot;)
    .highlight_spacing(HighlightSpacing::Always);
</code></pre>
<p>Right now, there are 3 variants:</p>
<ul>
<li><code>Always</code>: Always add spacing for the selection symbol column.</li>
<li><code>WhenSelected</code>: Only add spacing for the selection symbol column if a row is selected.</li>
<li><code>Never</code>: Never add spacing to the selection symbol column, regardless of whether something is
selected or not.</li>
</ul>
<hr />
<h2 id="table-support-line-alignment"><a class="header" href="#table-support-line-alignment">Table: support line alignment</a></h2>
<pre><code class="language-rs">let table = Table::new(vec![
        Row::new(vec![Line::from(&quot;Left&quot;).alignment(Alignment::Left)]),
        Row::new(vec![Line::from(&quot;Center&quot;).alignment(Alignment::Center)]),
        Row::new(vec![Line::from(&quot;Right&quot;).alignment(Alignment::Right)]),
    ])
    .widths(&amp;[Constraint::Percentage(100)]);
</code></pre>
<p>Now results in:</p>
<pre><code class="language-text">Left
       Center
               Right
</code></pre>
<hr />
<h2 id="scrollbar-optional-track-symbol"><a class="header" href="#scrollbar-optional-track-symbol">Scrollbar: optional track symbol</a></h2>
<p>The track symbol in the <code>Scrollbar</code> is now optional, simplifying composition with other widgets. It
also makes it easier to use the <code>Scrollbar</code> in tandem with a block with special block characters.</p>
<p>One breaking change is that <code>track_symbol</code> needs to be set in the following way now:</p>
<pre><code class="language-diff">-let scrollbar = Scrollbar::default().track_symbol(&quot;-&quot;);
+let scrollbar = Scrollbar::default().track_symbol(Some(&quot;-&quot;));
</code></pre>
<p>It also makes it possible to render a custom track that is composed out of multiple differing track
symbols.</p>
<hr />
<h2 id="symbolsscrollbar-module"><a class="header" href="#symbolsscrollbar-module"><code>symbols::scrollbar</code> module</a></h2>
<p>The symbols and sets are moved from <code>widgets::scrollbar</code> to <code>symbols::scrollbar</code>. This makes it
consistent with the other symbol sets. We also made the <code>scrollbar</code> module private.</p>
<p>Since this is a breaking change, you need to update your code to add an import for
<code>ratatui::symbols::scrollbar::*</code> (or the specific symbols you need).</p>
<hr />
<h2 id="alpha-releases"><a class="header" href="#alpha-releases">Alpha releases</a></h2>
<p>The alpha releases (i.e. pre-releases) are created *every Saturday* and they are automated with
the help of
<a href="https://github.com/ratatui-org/ratatui/blob/main/.github/workflows/cd.yml">this GitHub Actions workflow</a>.
This is especially useful if you want to test <code>ratatui</code> or use unstable/experimental features before
we hit a stable release.</p>
<p>The versioning scheme is <code>v&lt;version&gt;-alpha.&lt;num&gt;</code>, for example:
<a href="https://github.com/ratatui-org/ratatui/releases/tag/v0.22.1-alpha.2">v0.22.1-alpha.2</a></p>
<p>Additionally, see the following issue for possible contributions in the context of alpha releases
and documentation:
<a href="https://github.com/ratatui-org/ratatui/issues/412">https://github.com/ratatui-org/ratatui/issues/412</a></p>
<hr />
<h2 id="example-gifs"><a class="header" href="#example-gifs">Example GIFs</a></h2>
<p>We added GIFs for each example in the <code>examples/</code> directory and added a <code>README.md</code> for preview.
This should make it easier to see what each example does without having to run it.</p>
<p>See:
<a href="https://github.com/ratatui-org/ratatui/blob/main/examples/README.md"><strong>https://github.com/ratatui-org/ratatui/blob/main/examples/README.md</strong></a></p>
<p>One thing to note here is that we used <a href="https://github.com/charmbracelet/vhs">vhs</a> for generating
GIFs from a set of instructions. For example:</p>
<pre><code class="language-ini"># This is a vhs script. See https://github.com/charmbracelet/vhs for more info.
# To run this script, install vhs and run `vhs ./examples/demo.tape`
Output &quot;target/demo.gif&quot;
Set Theme &quot;OceanicMaterial&quot;
Set Width 1200
Set Height 1200
Set PlaybackSpeed 0.5
Hide
Type &quot;cargo run --example demo&quot;
Enter
Sleep 2s
Show
Sleep 1s
Down@1s 12
Right
Sleep 4s
Right
Sleep 4s
</code></pre>
<p>Results in:</p>
<p><img src="https://camo.githubusercontent.com/a7c42a61ca3400569b2ebc1543a6f35e03fb09ba86e855137687b54f27b71038/68747470733a2f2f7668732e636861726d2e73682f7668732d7446305162755062744867556547307354566746722e676966" alt="ratatui demo" /></p>
<p>We also host these GIFs at <a href="https://vhs.charm.sh">https://vhs.charm.sh</a> but there is an issue about
moving everything to GitHub. If you are interested in contributing regarding this, see
<a href="https://github.com/ratatui-org/ratatui/issues/401">https://github.com/ratatui-org/ratatui/issues/401</a></p>
<hr />
<h2 id="common-traits"><a class="header" href="#common-traits">Common traits</a></h2>
<p>With the help of <a href="https://crates.io/crates/strum">strum</a> crate, we added <code>Display</code> and <code>FromStr</code>
implementation to enum types.</p>
<p>Also, we implemented common traits such as <code>Debug</code>, <code>Default</code>, <code>Clone</code>, <code>Copy</code>, <code>Eq</code>, <code>PartialEq</code>,
<code>Ord</code>, <code>PartialOrd</code>, <code>Hash</code> to the structs/enums where possible.</p>
<hr />
<h2 id="test-coverage-"><a class="header" href="#test-coverage-">Test coverage üß™</a></h2>
<p><code>ratatui</code> now has <a href="https://app.codecov.io/gh/ratatui-org/ratatui">90% test coverage</a>!</p>
<p>Shoutout to everyone who added tests/benchmarks for various widgets made this possible.</p>
<hr />
<h2 id="no-unsafe-"><a class="header" href="#no-unsafe-">No unsafe ‚ö†Ô∏è</a></h2>
<p>We now <em>forbid</em> <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">unsafe code</a> in <code>ratatui</code>.
Also, see <a href="https://github.com/ratatui-org/ratatui/discussions/66">this discussion</a> we had in the
past about using <code>unsafe</code> code for optimization purposes.</p>
<hr />
<h2 id="the-book-"><a class="header" href="#the-book-">The book üìï</a></h2>
<p>We are working on a book for more in-depth <code>ratatui</code> documentation and usage examples, you can read
it from here:
<a href="https://ratatui-org.github.io/ratatui-book/">https://ratatui-org.github.io/ratatui-book/</a></p>
<p>Repository:
<a href="https://github.com/ratatui-org/ratatui-book"><strong>https://github.com/ratatui-org/ratatui-book</strong></a></p>
<hr />
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<ul>
<li>Expand serde attributes for <code>TestBuffer</code> for de/serializing the whole test buffer.</li>
<li>Add weak constraints to make <code>Rect</code>s closer to each other in size.</li>
<li>Simplify <code>Layout::split</code> function.</li>
<li>Various bug fixes and improvements in Barchart, Block, Layout and other widgets.</li>
<li>Add documentation to various widgets and improve existing documentation.</li>
<li>Add examples for colors and modifiers.</li>
<li>We created a Matrix bridge at <a href="https://matrix.to/#/#ratatui:matrix.org">#ratatui:matrix.org</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v022"><a class="header" href="#v022"><a href="https://github.com/ratatui-org/ratatui/releases/tag/v0.22.0">v0.22</a></a></h1>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="highlights/v0.22.html#admonition-note"></a></p>
</div>
<div>
<p>reposted from <a href="https://blog.orhun.dev/ratatui-0-22-0/">https://blog.orhun.dev/ratatui-0-22-0/</a></p>
</div>
</div>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>We now have a <code>prelude</code> module! This allows users of the library to easily use <code>ratatui</code> without a
huge amount of imports.</p>
<pre><code class="language-rs">use ratatui::prelude::*;
</code></pre>
<p>Aside from the main types that are used in the library, this <code>prelude</code> also re-exports several
modules to make it easy to qualify types that would otherwise collide. For example:</p>
<pre><code class="language-rs">use ratatui::{prelude::*, widgets::*};

#[derive(Debug, Default, PartialEq, Eq)]
struct Line;

assert_eq!(Line::default(), Line);
assert_eq!(text::Line::default(), ratatui::text::Line::from(vec![]));
</code></pre>
<hr />
<h2 id="new-widget-scrollbar"><a class="header" href="#new-widget-scrollbar">New widget: Scrollbar</a></h2>
<p>A scrollbar widget has been added which can be used with any <code>Rect</code>. It can also be customized with
different styles and symbols.</p>
<p>Here are the components of a <code>Scrollbar</code>:</p>
<pre><code class="language-plain">&lt;--‚ñÆ-------&gt;
^  ^   ^   ^
‚îÇ  ‚îÇ   ‚îÇ   ‚îî end
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ track
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ thumb
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ begin
</code></pre>
<p>To use it, render it as a stateful widget along with <code>ScrollbarState</code>:</p>
<pre><code class="language-rs">frame.render_stateful_widget(
    Scrollbar::default()
        .orientation(ScrollbarOrientation::VerticalRight)
        .begin_symbol(Some(&quot;‚Üë&quot;))
        .end_symbol(Some(&quot;‚Üì&quot;)),
    rect,
    &amp;mut scrollbar_state,
);
</code></pre>
<p>Will result in:</p>
<pre><code class="language-plain">‚îåscrollbar‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üë
‚îÇThis is a longer line      ‚ïë
‚îÇVeeeeeeeeeeeeeeeery    looo‚ñà
‚îÇThis is a line             ‚ïë
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üì
</code></pre>
<hr />
<h2 id="block-support-multiple-titles"><a class="header" href="#block-support-multiple-titles">Block: support multiple titles</a></h2>
<p><code>Block</code> widget now supports having more than one title via <code>Title</code> widget.</p>
<p>Each title will be rendered with a single space separating titles that are in the same position or
alignment. When both centered and non-centered titles are rendered, the centered space is calculated
based on the full width of the block, rather than the leftover width.</p>
<p>You can provide various types as the title, including strings, string slices, borrowed strings
(<code>Cow&lt;str&gt;</code>), spans, or vectors of spans (<code>Vec&lt;Span&gt;</code>).</p>
<p>It can be used as follows:</p>
<pre><code class="language-rs">Block::default()
    .borders(Borders::ALL)
    .title(&quot;Title&quot;) // By default in the top right corner
    .title(Title::from(&quot;Left&quot;).alignment(Alignment::Left))
    .title(Title::from(&quot;Center&quot;).alignment(Alignment::Center))
    .title(Title::from(&quot;Bottom&quot;).position(Position::Bottom))
    .title(
        Title::from(&quot;Bottom center&quot;)
            .alignment(Alignment::Center)
            .position(Position::Bottom),
    );
</code></pre>
<p>Results in:</p>
<pre><code class="language-plain">‚îåTitle‚îÄLeft‚îÄ‚îÄCenter‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                               ‚îÇ
‚îÇ                               ‚îÇ
‚îÇ                               ‚îÇ
‚îîBottom‚îÄ‚îÄ‚îÄBottom center‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h2 id="barchart-support-groups"><a class="header" href="#barchart-support-groups">Barchart: support groups</a></h2>
<p><code>Barchart</code> has been improved to support adding multiple bars from different data sets. This can be
done by using the newly added <code>Bar</code> and <code>BarGroup</code> objects.</p>
<p>See the <a href="https://github.com/ratatui-org/ratatui/blob/main/examples/barchart.rs">barchart example</a>
for more information and implementation details.</p>
<hr />
<h2 id="stylization-shorthands"><a class="header" href="#stylization-shorthands">Stylization shorthands</a></h2>
<p>It is possible to use style shorthands for <code>str</code>, <code>Span</code>, and <code>Paragraph</code>.</p>
<p>A crazy example would be:</p>
<pre><code class="language-rs">&quot;hello&quot;
    .on_black()
    .black()
    .bold()
    .underline()
    .dimmed()
    .slow_blink()
    .crossed_out()
    .reversed()
</code></pre>
<p>This especially helps with concise styling:</p>
<pre><code class="language-rs">assert_eq!(
  &quot;hello&quot;.red().on_blue().bold(),
  Span::styled(&quot;hello&quot;, Style::default().fg(Color::Red).bg(Color::Blue).add_modifier(Modifier::BOLD))
)
</code></pre>
<hr />
<h2 id="stylize-everything"><a class="header" href="#stylize-everything">Stylize everything</a></h2>
<p>All widgets can be styled now (i.e. <code>set_style</code>)</p>
<p><code>Styled</code> trait is implemented for all the remaining widgets, including:</p>
<ul>
<li><code>Barchart</code></li>
<li><code>Chart</code> (including <code>Axis</code> and <code>Dataset</code>)</li>
<li><code>Gauge</code> and <code>LineGauge</code></li>
<li><code>List</code> and <code>ListItem</code></li>
<li><code>Sparkline</code></li>
<li><code>Table</code>, <code>Row</code>, and <code>Cell</code></li>
<li><code>Tabs</code></li>
<li><code>Style</code></li>
</ul>
<hr />
<h2 id="constant-styles"><a class="header" href="#constant-styles">Constant styles</a></h2>
<p><code>Style</code>s can be constructed in a <code>const</code> context as follows:</p>
<pre><code class="language-rs">const DEFAULT_MODIFIER: Modifier = Modifier::BOLD.union(Modifier::ITALIC);
const EMPTY: Modifier = Modifier::empty();

const DEFAULT_STYLE: Style = Style::with(DEFAULT_MODIFIER, EMPTY)
    .fg(Color::Red)
    .bg(Color::Black);
</code></pre>
<hr />
<h2 id="more-colors-formats"><a class="header" href="#more-colors-formats">More colors formats</a></h2>
<p>It is now possible to parse hyphenated color names like <code>light-red</code> via <code>Color::from_str</code>.</p>
<p>Additionally, all colors from the
<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI color table</a> are supported (though some
names are not exactly the same).</p>
<ul>
<li><code>gray</code> is sometimes called <code>white</code> - this is not supported as we use <code>white</code> for bright white</li>
<li><code>gray</code> is sometimes called <code>silver</code> - this is supported</li>
<li><code>darkgray</code> is sometimes called <code>light black</code> or <code>bright black</code> (both are supported)</li>
<li><code>white</code> is sometimes called <code>light white</code> or <code>bright white</code> (both are supported)</li>
<li>we support <code>bright</code> and <code>light</code> prefixes for all colors</li>
<li>we support <code>&quot;-&quot;</code>, <code>&quot;_&quot;</code>, and <code>&quot; &quot;</code> as separators for all colors</li>
<li>we support both <code>gray</code> and <code>grey</code> spellings</li>
</ul>
<p>For example:</p>
<pre><code class="language-rs">use ratatui::style::Color;
use std::str::FromStr;

assert_eq!(Color::from_str(&quot;red&quot;), Ok(Color::Red));
assert_eq!(&quot;red&quot;.parse(), Ok(Color::Red));
assert_eq!(&quot;lightred&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;light red&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;light-red&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;light_red&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;lightRed&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;bright red&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;bright-red&quot;.parse(), Ok(Color::LightRed));
assert_eq!(&quot;silver&quot;.parse(), Ok(Color::Gray));
assert_eq!(&quot;dark-grey&quot;.parse(), Ok(Color::DarkGray));
assert_eq!(&quot;dark gray&quot;.parse(), Ok(Color::DarkGray));
assert_eq!(&quot;light-black&quot;.parse(), Ok(Color::DarkGray));
assert_eq!(&quot;white&quot;.parse(), Ok(Color::White));
assert_eq!(&quot;bright white&quot;.parse(), Ok(Color::White));
</code></pre>
<hr />
<h2 id="integrations"><a class="header" href="#integrations">Integrations</a></h2>
<p>Following tools are now integrated into the repository:</p>
<ul>
<li><a href="https://github.com/rhysd/cargo-husky"><code>cargo-husky</code></a>: git pre-push hooks</li>
<li><a href="https://github.com/Canop/bacon"><code>bacon</code></a>: background code checks / coverage</li>
<li><a href="https://github.com/commitizen/cz-cli"><code>commitizen</code></a>: conventional commits</li>
<li><a href="https://github.com/EmbarkStudios/cargo-deny"><code>cargo-deny</code></a>: linting dependencies</li>
<li><a href="https://github.com/crate-ci/typos"><code>typos</code></a>: spell checker</li>
</ul>
<hr />
<h2 id="other-1"><a class="header" href="#other-1">Other</a></h2>
<ul>
<li>Benchmarks added for the <code>Paragraph</code> widget</li>
<li>Added underline colors support for <code>crossterm</code> backend</li>
<li>Mark some of the low-level functions of <code>Block</code>, <code>Layout</code> and <code>Rect</code> as <code>const</code></li>
<li>The project license has been updated to acknowledge <code>ratatui</code> developers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v021"><a class="header" href="#v021"><a href="https://github.com/ratatui-org/ratatui/releases/tag/v0.21.0">v0.21</a></a></h1>
<h2 id="new-backend-termwiz"><a class="header" href="#new-backend-termwiz">New backend: <code>termwiz</code></a></h2>
<p><code>ratatui</code> supports a new backend called <code>termwiz</code> which is a ‚ÄúTerminal Wizardry‚Äù crate that powers
<a href="https://github.com/wez/wezterm">wezterm</a>.</p>
<p>To use it, enable the <code>termwiz</code> feature in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies.ratatui]
version = &quot;0.21.0&quot;
features = [&quot;termwiz&quot;]
default-features = false
</code></pre>
<p>Then you can utilize <code>TermwizBackend</code> object for creating a terminal. Here is a simple program that
shows a text on the screen for 5 seconds using <code>ratatui</code> + <code>termwiz</code>:</p>
<pre><code class="language-rs">use ratatui::{backend::TermwizBackend, widgets::Paragraph, Terminal};
use std::{
    error::Error,
    thread,
    time::{Duration, Instant},
};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let backend = TermwizBackend::new()?;
    let mut terminal = Terminal::new(backend)?;
    terminal.hide_cursor()?;

    let now = Instant::now();
    while now.elapsed() &lt; Duration::from_secs(5) {
        terminal.draw(|f| f.render_widget(Paragraph::new(&quot;termwiz example&quot;), f.size()))?;
        thread::sleep(Duration::from_millis(250));
    }

    terminal.show_cursor()?;
    terminal.flush()?;
    Ok(())
}
</code></pre>
<hr />
<h2 id="new-widget-calendar"><a class="header" href="#new-widget-calendar">New widget: Calendar</a></h2>
<p>A calendar widget has been added which was originally a part of the
<a href="https://github.com/sophacles/extra-widgets">extra-widgets</a> repository.</p>
<p>Since this new widget depends on <code>time</code> crate, we gated it behind <code>widget-calendar</code> feature to avoid
an extra dependency:</p>
<pre><code class="language-toml">[dependencies.ratatui]
version = &quot;0.21.0&quot;
features = [&quot;widget-calendar&quot;]
</code></pre>
<p>Here is the example usage:</p>
<pre><code class="language-rs">Monthly::new(
    time::Date::from_calendar_date(2023, time::Month::January, 1).unwrap(),
    CalendarEventStore::default(),
)
.show_weekdays_header(Style::default())
.show_month_header(Style::default())
.show_surrounding(Style::default()),
</code></pre>
<p>Results in:</p>
<pre><code class="language-plain">     January 2023
 Su Mo Tu We Th Fr Sa
  1  2  3  4  5  6  7
  8  9 10 11 12 13 14
 15 16 17 18 19 20 21
 22 23 24 25 26 27 28
 29 30 31  1  2  3  4
</code></pre>
<hr />
<h2 id="new-widget-circle"><a class="header" href="#new-widget-circle">New widget: Circle</a></h2>
<p><code>Circle</code> widget has been added with the use-case of showing an accuracy radius on the world map.</p>
<p>Here is an example of how to use it with <code>Canvas</code>:</p>
<pre><code class="language-rs">Canvas::default()
    .paint(|ctx| {
        ctx.draw(&amp;Circle {
            x: 5.0,
            y: 2.0,
            radius: 5.0,
            color: Color::Reset,
        });
    })
    .marker(Marker::Braille)
    .x_bounds([-10.0, 10.0])
    .y_bounds([-10.0, 10.0]),
</code></pre>
<p>Results in:</p>
<pre><code class="language-plain"> ‚°†‚†§‚¢§‚°Ä
‚¢∏‚°Å  ‚°ß
 ‚†ë‚†í‚†ö‚†Å
</code></pre>
<hr />
<h2 id="inline-viewport"><a class="header" href="#inline-viewport">Inline Viewport</a></h2>
<p>This was a highly requested feature and the original implementation was done by
<a href="https://github.com/fdehau">@fdehau</a> himself. Folks at <a href="https://atuin.sh">Atuin</a> completed the
implementation and we are happy to finally have this incorporated in the new release!</p>
<p>An inline viewport refers to a rectangular section of the terminal window that is set aside for
displaying content.</p>
<p>In the repository, there is an example that simulates downloading multiple files in parallel:
<a href="https://github.com/ratatui-org/ratatui/blob/main/examples/inline.rs">https://github.com/ratatui-org/ratatui/blob/main/examples/inline.rs</a></p>
<hr />
<h2 id="block-title-on-bottom"><a class="header" href="#block-title-on-bottom">Block: title on bottom</a></h2>
<blockquote>
<p>Before you could only put the title on the top row of a Block. Now you can put it on the bottom
row! Revolutionary.</p>
</blockquote>
<p>For example, place the title on the bottom and center:</p>
<pre><code class="language-rs">Paragraph::new(&quot;ratatui&quot;)
    .alignment(Alignment::Center)
    .block(
        Block::default()
            .title(Span::styled(&quot;Title&quot;, Style::default()))
            .title_on_bottom()
            .title_alignment(Alignment::Center)
            .borders(Borders::ALL),
    )
</code></pre>
<p>Results in:</p>
<pre><code class="language-plain">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       ratatui       ‚îÇ
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄTitle‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h2 id="block-support-adding-padding"><a class="header" href="#block-support-adding-padding">Block: support adding padding</a></h2>
<p>If we want to render a widget inside a <code>Block</code> with a certain distance from its borders, we need to
create another <code>Layout</code> element based on the outer <code>Block</code>, add a margin and render the <code>Widget</code>
into it. Adding a padding property on the block element skips the creation of this second Layout.</p>
<p>This property works especially when rendering texts, as we can just create a block with padding and
use it as the text wrapper:</p>
<pre><code class="language-rs">let block = Block::default()
    .borders(Borders::ALL)
    .padding(Padding::new(1, 1, 2, 2));
let paragraph = Paragraph::new(&quot;example paragraph&quot;).block(block);
f.render_widget(paragraph, area);
</code></pre>
<p>Rendering another widget should be easy too, using the <code>.inner</code> method:</p>
<pre><code class="language-rs">let block = Block::default().borders(Borders::ALL).padding(Padding {
    left: todo!(),
    right: todo!(),
    top: todo!(),
    bottom: todo!(),
});
let inner_block = Block::default().borders(Borders::ALL);
let inner_area = block.inner(area);

f.render_widget(block, area);
f.render_widget(inner_block, inner_area);
f.render_widget(paragraph, area);
</code></pre>
<hr />
<h2 id="text-display-secure-data"><a class="header" href="#text-display-secure-data">Text: display secure data</a></h2>
<p>A new type called <code>Masked</code> is added for text-related types for masking data with a mask character.
The example usage is as follows:</p>
<pre><code class="language-rs">Line::from(vec![
    Span::raw(&quot;Masked text: &quot;),
    Span::styled(
        Masked::new(&quot;password&quot;, '*'),
        Style::default().fg(Color::Red),
    ),
])
</code></pre>
<p>Results in:</p>
<pre><code class="language-plain">Masked text: ********
</code></pre>
<hr />
<h2 id="border-macro"><a class="header" href="#border-macro"><code>border!</code> macro</a></h2>
<p>A <code>border!</code> macro has been added that takes <code>TOP</code>, <code>BOTTOM</code>, <code>LEFT</code>, <code>RIGHT</code>, and <code>ALL</code> and returns
a <code>Borders</code> object.</p>
<p>An empty <code>border!()</code> call returns <code>NONE</code>.</p>
<p>For example:</p>
<pre><code class="language-rs">border!(ALL)
border!(LEFT, RIGHT)
border!()
</code></pre>
<p>This is gated behind a <code>macros</code> feature flag to ensure short build times. To enable it, update
<code>Cargo.toml</code> as follows:</p>
<pre><code class="language-toml">[dependencies.ratatui]
version = &quot;0.21.0&quot;
features = [&quot;macros&quot;]
</code></pre>
<p>Going forward, we will most likely put the new macros behind <code>macros</code> feature as well.</p>
<hr />
<h2 id="color-support-conversion-from-string"><a class="header" href="#color-support-conversion-from-string">Color: support conversion from <code>String</code></a></h2>
<p>Have you ever needed this conversion?</p>
<pre><code class="language-rs">&quot;black&quot; =&gt; Color::Black,
&quot;red&quot; =&gt; Color::Red,
&quot;green&quot; =&gt; Color::Green,
// etc.
</code></pre>
<p>Don‚Äôt worry, we got you covered:</p>
<pre><code class="language-rs">Color::from_str(&quot;lightblue&quot;) // Color::LightBlue
Color::from_str(&quot;10&quot;)        // Color::Indexed(10)
Color::from_str(&quot;#FF0000&quot;)   // Color::Rgb(255, 0, 0)
</code></pre>
<hr />
<h2 id="spans---line"><a class="header" href="#spans---line"><code>Spans</code> -&gt; <code>Line</code></a></h2>
<p><code>Line</code> is a significantly better name over <code>Spans</code> as the plural causes confusion and the type
really is a representation of a line of text made up of spans.</p>
<p>So, <code>Spans</code> is renamed as <code>Line</code> and a deprecation notice has been added.</p>
<p>See
<a href="https://github.com/ratatui-org/ratatui/pull/178">https://github.com/ratatui-org/ratatui/pull/178</a>
for more discussion.</p>
<hr />
<h2 id="other-features"><a class="header" href="#other-features">Other features</a></h2>
<ul>
<li><code>List</code> now has a <code>len()</code> method for returning the number of items</li>
<li><code>Sparkline</code> now has a <code>direction()</code> method for specifying the render direction (left to right /
right to left)</li>
<li><code>Table</code> and <code>List</code> states now have <code>offset()</code> and <code>offset_mut()</code> methods</li>
<li>Expose the test buffer (<code>TestBackend</code>) with <code>Display</code> implementation</li>
</ul>
<hr />
<h2 id="new-apps"><a class="header" href="#new-apps">New apps</a></h2>
<p>Here is the list of applications that has been added:</p>
<ul>
<li><a href="https://github.com/BrookJeynes/oxycards">oxycards</a>: quiz card application built within the
terminal.</li>
<li><a href="https://github.com/Xithrius/twitch-tui">twitch-tui</a>: twitch chat in the terminal.</li>
<li><a href="https://github.com/pythops/tenere">tenere</a>: TUI interface for LLMs.</li>
</ul>
<p>Also, we moved <code>APPS.md</code> file to the
<a href="https://github.com/ratatui-org/ratatui/wiki/Apps-using-Ratatui">Wiki</a> so check it out for more
applications built with <code>ratatui</code>!</p>
<hr />
<h2 id="migration-from-tui-rs"><a class="header" href="#migration-from-tui-rs">Migration from <code>tui-rs</code></a></h2>
<p>We put together a migration guide at the Wiki:
<a href="highlights/./../how-to/develop-apps/migrate-from-tui-rs.html">Migrating from TUI</a></p>
<p>Also, the minimum supported Rust version is <code>1.65.0</code></p>
<hr />
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Any contribution is highly appreciated! There are
<a href="https://github.com/ratatui-org/ratatui/blob/main/CONTRIBUTING.md">contribution guidelines</a> for
getting started.</p>
<p>Feel free to <a href="https://github.com/ratatui-org/ratatui/issues/new/choose">submit issues</a> and throw in
ideas!</p>
<p>If you are having a problem with <code>ratatui</code> or want to contribute to the project or just want to
chit-chat, feel free to <a href="https://discord.gg/pMCEU9hNEj">join our Discord server</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li><a href="https://docs.rs/ratatui/latest/ratatui/">Crate Docs</a></li>
<li><a href="https://github.com/ratatui-org/rust-tui-template">Starter Template</a></li>
<li><a href="https://github.com/ratatui-org/ratatui-async-template">Starter Async Tokio Template</a></li>
</ul>
<h2 id="apps-using-ratatui"><a class="header" href="#apps-using-ratatui"><a href="https://github.com/ratatui-org/ratatui/wiki/Apps-using-Ratatui">Apps using <code>ratatui</code></a></a></h2>
<p>Here you will find a list of TUI applications that are made using <code>ratatui</code> and <code>tui</code>.</p>
<ul>
<li><a href="references/index.html#-development-tools">üíª Development Tools</a></li>
<li><a href="references/index.html#-games-and-entertainment">üïπÔ∏è Games and Entertainment</a></li>
<li><a href="references/index.html#-productivity-and-utilities">üöÄ Productivity and Utilities</a></li>
<li><a href="references/index.html#-music-and-media">üéº Music and Media</a></li>
<li><a href="references/index.html#-networking-and-internet">üåê Networking and Internet</a></li>
<li><a href="references/index.html#-system-administration">üë®‚Äçüíª System Administration</a></li>
<li><a href="references/index.html#-other">üåå Other</a></li>
</ul>
<p>Aside from those listed here, many other apps and libraries can be easily be found via the reverse
dependencies on crates.io and GitHub:</p>
<ul>
<li><a href="https://crates.io/crates/ratatui/reverse_dependencies">https://crates.io/crates/ratatui/reverse_dependencies</a></li>
<li><a href="https://crates.io/crates/tui/reverse_dependencies">https://crates.io/crates/tui/reverse_dependencies</a></li>
<li><a href="https://github.com/ratatui-org/ratatui/network/dependents">https://github.com/ratatui-org/ratatui/network/dependents</a></li>
<li><a href="https://github.com/fdehau/tui-rs/network/dependents?package_id=UGFja2FnZS0zMjE3MzkzMDMx">https://github.com/fdehau/tui-rs/network/dependents?package_id=UGFja2FnZS0zMjE3MzkzMDMx</a></li>
</ul>
<h3 id="-development-tools"><a class="header" href="#-development-tools">üíª Development Tools</a></h3>
<ul>
<li><a href="https://github.com/SoptikHa2/desed">desed</a>: Debugging tool for sed scripts</li>
<li><a href="https://github.com/extrawurst/gitui">gitui</a>: Terminal UI for Git</li>
<li><a href="https://github.com/TaKO8Ki/gobang">gobang</a>: Cross-platform TUI database management tool</li>
<li><a href="https://github.com/kamiyaa/joshuto">joshuto</a>: Ranger-like terminal file manager written in Rust</li>
<li><a href="https://github.com/acheronfail/repgrep">repgrep</a>: An interactive replacer for ripgrep that makes
it easy to find and replace across files on the command line</li>
<li><a href="https://github.com/pythops/tenere">tenere</a>: TUI interface for LLMs written in Rust</li>
<li><a href="https://github.com/JosephLai241/nomad">nomad</a>: Customizable next-gen tree command with Git
integration and TUI</li>
</ul>
<h3 id="-games-and-entertainment"><a class="header" href="#-games-and-entertainment">üïπÔ∏è Games and Entertainment</a></h3>
<ul>
<li><a href="https://github.com/deepu105/battleship-rs">Battleship.rs</a>: Terminal-based Battleship game</li>
<li><a href="https://github.com/kachark/game-of-life-rs">game-of-life-rs</a>: Conway‚Äôs Game of Life implemented
in Rust and visualized with tui-rs</li>
<li><a href="https://github.com/BrookJeynes/oxycards">oxycards</a>: Quiz card application built within the
terminal</li>
<li><a href="https://github.com/cpcloud/minesweep-rs">minesweep</a>: Terminal-based Minesweeper game</li>
<li><a href="https://github.com/24seconds/rust-sadari-cli">rust-sadari-cli</a>: rust sadari game based on
terminal! (Ghost leg or Amidakuji in another words)</li>
<li><a href="https://github.com/thomas-mauran/tic-tac-toe">tic-tac-toe</a>: Terminal-based tic tac toe game</li>
</ul>
<h3 id="-productivity-and-utilities"><a class="header" href="#-productivity-and-utilities">üöÄ Productivity and Utilities</a></h3>
<ul>
<li><a href="https://github.com/imsnif/diskonaut">diskonaut</a>: Terminal-based disk space navigator</li>
<li><a href="https://github.com/heyrict/exhaust">exhaust</a>: Exhaust all your possibilities.. for the next
coming exam</li>
<li><a href="https://github.com/orhun/gpg-tui">gpg-tui</a>: Manage your GnuPG keys with ease!</li>
<li><a href="https://github.com/woxjro/lazy-etherscan">lazy-etherscan</a>: A Simple Terminal UI for the Ethereum
Blockchain Explorer</li>
<li><a href="https://github.com/16arpi/meteo-tui">meteo-tui</a>: French weather app in the command line</li>
<li><a href="https://github.com/aryakaul/rusty-krab-manager">rusty-krab-manager</a>: time management tui in rust</li>
<li><a href="https://github.com/kdheepak/taskwarrior-tui">taskwarrior-tui</a>: TUI for the Taskwarrior
command-line task manager</li>
<li><a href="https://github.com/tarkah/tickrs">tickrs</a>: Stock market ticker in the terminal</li>
<li><a href="https://github.com/lesleyrs/tts-tui">tts-tui</a>: Text to speech app that reads from clipboard</li>
<li><a href="https://github.com/moali87/jirust">Jirust</a>: A Jira TUI</li>
<li><a href="https://github.com/konradsz/igrep">igrep</a>: Interactive Grep</li>
<li><a href="https://github.com/ebubekirgungor/todolist-rust">todolist-rust</a>: A terminal-based simple to-do
app</li>
</ul>
<h3 id="-music-and-media"><a class="header" href="#-music-and-media">üéº Music and Media</a></h3>
<ul>
<li><a href="https://github.com/glicol/glicol-cli">glicol-cli</a>: Cross-platform music live coding in terminal</li>
<li><a href="https://github.com/Rigellute/spotify-tui">spotify-tui</a>: Spotify client for the terminal</li>
<li><a href="https://github.com/Xithrius/twitch-tui">twitch-tui</a>: Twitch chat in the terminal</li>
<li><a href="https://github.com/sudipghimire533/ytui-music">ytui-music</a>: Listen to music from YouTube in the
terminal</li>
</ul>
<h3 id="-networking-and-internet"><a class="header" href="#-networking-and-internet">üåê Networking and Internet</a></h3>
<ul>
<li><a href="https://github.com/wcampbell0x2a/adsb_deku#radar-tui">adsb_deku/radar</a>: TUI for displaying ADS-B
data from aircraft</li>
<li><a href="https://github.com/Lissy93/AdGuardian-Term">AdGuardian-Term</a>: Real-time traffic monitoring and
statistics for AdGuard Home</li>
<li><a href="https://github.com/imsnif/bandwhich">bandwhich</a>: Displays network utilization by process</li>
<li><a href="https://github.com/mrusme/conclusive">conclusive</a>: A command line client for Plausible Analytics</li>
<li><a href="https://github.com/orf/gping/">gping</a>: Ping tool with a graph</li>
<li><a href="https://github.com/EdJoPaTo/mqttui">mqttui</a>: MQTT client for subscribing or publishing to topics</li>
<li><a href="https://github.com/hatoo/oha">oha</a>: Top-like monitoring tool for HTTP(S) traffic</li>
<li><a href="https://github.com/wojciech-zurek/rrtop">rrtop</a>: Rust Redis monitoring (top like) app.</li>
<li><a href="https://github.com/veeso/termscp">termscp</a>: A feature rich terminal UI file transfer and explorer
with support for SCP/SFTP/FTP/S3/SMB</li>
<li><a href="https://github.com/fujiapple852/trippy">trippy</a>: Network diagnostic tool</li>
<li><a href="https://github.com/kamiyaa/tsuchita">tsuchita</a>: client-server notification center for dbus
desktop notifications</li>
<li><a href="https://github.com/vectordotdev/vector">vector</a>: A high-performance observability data pipeline</li>
<li><a href="https://github.com/gabrieldemian/vincenzo">vincenzo</a>: A bittorrent client for the terminal with
vim-like keybindings</li>
</ul>
<h3 id="-system-administration"><a class="header" href="#-system-administration">üë®‚Äçüíª System Administration</a></h3>
<ul>
<li><a href="https://github.com/ClementTsang/bottom">bottom</a>: Cross-platform graphical process/system monitor</li>
<li><a href="https://github.com/kdash-rs/kdash">kdash</a>: A simple and fast dashboard for Kubernetes</li>
<li><a href="https://github.com/orhun/kmon">kmon</a>: Linux Kernel Manager and Activity Monitor</li>
<li><a href="https://github.com/imuxin/kubectl-watch">kubectl-watch</a>: A kubectl plugin to provide a pretty
delta change view of being watched kubernetes resources</li>
<li><a href="https://github.com/sarub0b0/kubetui">kubetui</a>: TUI for real-time monitoring of Kubernetes
resources</li>
<li><a href="https://github.com/todoesverso/logss">logss</a>: A simple cli for logs splitting</li>
<li><a href="https://github.com/mrjackwills/oxker">oxker</a>: Simple TUI to view &amp; control docker containers</li>
<li><a href="https://github.com/graelo/pumas">pumas</a>: Power Usage Monitor for Apple Silicon</li>
<li><a href="https://github.com/orhun/systeroid">systeroid</a>: A more powerful alternative to sysctl(8) with a
terminal user interface</li>
<li><a href="https://github.com/sayanarijit/xplr">xplr</a>: Hackable, minimal, and fast TUI file explorer</li>
<li><a href="https://github.com/cjbassi/ytop">ytop</a>: TUI system monitor for Linux</li>
<li><a href="https://github.com/bvaisvil/zenith">zenith</a>: Cross-platform monitoring tool for system stats</li>
</ul>
<h3 id="-other"><a class="header" href="#-other">üåå Other</a></h3>
<ul>
<li><a href="https://github.com/replydev/cotp">cotp</a>: Command-line TOTP/HOTP authenticator app</li>
<li><a href="https://github.com/paarthmadan/cube">cube timer</a>: A tui for cube timing, written in Rust</li>
<li><a href="https://github.com/kaixinbaba/hg-tui">hg-tui</a>: TUI for viewing the hellogithub.com website</li>
<li><a href="https://github.com/blacknon/hwatch">hwatch</a>: Alternative watch command with command history and
diffs</li>
<li><a href="https://github.com/ckaznable/poketex">poketex</a>: Simple Pokedex based on TUI</li>
<li><a href="https://github.com/lemunozm/termchat">termchat</a>: Terminal chat through the LAN with video
streaming and file transfer</li>
</ul>
<h2 id="third-party-crates"><a class="header" href="#third-party-crates"><a href="https://github.com/ratatui-org/ratatui#third-party-libraries-bootstrapping-templates-and-widgets">Third Party Crates</a></a></h2>
<ul>
<li><a href="https://github.com/uttarayan21/ansi-to-tui">ansi-to-tui</a> ‚Äî Convert ansi colored text to
<code>ratatui::text::Text</code></li>
<li><a href="https://github.com/uttarayan21/color-to-tui">color-to-tui</a> ‚Äî Parse hex colors to
<code>ratatui::style::Color</code></li>
<li><a href="https://github.com/ratatui-org/rust-tui-template">rust-tui-template</a> ‚Äî A template for
bootstrapping a Rust TUI application with Tui-rs &amp; crossterm</li>
<li><a href="https://github.com/pmsanford/simple-tui-rs">simple-tui-rs</a> ‚Äî A simple example tui-rs app</li>
<li><a href="https://github.com/jkelleyrtp/tui-builder">tui-builder</a> ‚Äî Batteries-included MVC framework for
Tui-rs + Crossterm apps</li>
<li><a href="https://github.com/kegesch/tui-clap-rs">tui-clap</a> ‚Äî Use clap-rs together with Tui-rs</li>
<li><a href="https://github.com/kegesch/tui-log-rs">tui-log</a> ‚Äî Example of how to use logging with Tui-rs</li>
<li><a href="https://github.com/gin66/tui-logger">tui-logger</a> ‚Äî Logger and Widget for Tui-rs</li>
<li><a href="https://github.com/veeso/tui-realm">tui-realm</a> ‚Äî Tui-rs framework to build stateful applications
with a React/Elm inspired approach</li>
<li><a href="https://github.com/veeso/tui-realm-treeview">tui-realm-treeview</a> ‚Äî Treeview component for
Tui-realm</li>
<li><a href="https://github.com/EdJoPaTo/tui-rs-tree-widget">tui-rs-tree-widgets</a>: Widget for tree data
structures.</li>
<li><a href="https://github.com/markatk/tui-windows-rs">tui-windows</a> ‚Äî Tui-rs abstraction to handle multiple
windows and their rendering</li>
<li><a href="https://github.com/rhysd/tui-textarea">tui-textarea</a>: Simple yet powerful multi-line text editor
widget supporting several key shortcuts, undo/redo, text search, etc.</li>
<li><a href="https://github.com/sayanarijit/tui-input">tui-input</a>: TUI input library supporting multiple
backends and tui-rs.</li>
<li><a href="https://github.com/a-kenji/tui-term">tui-term</a>: A pseudoterminal widget library that enables the
rendering of terminal applications as ratatui widgets.</li>
<li><a href="https://github.com/joshka/tui-big-text">tui-big-text</a>: A Rust crate that renders large pixel text
as a ratatui widget using the glyphs from the font8x8 crate.</li>
<li><a href="https://github.com/Canop/crokey/">crokey</a>: Crokey helps incorporate configurable keybindings in
crossterm based terminal applications by providing functions to handle key combinations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="showcase"><a class="header" href="#showcase">Showcase</a></h1>
<h2 id="scope-tui"><a class="header" href="#scope-tui"><a href="https://github.com/alemidev/scope-tui"><code>scope-tui</code></a></a></h2>
<p>A simple oscilloscope/vectorscope/spectroscope for your terminal</p>
<p><img src="https://camo.githubusercontent.com/144d96875a367bd55d8cc2343da2479aefea9925106b71d9e73aa9bebc57c33f/68747470733a2f2f63646e2e616c656d692e6465762f73636f70652d7475692d776964652e706e67" alt="" /></p>
<hr />
<h2 id="gitui"><a class="header" href="#gitui"><a href="https://github.com/extrawurst/gitui"><code>gitui</code></a></a></h2>
<p>TUI for git written in rust</p>
<p><img src="https://github.com/extrawurst/gitui/blob/master/demo.gif?raw=true" alt="" /></p>
<hr />
<h2 id="bottom"><a class="header" href="#bottom"><a href="https://github.com/ClementTsang/bottom/"><code>bottom</code></a></a></h2>
<p>A customizable cross-platform graphical process/system monitor for the terminal</p>
<p><img src="https://github.com/ClementTsang/bottom/blob/master/assets/demo.gif?raw=true" alt="" /></p>
<hr />
<h2 id="xplr"><a class="header" href="#xplr"><a href="https://github.com/sayanarijit/xplr"><code>xplr</code></a></a></h2>
<p>A hackable, minimal, fast TUI file explorer</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/QJaEMeVo9Uw?si=3mzY7GZ1ZuLuiMCr" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<hr />
<h2 id="yazi"><a class="header" href="#yazi"><a href="https://yazi-rs.github.io/docs"><code>yazi</code></a></a></h2>
<p>Blazing fast terminal file manager written in Rust, based on async I/O</p>
<p><a href="https://yazi-rs.github.io/docs/showcase">Showcase</a></p>
<hr />
<h2 id="joshuto"><a class="header" href="#joshuto"><a href="https://github.com/kamiyaa/joshuto"><code>joshuto</code></a></a></h2>
<p>ranger-like terminal file manager written in Rust</p>
<p><img src="https://github.com/kamiyaa/joshuto/raw/main/screenshot.png?raw=true" alt="" /></p>
<hr />
<h2 id="taskwarrior-tui"><a class="header" href="#taskwarrior-tui"><a href="https://github.com/kdheepak/taskwarrior-tui"><code>taskwarrior-tui</code></a></a></h2>
<p>A terminal user interface for taskwarrior</p>
<p><img src="https://user-images.githubusercontent.com/1813121/159858280-3ca31e9a-fc38-4547-a92d-36a7758cf5dc.gif" alt="" /></p>
<hr />
<h2 id="bandwich"><a class="header" href="#bandwich"><a href="https://github.com/imsnif/bandwhich"><code>bandwich</code></a></a></h2>
<p>This is a CLI utility for displaying current network utilization by process, connection and remote IP/hostname</p>
<p><img src="https://github.com/imsnif/bandwhich/raw/main/demo.gif?raw=true" alt="" /></p>
<hr />
<h2 id="oha"><a class="header" href="#oha"><a href="https://github.com/hatoo/oha/"><code>oha</code></a></a></h2>
<p>oha is a tiny program that sends some load to a web application and show realtime tui</p>
<p><img src="https://github.com/hatoo/oha/blob/master/demo.gif?raw=true" alt="" /></p>
<hr />
<h2 id="gpg-tui"><a class="header" href="#gpg-tui"><a href="https://github.com/orhun/gpg-tui"><code>gpg-tui</code></a></a></h2>
<p>gpg-tui is a Terminal User Interface for GnuPG.</p>
<p><img src="https://github.com/orhun/gpg-tui/blob/master/demo/gpg-tui-scrolling_rows.gif?raw=true" alt="" /></p>
<hr />
<h2 id="atuin"><a class="header" href="#atuin"><a href="https://github.com/atuinsh/atuin"><code>atuin</code></a></a></h2>
<p>Atuin replaces your existing shell history with a SQLite database, and records additional context for your commands.</p>
<p><img src="https://github.com/atuinsh/atuin/blob/main/demo.gif?raw=true" alt="" /></p>
<hr />
<h2 id="minesweep-rs"><a class="header" href="#minesweep-rs"><a href="https://github.com/cpcloud/minesweep-rs"><code>minesweep-rs</code></a></a></h2>
<p>A mine sweeping game written in Rust</p>
<p><img src="https://github.com/cpcloud/minesweep-rs/blob/main/demo.gif?raw=true" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>As ratatui grows and evolves, this list may change, so make sure to check the
<a href="https://github.com/ratatui-org/ratatui">main repo</a> if you are unsure.</p>
<h2 id="backend-selection"><a class="header" href="#backend-selection">Backend Selection</a></h2>
<p>For most cases, the default <code>crossterm</code> backend is the correct choice. See
<a href="references/../concepts/backends">Backends</a> for more information. However, this can be changed to termion or termwiz</p>
<pre><code class="language-shell"># Defaults to crossterm
cargo add ratatui

# For termion, unset the default crossterm feature and select the termion feature
cargo add ratatui --no-default-features --features=terminon
cargo add termion

# For termwiz, unset the default crossterm feature and select the termwiz feature
cargo add ratatui --no-default-features --features=termwiz
cargo add termwiz
</code></pre>
<h2 id="all-widgets"><a class="header" href="#all-widgets">All-Widgets</a></h2>
<p>This feature enables some extra widgets that are not in <code>default</code> to save on compile time. As of
v0.21, the only widget in this feature group is the <code>calendar</code> widget, which can be enabled with the
<code>widget-calendar</code> feature.</p>
<pre><code class="language-shell">cargo add ratatui --features all-widgets
</code></pre>
<h2 id="widget-calendar"><a class="header" href="#widget-calendar">Widget-Calendar</a></h2>
<p>This feature enables the calendar widget, which requires the <code>time</code> crate.</p>
<pre><code class="language-shell">cargo add ratatui --features widget-calendar
</code></pre>
<h2 id="serde"><a class="header" href="#serde">Serde</a></h2>
<pre><code class="language-shell">cargo add ratatui --features serde
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ratatui-1"><a class="header" href="#ratatui-1">Ratatui</a></h1>
<p>Check out the <a href="https://github.com/ratatui-org/ratatui/blob/main/CONTRIBUTING.md">CONTRIBUTING GUIDE</a>
for more information.</p>
<h2 id="keep-prs-small-intentional-and-focused"><a class="header" href="#keep-prs-small-intentional-and-focused">Keep PRs small, intentional and focused</a></h2>
<p>Try to do one pull request per change. The time taken to review a PR grows exponential with the size
of the change. Small focused PRs will generally be much more faster to review. PRs that include both
refactoring (or reformatting) with actual changes are more difficult to review as every line of the
change becomes a place where a bug may have been introduced. Consider splitting refactoring /
reformatting changes into a separate PR from those that make a behavioral change, as the tests help
guarantee that the behavior is unchanged.</p>
<h2 id="search-tui-rs-for-similar-work"><a class="header" href="#search-tui-rs-for-similar-work">Search <code>tui-rs</code> for similar work</a></h2>
<p>The original fork of Ratatui, <a href="https://github.com/fdehau/tui-rs/"><code>tui-rs</code></a>, has a large amount of
history of the project. Please search, read, link, and summarize any relevant
<a href="https://github.com/fdehau/tui-rs/issues/">issues</a>,
<a href="https://github.com/fdehau/tui-rs/discussions/">discussions</a> and
<a href="https://github.com/fdehau/tui-rs/pulls">pull requests</a>.</p>
<h2 id="use-conventional-commits"><a class="header" href="#use-conventional-commits">Use conventional commits</a></h2>
<p>We use <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commits</a> and check for them as
a lint build step. To help adhere to the format, we recommend to install
<a href="https://commitizen-tools.github.io/commitizen/">Commitizen</a>. By using this tool you automatically
follow the configuration defined in .cz.toml. Your commit messages should have enough
information to help someone reading the CHANGELOG understand what is new just from
the title. The summary helps expand on that to provide information that helps provide more context,
describes the nature of the problem that the commit is solving and any unintuitive effects of the
change. It‚Äôs rare that code changes can easily communicate intent, so make sure this is clearly
documented.</p>
<h2 id="clean-up-your-commits"><a class="header" href="#clean-up-your-commits">Clean up your commits</a></h2>
<p>The final version of your PR that will be committed to the repository should be rebased and tested
against main. Every commit will end up as a line in the changelog, so please squash commits that are
only formatting or incremental fixes to things brought up as part of the PR review. Aim for a single
commit (unless there is a strong reason to stack the commits). See
<a href="https://sethrobertson.github.io/GitBestPractices/#sausage">Git Best Practices - On Sausage Making</a>
for more on this.</p>
<h2 id="run-ci-tests-before-pushing-a-pr"><a class="header" href="#run-ci-tests-before-pushing-a-pr">Run CI tests before pushing a PR</a></h2>
<p>We‚Äôre using <a href="https://github.com/rhysd/cargo-husky">cargo-husky</a> to automatically run git hooks,
which will run <code>cargo make ci</code> before each push. To initialize the hook run <code>cargo test</code>. If
<code>cargo-make</code> is not installed, it will provide instructions to install it for you. This will ensure
that your code is formatted, compiles and passes all tests before you push. If you need to skip this
check, you can use <code>git push --no-verify</code>.</p>
<h2 id="sign-your-commits"><a class="header" href="#sign-your-commits">Sign your commits</a></h2>
<p>We use commit signature verification, which will block commits from being merged via the UI unless
they are signed. To set up your machine to sign commits, see
<a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">managing commit signature verification</a>
in GitHub docs.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Clone the repo and build it using <a href="https://sagiegurari.github.io/cargo-make/">cargo-make</a></p>
<p>Ratatui is an ordinary Rust project where common tasks are managed with
<a href="https://github.com/sagiegurari/cargo-make/">cargo-make</a>. It wraps common <code>cargo</code> commands with sane
defaults depending on your platform of choice. Building the project should be as easy as running
<code>cargo make build</code>.</p>
<pre><code class="language-shell">git clone https://github.com/ratatui-org/ratatui.git
cd ratatui
cargo make build
</code></pre>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>The <a href="https://app.codecov.io/gh/ratatui-org/ratatui">test coverage</a> of the crate is reasonably good,
but this can always be improved. Focus on keeping the tests simple and obvious and write unit tests
for all new or modified code. Beside the usual doc and unit tests, one of the most valuable test you
can write for Ratatui is a test against the <code>TestBackend</code>. It allows you to assert the content of
the output buffer that would have been flushed to the terminal after a given draw call. See
<code>widgets_block_renders</code> in tests/widgets_block.rs for an example.</p>
<p>When writing tests, generally prefer to write unit tests and doc tests directly in the code file
being tested rather than integration tests in the <code>tests/</code> folder.</p>
<p>If an area that you‚Äôre making a change in is not tested, write tests to characterize the existing
behavior before changing it. This helps ensure that we don‚Äôt introduce bugs to existing software
using Ratatui (and helps make it easy to migrate apps still using <code>tui-rs</code>).</p>
<p>For coverage, we have two <a href="https://dystroy.org/bacon/">bacon</a> jobs (one for all tests, and one for
unit tests, keyboard shortcuts <code>v</code> and <code>u</code> respectively) that run
<a href="https://github.com/taiki-e/cargo-llvm-cov">cargo-llvm-cov</a> to report the coverage. Several plugins
exist to show coverage directly in your editor. E.g.:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters</a></li>
<li><a href="https://github.com/alepez/vim-llvmcov">https://github.com/alepez/vim-llvmcov</a></li>
</ul>
<h2 id="use-of-unsafe-for-optimization-purposes"><a class="header" href="#use-of-unsafe-for-optimization-purposes">Use of unsafe for optimization purposes</a></h2>
<p>We don‚Äôt currently use any unsafe code in Ratatui, and would like to keep it that way. However there
may be specific cases that this becomes necessary in order to avoid slowness. Please see
<a href="https://github.com/ratatui-org/ratatui/discussions/66">this discussion</a> for more about the
decision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ratatui-book"><a class="header" href="#ratatui-book">Ratatui Book</a></h1>
<p>The <a href="https://github.com/ratatui-org/ratatui-book">ratatui-book</a> is written in
<a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a>.</p>
<p>The book is built as HTML pages as part of a
<a href="https://github.com/ratatui-org/ratatui-book/blob/main/.github/workflows/mdbook.yml">GitHub Action</a>
and is available to view at <a href="https://ratatui-org.github.io/ratatui-book/">https://ratatui-org.github.io/ratatui-book/</a>.</p>
<p>Feel free to make contributions if you‚Äôd like to improve the documentation.</p>
<p>If you want to set up your local environment, you can run the following:</p>
<pre><code class="language-bash">cargo install mdbook --version 0.4.35
cargo install mdbook-admonish --version 1.13.0
cargo install mdbook-svgbob2 --version 0.3.0
cargo install mdbook-linkcheck --version 0.7.7
cargo install mdbook-mermaid --version 0.12.6
cargo install mdbook-emojicodes --version 0.2.2
cargo install mdbook-catppuccin --version 2.0.1
</code></pre>
<p>These plugins allow additional features.</p>
<h2 id="mdbook-admonish"><a class="header" href="#mdbook-admonish"><code>mdbook-admonish</code></a></h2>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```admonish note
This is a note
```

```admonish tip
This is a tip
```

```admonish warning
This is a warning
```

```admonish info
This is a info
```
</code></pre>
<p>will render as the following:</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-note"></a></p>
</div>
<div>
<p>This is a note</p>
</div>
</div>
<div id="admonition-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-tip"></a></p>
</div>
<div>
<p>This is a tip</p>
</div>
</div>
<div id="admonition-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-warning"></a></p>
</div>
<div>
<p>This is a warning</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-info"></a></p>
</div>
<div>
<p>This is a info</p>
</div>
</div>
<h2 id="mdbook-mermaid"><a class="header" href="#mdbook-mermaid"><code>mdbook-mermaid</code></a></h2>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```mermaid
graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
```
</code></pre>
<p>will render as the following:</p>
<pre class="mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</pre>
<h2 id="mdbook-svgbob2"><a class="header" href="#mdbook-svgbob2"><code>mdbook-svgbob2</code></a></h2>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```svgbob
       .---.
      /-o-/--
   .-/ / /-&gt;
  ( *  \/
   '-.  \
      \ /
       '
```
</code></pre>
<p>will render as the following:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="112" height="128">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="112" height="128"></rect>
  <circle cx="68" cy="24" r="3" class="nofill"></circle>
  <line x1="72" y1="24" x2="104" y2="24" class="solid"></line>
  <circle cx="36" cy="56" r="3" class="filled"></circle>
  <g>
    <path d="M 64,8 A 8,8 0,0,0 58,12" class="nofill"></path>
    <line x1="58" y1="12" x2="38" y2="52" class="solid"></line>
    <line x1="64" y1="8" x2="88" y2="8" class="solid"></line>
    <path d="M 88,8 A 3,3 0,0,1 90,12" class="nofill"></path>
    <line x1="90" y1="12" x2="64" y2="64" class="solid"></line>
    <line x1="52" y1="24" x2="64" y2="24" class="solid"></line>
    <line x1="76" y1="40" x2="88" y2="40" class="solid"></line>
    <polygon points="88,36 96,40 88,44" class="filled"></polygon>
    <line x1="66" y1="28" x2="56" y2="48" class="solid"></line>
    <line x1="56" y1="48" x2="72" y2="80" class="solid"></line>
    <path d="M 32,40 A 8,8 0,0,0 26,44" class="nofill"></path>
    <line x1="26" y1="44" x2="24" y2="48" class="solid"></line>
    <line x1="32" y1="40" x2="44" y2="40" class="solid"></line>
    <path d="M 24,48 A 16,16 0,0,0 24,64" class="nofill"></path>
    <line x1="24" y1="64" x2="26" y2="68" class="solid"></line>
    <path d="M 26,68 A 8,8 0,0,0 32,72" class="nofill"></path>
    <line x1="32" y1="72" x2="40" y2="72" class="solid"></line>
    <path d="M 40,72 A 8,8 0,0,1 46,76" class="nofill"></path>
    <line x1="46" y1="76" x2="60" y2="104" class="solid"></line>
    <line x1="72" y1="80" x2="60" y2="104" class="solid"></line>
  </g>
</svg></pre>
<h2 id="mdbook-emojicodes"><a class="header" href="#mdbook-emojicodes"><code>mdbook-emojicodes</code></a></h2>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">I love cats üê± and dogs üê∂, I have two, one's gray, like a raccoon ü¶ù, and the other
one is black, like the night üåÉ.
</code></pre>
<p>will render as the following:</p>
<p>I love cats üê± and dogs üê∂, I have two, one‚Äôs gray, like a raccoon ü¶ù, and the other
one is black, like the night üåÉ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">LICENSE</a></h1>
<h1 id="the-mit-license"><a class="header" href="#the-mit-license">The MIT License</a></h1>
<p>Copyright (c) 2023 Ratatui Developers</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p><img src="https://contrib.rocks/image?repo=ratatui-org/ratatui" alt="https://github.com/ratatui-org/ratatui/graphs/contributors" /></p>
<p>See <a href="https://github.com/ratatui-org/ratatui/graphs/contributors">the contributors graph</a> on GitHub
for more up to date information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>