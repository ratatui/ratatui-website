---
export interface Props {
  width?: number;
  height?: number;
  gridSize?: number;
  numClusters?: number;
  dotsPerCluster?: number;
  clusterRadius?: number;
  dotSize?: number;
  colors?: string[];
  pattern?: "random" | "circular" | "dense" | "sparse";
  opacity?: number;
  fixed?: boolean;
}

const {
  width = 1920,
  height = 1080,
  gridSize = 20,
  numClusters = 5,
  dotsPerCluster = 20,
  clusterRadius = 80,
  dotSize = 4,
  colors = ["#3b82f6", "#8b5cf6", "#ec4899", "#f59e0b", "#10b981"],
  pattern = "random",
  opacity = 0.6,
  fixed = true,
} = Astro.props;

interface Point {
  x: number;
  y: number;
  color: string;
  size: number;
}

// Snap coordinate to grid
function snapToGrid(coord: number, gridSize: number): number {
  return Math.round(coord / gridSize) * gridSize;
}

// Get grid cell center from coordinate
function getGridCell(x: number, y: number, gridSize: number): { x: number; y: number } {
  return {
    x: snapToGrid(x, gridSize),
    y: snapToGrid(y, gridSize),
  };
}

// Generate cluster center relative to viewport center (0,0)
function generateClusterCenter(): { x: number; y: number } {
  const rawX = (Math.random() - 0.5) * width * 0.8; // Centered distribution
  const rawY = (Math.random() - 0.5) * height * 0.8;
  return getGridCell(rawX, rawY, gridSize);
}

function generateRandomPattern(center: { x: number; y: number }, count: number): Point[] {
  const dots: Point[] = [];
  const usedCells = new Set<string>();

  let attempts = 0;
  const maxAttempts = count * 10;

  while (dots.length < count && attempts < maxAttempts) {
    attempts++;

    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * clusterRadius;
    const rawX = center.x + Math.cos(angle) * distance;
    const rawY = center.y + Math.sin(angle) * distance;

    const snapped = getGridCell(rawX, rawY, gridSize);
    const cellKey = `${snapped.x},${snapped.y}`;

    if (!usedCells.has(cellKey)) {
      usedCells.add(cellKey);
      dots.push({
        x: snapped.x,
        y: snapped.y,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: dotSize,
      });
    }
  }

  return dots;
}

function generateCircularPattern(center: { x: number; y: number }, count: number): Point[] {
  const dots: Point[] = [];
  const usedCells = new Set<string>();

  const maxRings = Math.ceil(clusterRadius / gridSize);

  for (let ring = 0; ring <= maxRings && dots.length < count; ring++) {
    const radius = ring * gridSize;
    const circumference = 2 * Math.PI * radius;
    const dotsInRing = ring === 0 ? 1 : Math.floor(circumference / gridSize);

    for (let i = 0; i < dotsInRing && dots.length < count; i++) {
      const angle = (i / dotsInRing) * Math.PI * 2;
      const rawX = center.x + Math.cos(angle) * radius;
      const rawY = center.y + Math.sin(angle) * radius;

      const snapped = getGridCell(rawX, rawY, gridSize);
      const cellKey = `${snapped.x},${snapped.y}`;

      if (!usedCells.has(cellKey)) {
        usedCells.add(cellKey);
        dots.push({
          x: snapped.x,
          y: snapped.y,
          color: colors[ring % colors.length],
          size: dotSize,
        });
      }
    }
  }

  return dots;
}

function generateDensePattern(center: { x: number; y: number }, count: number): Point[] {
  const dots: Point[] = [];
  const usedCells = new Set<string>();

  const gridRadius = Math.ceil(Math.sqrt(count) / 2);

  for (let dx = -gridRadius; dx <= gridRadius && dots.length < count; dx++) {
    for (let dy = -gridRadius; dy <= gridRadius && dots.length < count; dy++) {
      const x = center.x + dx * gridSize;
      const y = center.y + dy * gridSize;

      const distance = Math.hypot(dx, dy) * gridSize;
      if (distance <= clusterRadius) {
        const cellKey = `${x},${y}`;

        if (!usedCells.has(cellKey)) {
          usedCells.add(cellKey);
          dots.push({
            x,
            y,
            color: colors[Math.abs(dx + dy) % colors.length],
            size: dotSize,
          });
        }
      }
    }
  }

  return dots;
}

function generateSparsePattern(center: { x: number; y: number }, count: number): Point[] {
  const dots: Point[] = [];
  const usedCells = new Set<string>();

  let attempts = 0;
  const maxAttempts = count * 20;

  while (dots.length < count && attempts < maxAttempts) {
    attempts++;

    const gridSteps = Math.floor(clusterRadius / gridSize);
    const dx = Math.floor(Math.random() * gridSteps * 2) - gridSteps;
    const dy = Math.floor(Math.random() * gridSteps * 2) - gridSteps;

    const x = center.x + dx * gridSize;
    const y = center.y + dy * gridSize;
    const cellKey = `${x},${y}`;

    if (!usedCells.has(cellKey)) {
      usedCells.add(cellKey);
      dots.push({
        x,
        y,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: dotSize,
      });
    }
  }

  return dots;
}

// Generate all clusters with grid-aligned dots
const allDots: Point[] = [];
for (let i = 0; i < numClusters; i++) {
  const center = generateClusterCenter();
  let clusterDots: Point[];

  switch (pattern) {
    case "circular":
      clusterDots = generateCircularPattern(center, dotsPerCluster);
      break;
    case "dense":
      clusterDots = generateDensePattern(center, dotsPerCluster);
      break;
    case "sparse":
      clusterDots = generateSparsePattern(center, dotsPerCluster);
      break;
    default:
      clusterDots = generateRandomPattern(center, dotsPerCluster);
  }

  allDots.push(...clusterDots);
}
---

<div class="dot-background" class:list={[{ fixed }]}>
  <svg
    width={width}
    height={height}
    viewBox={`${-width / 2} ${-height / 2} ${width} ${height}`}
    xmlns="http://www.w3.org/2000/svg"
    preserveAspectRatio="xMidYMid slice"
  >
    {
      allDots.map((dot) => (
        <rect
          x={dot.x - dot.size}
          y={dot.y - dot.size}
          width={dot.size * 2}
          height={dot.size * 2}
          fill={dot.color}
          opacity={opacity}
        />
      ))
    }
  </svg>
</div>

<style>
  .dot-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
    pointer-events: none;
  }

  .dot-background.fixed {
    position: fixed;
  }

  .dot-background svg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    min-width: 100%;
    min-height: 100%;
    width: auto;
    height: auto;
  }

  circle {
    transition: opacity 0.3s ease;
  }
</style>
