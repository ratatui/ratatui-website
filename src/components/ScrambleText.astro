---
import rat from "@assets/rat.png";
import cheese from "@assets/cheese.png";
import square from "@assets/square.png";
import squareWhite from "@assets/square_white.png";

interface Props {
  classNames: string;
}
---

<div
  class="scramble-text py-4 text-center text-lg tracking-[0.2rem] text-slate-500 max-lg:hidden"
  data-original=""
  data-rat={rat.src}
  data-cheese={cheese.src}
  data-square={square.src}
  data-square-white={squareWhite.src}
>
</div>

<style>
  .scramble-text {
    cursor: pointer;
    transition: color 0.3s ease;
  }
</style>

<script>
  class TextScrambler {
    private element: HTMLElement;
    private originalText: string;
    private isScrambling: boolean = false;
    private isUnscrambling: boolean = false;
    private scrambleInterval: number | null = null;
    private images: string[];
    private squareCount: number = 20;
    private themeObserver: MutationObserver | null = null;
    private pendingThemeUpdate: boolean = false;

    constructor(element: HTMLElement) {
      this.element = element;
      this.originalText = element.getAttribute("data-original") || element.textContent || "";

      // Read image paths from data attributes
      const ratImg = element.getAttribute("data-rat") || "";
      const cheeseImg = element.getAttribute("data-cheese") || "";
      this.images = [ratImg, cheeseImg];

      // Initialize with correct square images based on theme
      this.initializeSquares();
      this.init();
      this.observeThemeChanges();
    }

    init(): void {
      this.element.addEventListener("mouseenter", () => this.scramble());
      this.element.addEventListener("mouseleave", () => this.unscramble());
    }

    private observeThemeChanges(): void {
      this.themeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "data-theme") {
            if (!this.isScrambling && !this.isUnscrambling) {
              // Update immediately if not animating
              this.initializeSquares();
            } else {
              // Flag for update after animation completes
              this.pendingThemeUpdate = true;
            }
          }
        });
      });

      // Observe the documentElement for data-theme attribute changes
      this.themeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ["data-theme"],
      });
    }

    private initializeSquares(): void {
      const squareImg = this.getCurrentSquareImage();
      this.element.innerHTML = Array.from({ length: this.squareCount })
        .map(() => this.createImageTag(squareImg))
        .join("");
      this.pendingThemeUpdate = false;
    }

    private createImageTag(src: string): string {
      return `<img class="w-10 inline align-bottom px-2" src="${src}" alt="" />`;
    }

    private getCurrentSquareImage(): string {
      const theme = document.documentElement.getAttribute("data-theme");
      if (theme === "light") {
        return this.element.getAttribute("data-square-white") || "";
      }
      return this.element.getAttribute("data-square") || "";
    }

    scramble(): void {
      if (this.scrambleInterval !== null) {
        clearInterval(this.scrambleInterval);
        this.scrambleInterval = null;
      }

      this.isUnscrambling = false;
      this.isScrambling = true;

      let frame = 0;
      const maxFrames = 60;

      this.scrambleInterval = window.setInterval(() => {
        if (!this.isScrambling) {
          if (this.scrambleInterval !== null) {
            clearInterval(this.scrambleInterval);
            this.scrambleInterval = null;
          }
          return;
        }

        const scrambled = Array.from({ length: this.squareCount })
          .map(() => {
            const randomImage = this.images[Math.floor(Math.random() * this.images.length)];
            return this.createImageTag(randomImage);
          })
          .join("");

        this.element.innerHTML = scrambled;
        frame++;

        if (frame >= maxFrames) {
          if (this.scrambleInterval !== null) {
            clearInterval(this.scrambleInterval);
            this.scrambleInterval = null;
          }
          this.isScrambling = false;

          // Apply pending theme update if theme changed during scramble
          if (this.pendingThemeUpdate) {
            this.initializeSquares();
          }
        }
      }, 1000 / 60);
    }

    unscramble(): void {
      if (this.scrambleInterval !== null) {
        clearInterval(this.scrambleInterval);
        this.scrambleInterval = null;
      }

      this.isScrambling = false;
      this.isUnscrambling = true;

      let frame = 0;
      const maxFrames = 60;

      this.scrambleInterval = window.setInterval(() => {
        if (!this.isUnscrambling) {
          if (this.scrambleInterval !== null) {
            clearInterval(this.scrambleInterval);
            this.scrambleInterval = null;
          }
          return;
        }

        const squareImg = this.getCurrentSquareImage();

        const scrambled = Array.from({ length: this.squareCount })
          .map((_, index) => {
            const progress = frame / maxFrames;
            const revealThreshold = index / this.squareCount;

            if (progress > revealThreshold) {
              return this.createImageTag(squareImg);
            }

            const randomImage = this.images[Math.floor(Math.random() * this.images.length)];
            return this.createImageTag(randomImage);
          })
          .join("");

        this.element.innerHTML = scrambled;
        frame++;

        if (frame >= maxFrames) {
          const finalSquareImg = this.getCurrentSquareImage();
          this.element.innerHTML = Array.from({ length: this.squareCount })
            .map(() => this.createImageTag(finalSquareImg))
            .join("");
          if (this.scrambleInterval !== null) {
            clearInterval(this.scrambleInterval);
            this.scrambleInterval = null;
          }
          this.isUnscrambling = false;

          // Apply pending theme update if theme changed during unscramble
          if (this.pendingThemeUpdate) {
            this.initializeSquares();
          }
        }
      }, 1000 / 60);
    }

    disconnect(): void {
      if (this.themeObserver) {
        this.themeObserver.disconnect();
      }
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const elements = document.querySelectorAll<HTMLElement>(".scramble-text");
    elements.forEach((element) => new TextScrambler(element));
  });
</script>
